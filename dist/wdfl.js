(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.wdfl = global.wdfl || {})));
}(this, (function (exports) { 'use strict';

	var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};



	function unwrapExports (x) {
		return x && x.__esModule ? x['default'] : x;
	}

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	var isObject_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	function isObject(value) {
	    var type = typeof value;
	    return value != null && (type == 'object' || type == 'function');
	}
	exports.default = isObject;
	});

	var _baseCreate = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var isObject_js_1 = isObject_1;
	var objectCreate = Object.create;
	var baseCreate = (function () {
	    function object() { }
	    return function (proto) {
	        if (!isObject_js_1.default(proto)) {
	            return {};
	        }
	        if (objectCreate) {
	            return objectCreate(proto);
	        }
	        object.prototype = proto;
	        var result = new object;
	        object.prototype = undefined;
	        return result;
	    };
	}());
	exports.default = baseCreate;
	});

	var _baseLodash = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	function baseLodash() {
	}
	exports.default = baseLodash;
	});

	var _LodashWrapper = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseCreate_js_1 = _baseCreate;
	var _baseLodash_js_1 = _baseLodash;
	function LodashWrapper(value, chainAll) {
	    this.__wrapped__ = value;
	    this.__actions__ = [];
	    this.__chain__ = !!chainAll;
	    this.__index__ = 0;
	    this.__values__ = undefined;
	}
	LodashWrapper.prototype = _baseCreate_js_1.default(_baseLodash_js_1.default.prototype);
	LodashWrapper.prototype.constructor = LodashWrapper;
	exports.default = LodashWrapper;
	});

	var _arrayPush = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	function arrayPush(array, values) {
	    var index = -1, length = values.length, offset = array.length;
	    while (++index < length) {
	        array[offset + index] = values[index];
	    }
	    return array;
	}
	exports.default = arrayPush;
	});

	var _freeGlobal = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
	exports.default = freeGlobal;
	});

	var _root = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _freeGlobal_js_1 = _freeGlobal;
	var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
	var root = _freeGlobal_js_1.default || freeSelf || Function('return this')();
	exports.default = root;
	});

	var _Symbol = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _root_js_1 = _root;
	var Symbol = _root_js_1.default.Symbol;
	exports.default = Symbol;
	});

	var _getRawTag = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _Symbol_js_1 = _Symbol;
	var objectProto = Object.prototype;
	var hasOwnProperty = objectProto.hasOwnProperty;
	var nativeObjectToString = objectProto.toString;
	var symToStringTag = _Symbol_js_1.default ? _Symbol_js_1.default.toStringTag : undefined;
	function getRawTag(value) {
	    var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
	    try {
	        value[symToStringTag] = undefined;
	        var unmasked = true;
	    }
	    catch (e) { }
	    var result = nativeObjectToString.call(value);
	    if (unmasked) {
	        if (isOwn) {
	            value[symToStringTag] = tag;
	        }
	        else {
	            delete value[symToStringTag];
	        }
	    }
	    return result;
	}
	exports.default = getRawTag;
	});

	var _objectToString = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var objectProto = Object.prototype;
	var nativeObjectToString = objectProto.toString;
	function objectToString(value) {
	    return nativeObjectToString.call(value);
	}
	exports.default = objectToString;
	});

	var _baseGetTag = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _Symbol_js_1 = _Symbol;
	var _getRawTag_js_1 = _getRawTag;
	var _objectToString_js_1 = _objectToString;
	var nullTag = '[object Null]', undefinedTag = '[object Undefined]';
	var symToStringTag = _Symbol_js_1.default ? _Symbol_js_1.default.toStringTag : undefined;
	function baseGetTag(value) {
	    if (value == null) {
	        return value === undefined ? undefinedTag : nullTag;
	    }
	    return (symToStringTag && symToStringTag in Object(value))
	        ? _getRawTag_js_1.default(value)
	        : _objectToString_js_1.default(value);
	}
	exports.default = baseGetTag;
	});

	var isObjectLike_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	function isObjectLike(value) {
	    return value != null && typeof value == 'object';
	}
	exports.default = isObjectLike;
	});

	var _baseIsArguments = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseGetTag_js_1 = _baseGetTag;
	var isObjectLike_js_1 = isObjectLike_1;
	var argsTag = '[object Arguments]';
	function baseIsArguments(value) {
	    return isObjectLike_js_1.default(value) && _baseGetTag_js_1.default(value) == argsTag;
	}
	exports.default = baseIsArguments;
	});

	var isArguments_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseIsArguments_js_1 = _baseIsArguments;
	var isObjectLike_js_1 = isObjectLike_1;
	var objectProto = Object.prototype;
	var hasOwnProperty = objectProto.hasOwnProperty;
	var propertyIsEnumerable = objectProto.propertyIsEnumerable;
	var isArguments = _baseIsArguments_js_1.default(function () { return arguments; }()) ? _baseIsArguments_js_1.default : function (value) {
	    return isObjectLike_js_1.default(value) && hasOwnProperty.call(value, 'callee') &&
	        !propertyIsEnumerable.call(value, 'callee');
	};
	exports.default = isArguments;
	});

	var isArray_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var isArray = Array.isArray;
	exports.default = isArray;
	});

	var _isFlattenable = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _Symbol_js_1 = _Symbol;
	var isArguments_js_1 = isArguments_1;
	var isArray_js_1 = isArray_1;
	var spreadableSymbol = _Symbol_js_1.default ? _Symbol_js_1.default.isConcatSpreadable : undefined;
	function isFlattenable(value) {
	    return isArray_js_1.default(value) || isArguments_js_1.default(value) ||
	        !!(spreadableSymbol && value && value[spreadableSymbol]);
	}
	exports.default = isFlattenable;
	});

	var _baseFlatten = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _arrayPush_js_1 = _arrayPush;
	var _isFlattenable_js_1 = _isFlattenable;
	function baseFlatten(array, depth, predicate, isStrict, result) {
	    var index = -1, length = array.length;
	    predicate || (predicate = _isFlattenable_js_1.default);
	    result || (result = []);
	    while (++index < length) {
	        var value = array[index];
	        if (depth > 0 && predicate(value)) {
	            if (depth > 1) {
	                baseFlatten(value, depth - 1, predicate, isStrict, result);
	            }
	            else {
	                _arrayPush_js_1.default(result, value);
	            }
	        }
	        else if (!isStrict) {
	            result[result.length] = value;
	        }
	    }
	    return result;
	}
	exports.default = baseFlatten;
	});

	var flatten_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseFlatten_js_1 = _baseFlatten;
	function flatten(array) {
	    var length = array == null ? 0 : array.length;
	    return length ? _baseFlatten_js_1.default(array, 1) : [];
	}
	exports.default = flatten;
	});

	var _apply = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	function apply(func, thisArg, args) {
	    switch (args.length) {
	        case 0: return func.call(thisArg);
	        case 1: return func.call(thisArg, args[0]);
	        case 2: return func.call(thisArg, args[0], args[1]);
	        case 3: return func.call(thisArg, args[0], args[1], args[2]);
	    }
	    return func.apply(thisArg, args);
	}
	exports.default = apply;
	});

	var _overRest = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _apply_js_1 = _apply;
	var nativeMax = Math.max;
	function overRest(func, start, transform) {
	    start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
	    return function () {
	        var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
	        while (++index < length) {
	            array[index] = args[start + index];
	        }
	        index = -1;
	        var otherArgs = Array(start + 1);
	        while (++index < start) {
	            otherArgs[index] = args[index];
	        }
	        otherArgs[start] = transform(array);
	        return _apply_js_1.default(func, this, otherArgs);
	    };
	}
	exports.default = overRest;
	});

	var constant_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	function constant(value) {
	    return function () {
	        return value;
	    };
	}
	exports.default = constant;
	});

	var isFunction_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseGetTag_js_1 = _baseGetTag;
	var isObject_js_1 = isObject_1;
	var asyncTag = '[object AsyncFunction]', funcTag = '[object Function]', genTag = '[object GeneratorFunction]', proxyTag = '[object Proxy]';
	function isFunction(value) {
	    if (!isObject_js_1.default(value)) {
	        return false;
	    }
	    var tag = _baseGetTag_js_1.default(value);
	    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
	}
	exports.default = isFunction;
	});

	var _coreJsData = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _root_js_1 = _root;
	var coreJsData = _root_js_1.default['__core-js_shared__'];
	exports.default = coreJsData;
	});

	var _isMasked = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _coreJsData_js_1 = _coreJsData;
	var maskSrcKey = (function () {
	    var uid = /[^.]+$/.exec(_coreJsData_js_1.default && _coreJsData_js_1.default.keys && _coreJsData_js_1.default.keys.IE_PROTO || '');
	    return uid ? ('Symbol(src)_1.' + uid) : '';
	}());
	function isMasked(func) {
	    return !!maskSrcKey && (maskSrcKey in func);
	}
	exports.default = isMasked;
	});

	var _toSource = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var funcProto = Function.prototype;
	var funcToString = funcProto.toString;
	function toSource(func) {
	    if (func != null) {
	        try {
	            return funcToString.call(func);
	        }
	        catch (e) { }
	        try {
	            return (func + '');
	        }
	        catch (e) { }
	    }
	    return '';
	}
	exports.default = toSource;
	});

	var _baseIsNative = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var isFunction_js_1 = isFunction_1;
	var _isMasked_js_1 = _isMasked;
	var isObject_js_1 = isObject_1;
	var _toSource_js_1 = _toSource;
	var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
	var reIsHostCtor = /^\[object .+?Constructor\]$/;
	var funcProto = Function.prototype, objectProto = Object.prototype;
	var funcToString = funcProto.toString;
	var hasOwnProperty = objectProto.hasOwnProperty;
	var reIsNative = RegExp('^' +
	    funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
	        .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
	function baseIsNative(value) {
	    if (!isObject_js_1.default(value) || _isMasked_js_1.default(value)) {
	        return false;
	    }
	    var pattern = isFunction_js_1.default(value) ? reIsNative : reIsHostCtor;
	    return pattern.test(_toSource_js_1.default(value));
	}
	exports.default = baseIsNative;
	});

	var _getValue = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	function getValue(object, key) {
	    return object == null ? undefined : object[key];
	}
	exports.default = getValue;
	});

	var _getNative = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseIsNative_js_1 = _baseIsNative;
	var _getValue_js_1 = _getValue;
	function getNative(object, key) {
	    var value = _getValue_js_1.default(object, key);
	    return _baseIsNative_js_1.default(value) ? value : undefined;
	}
	exports.default = getNative;
	});

	var _defineProperty = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _getNative_js_1 = _getNative;
	var defineProperty = (function () {
	    try {
	        var func = _getNative_js_1.default(Object, 'defineProperty');
	        func({}, '', {});
	        return func;
	    }
	    catch (e) { }
	}());
	exports.default = defineProperty;
	});

	var identity_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	function identity(value) {
	    return value;
	}
	exports.default = identity;
	});

	var _baseSetToString = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var constant_js_1 = constant_1;
	var _defineProperty_js_1 = _defineProperty;
	var identity_js_1 = identity_1;
	var baseSetToString = !_defineProperty_js_1.default ? identity_js_1.default : function (func, string) {
	    return _defineProperty_js_1.default(func, 'toString', {
	        'configurable': true,
	        'enumerable': false,
	        'value': constant_js_1.default(string),
	        'writable': true
	    });
	};
	exports.default = baseSetToString;
	});

	var _shortOut = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var HOT_COUNT = 800, HOT_SPAN = 16;
	var nativeNow = Date.now;
	function shortOut(func) {
	    var count = 0, lastCalled = 0;
	    return function () {
	        var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
	        lastCalled = stamp;
	        if (remaining > 0) {
	            if (++count >= HOT_COUNT) {
	                return arguments[0];
	            }
	        }
	        else {
	            count = 0;
	        }
	        return func.apply(undefined, arguments);
	    };
	}
	exports.default = shortOut;
	});

	var _setToString = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseSetToString_js_1 = _baseSetToString;
	var _shortOut_js_1 = _shortOut;
	var setToString = _shortOut_js_1.default(_baseSetToString_js_1.default);
	exports.default = setToString;
	});

	var _flatRest = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var flatten_js_1 = flatten_1;
	var _overRest_js_1 = _overRest;
	var _setToString_js_1 = _setToString;
	function flatRest(func) {
	    return _setToString_js_1.default(_overRest_js_1.default(func, undefined, flatten_js_1.default), func + '');
	}
	exports.default = flatRest;
	});

	var _WeakMap = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _getNative_js_1 = _getNative;
	var _root_js_1 = _root;
	var WeakMap = _getNative_js_1.default(_root_js_1.default, 'WeakMap');
	exports.default = WeakMap;
	});

	var _metaMap = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _WeakMap_js_1 = _WeakMap;
	var metaMap = _WeakMap_js_1.default && new _WeakMap_js_1.default;
	exports.default = metaMap;
	});

	var noop_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	function noop() {
	}
	exports.default = noop;
	});

	var _getData = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _metaMap_js_1 = _metaMap;
	var noop_js_1 = noop_1;
	var getData = !_metaMap_js_1.default ? noop_js_1.default : function (func) {
	    return _metaMap_js_1.default.get(func);
	};
	exports.default = getData;
	});

	var _realNames = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var realNames = {};
	exports.default = realNames;
	});

	var _getFuncName = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _realNames_js_1 = _realNames;
	var objectProto = Object.prototype;
	var hasOwnProperty = objectProto.hasOwnProperty;
	function getFuncName(func) {
	    var result = (func.name + ''), array = _realNames_js_1.default[result], length = hasOwnProperty.call(_realNames_js_1.default, result) ? array.length : 0;
	    while (length--) {
	        var data = array[length], otherFunc = data.func;
	        if (otherFunc == null || otherFunc == func) {
	            return data.name;
	        }
	    }
	    return result;
	}
	exports.default = getFuncName;
	});

	var _LazyWrapper = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseCreate_js_1 = _baseCreate;
	var _baseLodash_js_1 = _baseLodash;
	var MAX_ARRAY_LENGTH = 4294967295;
	function LazyWrapper(value) {
	    this.__wrapped__ = value;
	    this.__actions__ = [];
	    this.__dir__ = 1;
	    this.__filtered__ = false;
	    this.__iteratees__ = [];
	    this.__takeCount__ = MAX_ARRAY_LENGTH;
	    this.__views__ = [];
	}
	LazyWrapper.prototype = _baseCreate_js_1.default(_baseLodash_js_1.default.prototype);
	LazyWrapper.prototype.constructor = LazyWrapper;
	exports.default = LazyWrapper;
	});

	var _copyArray = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	function copyArray(source, array) {
	    var index = -1, length = source.length;
	    array || (array = Array(length));
	    while (++index < length) {
	        array[index] = source[index];
	    }
	    return array;
	}
	exports.default = copyArray;
	});

	var _wrapperClone = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _LazyWrapper_js_1 = _LazyWrapper;
	var _LodashWrapper_js_1 = _LodashWrapper;
	var _copyArray_js_1 = _copyArray;
	function wrapperClone(wrapper) {
	    if (wrapper instanceof _LazyWrapper_js_1.default) {
	        return wrapper.clone();
	    }
	    var result = new _LodashWrapper_js_1.default(wrapper.__wrapped__, wrapper.__chain__);
	    result.__actions__ = _copyArray_js_1.default(wrapper.__actions__);
	    result.__index__ = wrapper.__index__;
	    result.__values__ = wrapper.__values__;
	    return result;
	}
	exports.default = wrapperClone;
	});

	var wrapperLodash = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _LazyWrapper_js_1 = _LazyWrapper;
	var _LodashWrapper_js_1 = _LodashWrapper;
	var _baseLodash_js_1 = _baseLodash;
	var isArray_js_1 = isArray_1;
	var isObjectLike_js_1 = isObjectLike_1;
	var _wrapperClone_js_1 = _wrapperClone;
	var objectProto = Object.prototype;
	var hasOwnProperty = objectProto.hasOwnProperty;
	function lodash(value) {
	    if (isObjectLike_js_1.default(value) && !isArray_js_1.default(value) && !(value instanceof _LazyWrapper_js_1.default)) {
	        if (value instanceof _LodashWrapper_js_1.default) {
	            return value;
	        }
	        if (hasOwnProperty.call(value, '__wrapped__')) {
	            return _wrapperClone_js_1.default(value);
	        }
	    }
	    return new _LodashWrapper_js_1.default(value);
	}
	lodash.prototype = _baseLodash_js_1.default.prototype;
	lodash.prototype.constructor = lodash;
	exports.default = lodash;
	});

	var _isLaziable = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _LazyWrapper_js_1 = _LazyWrapper;
	var _getData_js_1 = _getData;
	var _getFuncName_js_1 = _getFuncName;
	var wrapperLodash_js_1 = wrapperLodash;
	function isLaziable(func) {
	    var funcName = _getFuncName_js_1.default(func), other = wrapperLodash_js_1.default[funcName];
	    if (typeof other != 'function' || !(funcName in _LazyWrapper_js_1.default.prototype)) {
	        return false;
	    }
	    if (func === other) {
	        return true;
	    }
	    var data = _getData_js_1.default(other);
	    return !!data && func === data[0];
	}
	exports.default = isLaziable;
	});

	var _createFlow = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _LodashWrapper_js_1 = _LodashWrapper;
	var _flatRest_js_1 = _flatRest;
	var _getData_js_1 = _getData;
	var _getFuncName_js_1 = _getFuncName;
	var isArray_js_1 = isArray_1;
	var _isLaziable_js_1 = _isLaziable;
	var FUNC_ERROR_TEXT = 'Expected a function';
	var WRAP_CURRY_FLAG = 8, WRAP_PARTIAL_FLAG = 32, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256;
	function createFlow(fromRight) {
	    return _flatRest_js_1.default(function (funcs) {
	        var length = funcs.length, index = length, prereq = _LodashWrapper_js_1.default.prototype.thru;
	        if (fromRight) {
	            funcs.reverse();
	        }
	        while (index--) {
	            var func = funcs[index];
	            if (typeof func != 'function') {
	                throw new TypeError(FUNC_ERROR_TEXT);
	            }
	            if (prereq && !wrapper && _getFuncName_js_1.default(func) == 'wrapper') {
	                var wrapper = new _LodashWrapper_js_1.default([], true);
	            }
	        }
	        index = wrapper ? index : length;
	        while (++index < length) {
	            func = funcs[index];
	            var funcName = _getFuncName_js_1.default(func), data = funcName == 'wrapper' ? _getData_js_1.default(func) : undefined;
	            if (data && _isLaziable_js_1.default(data[0]) &&
	                data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) &&
	                !data[4].length && data[9] == 1) {
	                wrapper = wrapper[_getFuncName_js_1.default(data[0])].apply(wrapper, data[3]);
	            }
	            else {
	                wrapper = (func.length == 1 && _isLaziable_js_1.default(func))
	                    ? wrapper[funcName]()
	                    : wrapper.thru(func);
	            }
	        }
	        return function () {
	            var args = arguments, value = args[0];
	            if (wrapper && args.length == 1 && isArray_js_1.default(value)) {
	                return wrapper.plant(value).value();
	            }
	            var index = 0, result = length ? funcs[index].apply(this, args) : value;
	            while (++index < length) {
	                result = funcs[index].call(this, result);
	            }
	            return result;
	        };
	    });
	}
	exports.default = createFlow;
	});

	var flowRight_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _createFlow_js_1 = _createFlow;
	var flowRight = _createFlow_js_1.default(true);
	exports.default = flowRight;
	});

	var flowRight = unwrapExports(flowRight_1);

	var _arrayMap = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	function arrayMap(array, iteratee) {
	    var index = -1, length = array == null ? 0 : array.length, result = Array(length);
	    while (++index < length) {
	        result[index] = iteratee(array[index], index, array);
	    }
	    return result;
	}
	exports.default = arrayMap;
	});

	var isSymbol_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseGetTag_js_1 = _baseGetTag;
	var isObjectLike_js_1 = isObjectLike_1;
	var symbolTag = '[object Symbol]';
	function isSymbol(value) {
	    return typeof value == 'symbol' ||
	        (isObjectLike_js_1.default(value) && _baseGetTag_js_1.default(value) == symbolTag);
	}
	exports.default = isSymbol;
	});

	var _baseToString = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _Symbol_js_1 = _Symbol;
	var _arrayMap_js_1 = _arrayMap;
	var isArray_js_1 = isArray_1;
	var isSymbol_js_1 = isSymbol_1;
	var INFINITY = 1 / 0;
	var symbolProto = _Symbol_js_1.default ? _Symbol_js_1.default.prototype : undefined, symbolToString = symbolProto ? symbolProto.toString : undefined;
	function baseToString(value) {
	    if (typeof value == 'string') {
	        return value;
	    }
	    if (isArray_js_1.default(value)) {
	        return _arrayMap_js_1.default(value, baseToString) + '';
	    }
	    if (isSymbol_js_1.default(value)) {
	        return symbolToString ? symbolToString.call(value) : '';
	    }
	    var result = (value + '');
	    return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
	}
	exports.default = baseToString;
	});

	var toString_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseToString_js_1 = _baseToString;
	function toString(value) {
	    return value == null ? '' : _baseToString_js_1.default(value);
	}
	exports.default = toString;
	});

	var toString$1 = unwrapExports(toString_1);

	function __extends(d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	}

	function __decorate(decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	}

	var IO = (function () {
	    function IO(func) {
	        this.func = null;
	        this.func = func;
	    }
	    IO.of = function (func) {
	        var obj = new this(func);
	        return obj;
	    };
	    IO.prototype.chain = function (f) {
	        var io = this;
	        return IO.of(function () {
	            var next = f(io.func.apply(io, arguments));
	            return next.func.apply(next, arguments);
	        });
	    };
	    IO.prototype.map = function (f) {
	        return IO.of(flowRight(f, this.func));
	    };
	    
	    IO.prototype.ap = function (thatIO) {
	        return this.chain(function (f) {
	            return thatIO.map(f);
	        });
	    };
	    
	    IO.prototype.run = function () {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i] = arguments[_i];
	        }
	        return this.func.apply(this, arguments);
	    };
	    
	    IO.prototype.toString = function () {
	        return "IO(" + toString$1(this.func) + ")";
	    };
	    return IO;
	}());

	var _baseToNumber = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var isSymbol_js_1 = isSymbol_1;
	var NAN = 0 / 0;
	function baseToNumber(value) {
	    if (typeof value == 'number') {
	        return value;
	    }
	    if (isSymbol_js_1.default(value)) {
	        return NAN;
	    }
	    return +value;
	}
	exports.default = baseToNumber;
	});

	var _createMathOperation = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseToNumber_js_1 = _baseToNumber;
	var _baseToString_js_1 = _baseToString;
	function createMathOperation(operator, defaultValue) {
	    return function (value, other) {
	        var result;
	        if (value === undefined && other === undefined) {
	            return defaultValue;
	        }
	        if (value !== undefined) {
	            result = value;
	        }
	        if (other !== undefined) {
	            if (result === undefined) {
	                return other;
	            }
	            if (typeof value == 'string' || typeof other == 'string') {
	                value = _baseToString_js_1.default(value);
	                other = _baseToString_js_1.default(other);
	            }
	            else {
	                value = _baseToNumber_js_1.default(value);
	                other = _baseToNumber_js_1.default(other);
	            }
	            result = operator(value, other);
	        }
	        return result;
	    };
	}
	exports.default = createMathOperation;
	});

	var add_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _createMathOperation_js_1 = _createMathOperation;
	var add = _createMathOperation_js_1.default(function (augend, addend) {
	    return augend + addend;
	}, 0);
	exports.default = add;
	});

	var toNumber_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var isObject_js_1 = isObject_1;
	var isSymbol_js_1 = isSymbol_1;
	var NAN = 0 / 0;
	var reTrim = /^\s+|\s+$/g;
	var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
	var reIsBinary = /^0b[01]+$/i;
	var reIsOctal = /^0o[0-7]+$/i;
	var freeParseInt = parseInt;
	function toNumber(value) {
	    if (typeof value == 'number') {
	        return value;
	    }
	    if (isSymbol_js_1.default(value)) {
	        return NAN;
	    }
	    if (isObject_js_1.default(value)) {
	        var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
	        value = isObject_js_1.default(other) ? (other + '') : other;
	    }
	    if (typeof value != 'string') {
	        return value === 0 ? value : +value;
	    }
	    value = value.replace(reTrim, '');
	    var isBinary = reIsBinary.test(value);
	    return (isBinary || reIsOctal.test(value))
	        ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
	        : (reIsBadHex.test(value) ? NAN : +value);
	}
	exports.default = toNumber;
	});

	var toFinite_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var toNumber_js_1 = toNumber_1;
	var INFINITY = 1 / 0, MAX_INTEGER = 1.7976931348623157e+308;
	function toFinite(value) {
	    if (!value) {
	        return value === 0 ? value : 0;
	    }
	    value = toNumber_js_1.default(value);
	    if (value === INFINITY || value === -INFINITY) {
	        var sign = (value < 0 ? -1 : 1);
	        return sign * MAX_INTEGER;
	    }
	    return value === value ? value : 0;
	}
	exports.default = toFinite;
	});

	var toInteger_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var toFinite_js_1 = toFinite_1;
	function toInteger(value) {
	    var result = toFinite_js_1.default(value), remainder = result % 1;
	    return result === result ? (remainder ? result - remainder : result) : 0;
	}
	exports.default = toInteger;
	});

	var after_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var toInteger_js_1 = toInteger_1;
	var FUNC_ERROR_TEXT = 'Expected a function';
	function after(n, func) {
	    if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	    }
	    n = toInteger_js_1.default(n);
	    return function () {
	        if (--n < 1) {
	            return func.apply(this, arguments);
	        }
	    };
	}
	exports.default = after;
	});

	var _baseSetData = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var identity_js_1 = identity_1;
	var _metaMap_js_1 = _metaMap;
	var baseSetData = !_metaMap_js_1.default ? identity_js_1.default : function (func, data) {
	    _metaMap_js_1.default.set(func, data);
	    return func;
	};
	exports.default = baseSetData;
	});

	var _createCtor = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseCreate_js_1 = _baseCreate;
	var isObject_js_1 = isObject_1;
	function createCtor(Ctor) {
	    return function () {
	        var args = arguments;
	        switch (args.length) {
	            case 0: return new Ctor;
	            case 1: return new Ctor(args[0]);
	            case 2: return new Ctor(args[0], args[1]);
	            case 3: return new Ctor(args[0], args[1], args[2]);
	            case 4: return new Ctor(args[0], args[1], args[2], args[3]);
	            case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);
	            case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
	            case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
	        }
	        var thisBinding = _baseCreate_js_1.default(Ctor.prototype), result = Ctor.apply(thisBinding, args);
	        return isObject_js_1.default(result) ? result : thisBinding;
	    };
	}
	exports.default = createCtor;
	});

	var _createBind = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _createCtor_js_1 = _createCtor;
	var _root_js_1 = _root;
	var WRAP_BIND_FLAG = 1;
	function createBind(func, bitmask, thisArg) {
	    var isBind = bitmask & WRAP_BIND_FLAG, Ctor = _createCtor_js_1.default(func);
	    function wrapper() {
	        var fn = (this && this !== _root_js_1.default && this instanceof wrapper) ? Ctor : func;
	        return fn.apply(isBind ? thisArg : this, arguments);
	    }
	    return wrapper;
	}
	exports.default = createBind;
	});

	var _composeArgs = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var nativeMax = Math.max;
	function composeArgs(args, partials, holders, isCurried) {
	    var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result = Array(leftLength + rangeLength), isUncurried = !isCurried;
	    while (++leftIndex < leftLength) {
	        result[leftIndex] = partials[leftIndex];
	    }
	    while (++argsIndex < holdersLength) {
	        if (isUncurried || argsIndex < argsLength) {
	            result[holders[argsIndex]] = args[argsIndex];
	        }
	    }
	    while (rangeLength--) {
	        result[leftIndex++] = args[argsIndex++];
	    }
	    return result;
	}
	exports.default = composeArgs;
	});

	var _composeArgsRight = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var nativeMax = Math.max;
	function composeArgsRight(args, partials, holders, isCurried) {
	    var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result = Array(rangeLength + rightLength), isUncurried = !isCurried;
	    while (++argsIndex < rangeLength) {
	        result[argsIndex] = args[argsIndex];
	    }
	    var offset = argsIndex;
	    while (++rightIndex < rightLength) {
	        result[offset + rightIndex] = partials[rightIndex];
	    }
	    while (++holdersIndex < holdersLength) {
	        if (isUncurried || argsIndex < argsLength) {
	            result[offset + holders[holdersIndex]] = args[argsIndex++];
	        }
	    }
	    return result;
	}
	exports.default = composeArgsRight;
	});

	var _countHolders = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	function countHolders(array, placeholder) {
	    var length = array.length, result = 0;
	    while (length--) {
	        if (array[length] === placeholder) {
	            ++result;
	        }
	    }
	    return result;
	}
	exports.default = countHolders;
	});

	var _setData = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseSetData_js_1 = _baseSetData;
	var _shortOut_js_1 = _shortOut;
	var setData = _shortOut_js_1.default(_baseSetData_js_1.default);
	exports.default = setData;
	});

	var _getWrapDetails = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
	function getWrapDetails(source) {
	    var match = source.match(reWrapDetails);
	    return match ? match[1].split(reSplitDetails) : [];
	}
	exports.default = getWrapDetails;
	});

	var _insertWrapDetails = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/;
	function insertWrapDetails(source, details) {
	    var length = details.length;
	    if (!length) {
	        return source;
	    }
	    var lastIndex = length - 1;
	    details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];
	    details = details.join(length > 2 ? ', ' : ' ');
	    return source.replace(reWrapComment, '{\n/* [wrapped with ' + details + '] */\n');
	}
	exports.default = insertWrapDetails;
	});

	var _arrayEach = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	function arrayEach(array, iteratee) {
	    var index = -1, length = array == null ? 0 : array.length;
	    while (++index < length) {
	        if (iteratee(array[index], index, array) === false) {
	            break;
	        }
	    }
	    return array;
	}
	exports.default = arrayEach;
	});

	var _baseFindIndex = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	function baseFindIndex(array, predicate, fromIndex, fromRight) {
	    var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
	    while ((fromRight ? index-- : ++index < length)) {
	        if (predicate(array[index], index, array)) {
	            return index;
	        }
	    }
	    return -1;
	}
	exports.default = baseFindIndex;
	});

	var _baseIsNaN = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	function baseIsNaN(value) {
	    return value !== value;
	}
	exports.default = baseIsNaN;
	});

	var _strictIndexOf = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	function strictIndexOf(array, value, fromIndex) {
	    var index = fromIndex - 1, length = array.length;
	    while (++index < length) {
	        if (array[index] === value) {
	            return index;
	        }
	    }
	    return -1;
	}
	exports.default = strictIndexOf;
	});

	var _baseIndexOf = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseFindIndex_js_1 = _baseFindIndex;
	var _baseIsNaN_js_1 = _baseIsNaN;
	var _strictIndexOf_js_1 = _strictIndexOf;
	function baseIndexOf(array, value, fromIndex) {
	    return value === value
	        ? _strictIndexOf_js_1.default(array, value, fromIndex)
	        : _baseFindIndex_js_1.default(array, _baseIsNaN_js_1.default, fromIndex);
	}
	exports.default = baseIndexOf;
	});

	var _arrayIncludes = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseIndexOf_js_1 = _baseIndexOf;
	function arrayIncludes(array, value) {
	    var length = array == null ? 0 : array.length;
	    return !!length && _baseIndexOf_js_1.default(array, value, 0) > -1;
	}
	exports.default = arrayIncludes;
	});

	var _updateWrapDetails = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _arrayEach_js_1 = _arrayEach;
	var _arrayIncludes_js_1 = _arrayIncludes;
	var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
	var wrapFlags = [
	    ['ary', WRAP_ARY_FLAG],
	    ['bind', WRAP_BIND_FLAG],
	    ['bindKey', WRAP_BIND_KEY_FLAG],
	    ['curry', WRAP_CURRY_FLAG],
	    ['curryRight', WRAP_CURRY_RIGHT_FLAG],
	    ['flip', WRAP_FLIP_FLAG],
	    ['partial', WRAP_PARTIAL_FLAG],
	    ['partialRight', WRAP_PARTIAL_RIGHT_FLAG],
	    ['rearg', WRAP_REARG_FLAG]
	];
	function updateWrapDetails(details, bitmask) {
	    _arrayEach_js_1.default(wrapFlags, function (pair) {
	        var value = '_.' + pair[0];
	        if ((bitmask & pair[1]) && !_arrayIncludes_js_1.default(details, value)) {
	            details.push(value);
	        }
	    });
	    return details.sort();
	}
	exports.default = updateWrapDetails;
	});

	var _setWrapToString = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _getWrapDetails_js_1 = _getWrapDetails;
	var _insertWrapDetails_js_1 = _insertWrapDetails;
	var _setToString_js_1 = _setToString;
	var _updateWrapDetails_js_1 = _updateWrapDetails;
	function setWrapToString(wrapper, reference, bitmask) {
	    var source = (reference + '');
	    return _setToString_js_1.default(wrapper, _insertWrapDetails_js_1.default(source, _updateWrapDetails_js_1.default(_getWrapDetails_js_1.default(source), bitmask)));
	}
	exports.default = setWrapToString;
	});

	var _createRecurry = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _isLaziable_js_1 = _isLaziable;
	var _setData_js_1 = _setData;
	var _setWrapToString_js_1 = _setWrapToString;
	var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64;
	function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
	    var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined, newHoldersRight = isCurry ? undefined : holders, newPartials = isCurry ? partials : undefined, newPartialsRight = isCurry ? undefined : partials;
	    bitmask |= (isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG);
	    bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
	    if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
	        bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
	    }
	    var newData = [
	        func, bitmask, thisArg, newPartials, newHolders, newPartialsRight,
	        newHoldersRight, argPos, ary, arity
	    ];
	    var result = wrapFunc.apply(undefined, newData);
	    if (_isLaziable_js_1.default(func)) {
	        _setData_js_1.default(result, newData);
	    }
	    result.placeholder = placeholder;
	    return _setWrapToString_js_1.default(result, func, bitmask);
	}
	exports.default = createRecurry;
	});

	var _getHolder = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	function getHolder(func) {
	    var object = func;
	    return object.placeholder;
	}
	exports.default = getHolder;
	});

	var _isIndex = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var MAX_SAFE_INTEGER = 9007199254740991;
	var reIsUint = /^(?:0|[1-9]\d*)$/;
	function isIndex(value, length) {
	    length = length == null ? MAX_SAFE_INTEGER : length;
	    return !!length &&
	        (typeof value == 'number' || reIsUint.test(value)) &&
	        (value > -1 && value % 1 == 0 && value < length);
	}
	exports.default = isIndex;
	});

	var _reorder = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _copyArray_js_1 = _copyArray;
	var _isIndex_js_1 = _isIndex;
	var nativeMin = Math.min;
	function reorder(array, indexes) {
	    var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = _copyArray_js_1.default(array);
	    while (length--) {
	        var index = indexes[length];
	        array[length] = _isIndex_js_1.default(index, arrLength) ? oldArray[index] : undefined;
	    }
	    return array;
	}
	exports.default = reorder;
	});

	var _replaceHolders = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var PLACEHOLDER = '__lodash_placeholder__';
	function replaceHolders(array, placeholder) {
	    var index = -1, length = array.length, resIndex = 0, result = [];
	    while (++index < length) {
	        var value = array[index];
	        if (value === placeholder || value === PLACEHOLDER) {
	            array[index] = PLACEHOLDER;
	            result[resIndex++] = index;
	        }
	    }
	    return result;
	}
	exports.default = replaceHolders;
	});

	var _createHybrid = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _composeArgs_js_1 = _composeArgs;
	var _composeArgsRight_js_1 = _composeArgsRight;
	var _countHolders_js_1 = _countHolders;
	var _createCtor_js_1 = _createCtor;
	var _createRecurry_js_1 = _createRecurry;
	var _getHolder_js_1 = _getHolder;
	var _reorder_js_1 = _reorder;
	var _replaceHolders_js_1 = _replaceHolders;
	var _root_js_1 = _root;
	var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_ARY_FLAG = 128, WRAP_FLIP_FLAG = 512;
	function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
	    var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined : _createCtor_js_1.default(func);
	    function wrapper() {
	        var length = arguments.length, args = Array(length), index = length;
	        while (index--) {
	            args[index] = arguments[index];
	        }
	        if (isCurried) {
	            var placeholder = _getHolder_js_1.default(wrapper), holdersCount = _countHolders_js_1.default(args, placeholder);
	        }
	        if (partials) {
	            args = _composeArgs_js_1.default(args, partials, holders, isCurried);
	        }
	        if (partialsRight) {
	            args = _composeArgsRight_js_1.default(args, partialsRight, holdersRight, isCurried);
	        }
	        length -= holdersCount;
	        if (isCurried && length < arity) {
	            var newHolders = _replaceHolders_js_1.default(args, placeholder);
	            return _createRecurry_js_1.default(func, bitmask, createHybrid, wrapper.placeholder, thisArg, args, newHolders, argPos, ary, arity - length);
	        }
	        var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
	        length = args.length;
	        if (argPos) {
	            args = _reorder_js_1.default(args, argPos);
	        }
	        else if (isFlip && length > 1) {
	            args.reverse();
	        }
	        if (isAry && ary < length) {
	            args.length = ary;
	        }
	        if (this && this !== _root_js_1.default && this instanceof wrapper) {
	            fn = Ctor || _createCtor_js_1.default(fn);
	        }
	        return fn.apply(thisBinding, args);
	    }
	    return wrapper;
	}
	exports.default = createHybrid;
	});

	var _createCurry = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _apply_js_1 = _apply;
	var _createCtor_js_1 = _createCtor;
	var _createHybrid_js_1 = _createHybrid;
	var _createRecurry_js_1 = _createRecurry;
	var _getHolder_js_1 = _getHolder;
	var _replaceHolders_js_1 = _replaceHolders;
	var _root_js_1 = _root;
	function createCurry(func, bitmask, arity) {
	    var Ctor = _createCtor_js_1.default(func);
	    function wrapper() {
	        var length = arguments.length, args = Array(length), index = length, placeholder = _getHolder_js_1.default(wrapper);
	        while (index--) {
	            args[index] = arguments[index];
	        }
	        var holders = (length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder)
	            ? []
	            : _replaceHolders_js_1.default(args, placeholder);
	        length -= holders.length;
	        if (length < arity) {
	            return _createRecurry_js_1.default(func, bitmask, _createHybrid_js_1.default, wrapper.placeholder, undefined, args, holders, undefined, undefined, arity - length);
	        }
	        var fn = (this && this !== _root_js_1.default && this instanceof wrapper) ? Ctor : func;
	        return _apply_js_1.default(fn, this, args);
	    }
	    return wrapper;
	}
	exports.default = createCurry;
	});

	var _createPartial = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _apply_js_1 = _apply;
	var _createCtor_js_1 = _createCtor;
	var _root_js_1 = _root;
	var WRAP_BIND_FLAG = 1;
	function createPartial(func, bitmask, thisArg, partials) {
	    var isBind = bitmask & WRAP_BIND_FLAG, Ctor = _createCtor_js_1.default(func);
	    function wrapper() {
	        var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array(leftLength + argsLength), fn = (this && this !== _root_js_1.default && this instanceof wrapper) ? Ctor : func;
	        while (++leftIndex < leftLength) {
	            args[leftIndex] = partials[leftIndex];
	        }
	        while (argsLength--) {
	            args[leftIndex++] = arguments[++argsIndex];
	        }
	        return _apply_js_1.default(fn, isBind ? thisArg : this, args);
	    }
	    return wrapper;
	}
	exports.default = createPartial;
	});

	var _mergeData = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _composeArgs_js_1 = _composeArgs;
	var _composeArgsRight_js_1 = _composeArgsRight;
	var _replaceHolders_js_1 = _replaceHolders;
	var PLACEHOLDER = '__lodash_placeholder__';
	var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256;
	var nativeMin = Math.min;
	function mergeData(data, source) {
	    var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
	    var isCombo = ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_CURRY_FLAG)) ||
	        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_REARG_FLAG) && (data[7].length <= source[8])) ||
	        ((srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG)) && (source[7].length <= source[8]) && (bitmask == WRAP_CURRY_FLAG));
	    if (!(isCommon || isCombo)) {
	        return data;
	    }
	    if (srcBitmask & WRAP_BIND_FLAG) {
	        data[2] = source[2];
	        newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
	    }
	    var value = source[3];
	    if (value) {
	        var partials = data[3];
	        data[3] = partials ? _composeArgs_js_1.default(partials, value, source[4]) : value;
	        data[4] = partials ? _replaceHolders_js_1.default(data[3], PLACEHOLDER) : source[4];
	    }
	    value = source[5];
	    if (value) {
	        partials = data[5];
	        data[5] = partials ? _composeArgsRight_js_1.default(partials, value, source[6]) : value;
	        data[6] = partials ? _replaceHolders_js_1.default(data[5], PLACEHOLDER) : source[6];
	    }
	    value = source[7];
	    if (value) {
	        data[7] = value;
	    }
	    if (srcBitmask & WRAP_ARY_FLAG) {
	        data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
	    }
	    if (data[9] == null) {
	        data[9] = source[9];
	    }
	    data[0] = source[0];
	    data[1] = newBitmask;
	    return data;
	}
	exports.default = mergeData;
	});

	var _createWrap = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseSetData_js_1 = _baseSetData;
	var _createBind_js_1 = _createBind;
	var _createCurry_js_1 = _createCurry;
	var _createHybrid_js_1 = _createHybrid;
	var _createPartial_js_1 = _createPartial;
	var _getData_js_1 = _getData;
	var _mergeData_js_1 = _mergeData;
	var _setData_js_1 = _setData;
	var _setWrapToString_js_1 = _setWrapToString;
	var toInteger_js_1 = toInteger_1;
	var FUNC_ERROR_TEXT = 'Expected a function';
	var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64;
	var nativeMax = Math.max;
	function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
	    var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
	    if (!isBindKey && typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	    }
	    var length = partials ? partials.length : 0;
	    if (!length) {
	        bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
	        partials = holders = undefined;
	    }
	    ary = ary === undefined ? ary : nativeMax(toInteger_js_1.default(ary), 0);
	    arity = arity === undefined ? arity : toInteger_js_1.default(arity);
	    length -= holders ? holders.length : 0;
	    if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
	        var partialsRight = partials, holdersRight = holders;
	        partials = holders = undefined;
	    }
	    var data = isBindKey ? undefined : _getData_js_1.default(func);
	    var newData = [
	        func, bitmask, thisArg, partials, holders, partialsRight, holdersRight,
	        argPos, ary, arity
	    ];
	    if (data) {
	        _mergeData_js_1.default(newData, data);
	    }
	    func = newData[0];
	    bitmask = newData[1];
	    thisArg = newData[2];
	    partials = newData[3];
	    holders = newData[4];
	    arity = newData[9] = newData[9] === undefined
	        ? (isBindKey ? 0 : func.length)
	        : nativeMax(newData[9] - length, 0);
	    if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
	        bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
	    }
	    if (!bitmask || bitmask == WRAP_BIND_FLAG) {
	        var result = _createBind_js_1.default(func, bitmask, thisArg);
	    }
	    else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
	        result = _createCurry_js_1.default(func, bitmask, arity);
	    }
	    else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
	        result = _createPartial_js_1.default(func, bitmask, thisArg, partials);
	    }
	    else {
	        result = _createHybrid_js_1.default.apply(undefined, newData);
	    }
	    var setter = data ? _baseSetData_js_1.default : _setData_js_1.default;
	    return _setWrapToString_js_1.default(setter(result, newData), func, bitmask);
	}
	exports.default = createWrap;
	});

	var ary_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _createWrap_js_1 = _createWrap;
	var WRAP_ARY_FLAG = 128;
	function ary(func, n, guard) {
	    n = guard ? undefined : n;
	    n = (func && n == null) ? func.length : n;
	    return _createWrap_js_1.default(func, WRAP_ARY_FLAG, undefined, undefined, undefined, undefined, n);
	}
	exports.default = ary;
	});

	var _baseAssignValue = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _defineProperty_js_1 = _defineProperty;
	function baseAssignValue(object, key, value) {
	    if (key == '__proto__' && _defineProperty_js_1.default) {
	        _defineProperty_js_1.default(object, key, {
	            'configurable': true,
	            'enumerable': true,
	            'value': value,
	            'writable': true
	        });
	    }
	    else {
	        object[key] = value;
	    }
	}
	exports.default = baseAssignValue;
	});

	var eq_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	function eq(value, other) {
	    return value === other || (value !== value && other !== other);
	}
	exports.default = eq;
	});

	var _assignValue = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseAssignValue_js_1 = _baseAssignValue;
	var eq_js_1 = eq_1;
	var objectProto = Object.prototype;
	var hasOwnProperty = objectProto.hasOwnProperty;
	function assignValue(object, key, value) {
	    var objValue = object[key];
	    if (!(hasOwnProperty.call(object, key) && eq_js_1.default(objValue, value)) ||
	        (value === undefined && !(key in object))) {
	        _baseAssignValue_js_1.default(object, key, value);
	    }
	}
	exports.default = assignValue;
	});

	var _copyObject = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _assignValue_js_1 = _assignValue;
	var _baseAssignValue_js_1 = _baseAssignValue;
	function copyObject(source, props, object, customizer) {
	    var isNew = !object;
	    object || (object = {});
	    var index = -1, length = props.length;
	    while (++index < length) {
	        var key = props[index];
	        var newValue = customizer
	            ? customizer(object[key], source[key], key, object, source)
	            : undefined;
	        if (newValue === undefined) {
	            newValue = source[key];
	        }
	        if (isNew) {
	            _baseAssignValue_js_1.default(object, key, newValue);
	        }
	        else {
	            _assignValue_js_1.default(object, key, newValue);
	        }
	    }
	    return object;
	}
	exports.default = copyObject;
	});

	var _baseRest = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var identity_js_1 = identity_1;
	var _overRest_js_1 = _overRest;
	var _setToString_js_1 = _setToString;
	function baseRest(func, start) {
	    return _setToString_js_1.default(_overRest_js_1.default(func, start, identity_js_1.default), func + '');
	}
	exports.default = baseRest;
	});

	var isLength_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var MAX_SAFE_INTEGER = 9007199254740991;
	function isLength(value) {
	    return typeof value == 'number' &&
	        value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	}
	exports.default = isLength;
	});

	var isArrayLike_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var isFunction_js_1 = isFunction_1;
	var isLength_js_1 = isLength_1;
	function isArrayLike(value) {
	    return value != null && isLength_js_1.default(value.length) && !isFunction_js_1.default(value);
	}
	exports.default = isArrayLike;
	});

	var _isIterateeCall = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var eq_js_1 = eq_1;
	var isArrayLike_js_1 = isArrayLike_1;
	var _isIndex_js_1 = _isIndex;
	var isObject_js_1 = isObject_1;
	function isIterateeCall(value, index, object) {
	    if (!isObject_js_1.default(object)) {
	        return false;
	    }
	    var type = typeof index;
	    if (type == 'number'
	        ? (isArrayLike_js_1.default(object) && _isIndex_js_1.default(index, object.length))
	        : (type == 'string' && index in object)) {
	        return eq_js_1.default(object[index], value);
	    }
	    return false;
	}
	exports.default = isIterateeCall;
	});

	var _createAssigner = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseRest_js_1 = _baseRest;
	var _isIterateeCall_js_1 = _isIterateeCall;
	function createAssigner(assigner) {
	    return _baseRest_js_1.default(function (object, sources) {
	        var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined, guard = length > 2 ? sources[2] : undefined;
	        customizer = (assigner.length > 3 && typeof customizer == 'function')
	            ? (length--, customizer)
	            : undefined;
	        if (guard && _isIterateeCall_js_1.default(sources[0], sources[1], guard)) {
	            customizer = length < 3 ? undefined : customizer;
	            length = 1;
	        }
	        object = Object(object);
	        while (++index < length) {
	            var source = sources[index];
	            if (source) {
	                assigner(object, source, index, customizer);
	            }
	        }
	        return object;
	    });
	}
	exports.default = createAssigner;
	});

	var _isPrototype = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var objectProto = Object.prototype;
	function isPrototype(value) {
	    var Ctor = value && value.constructor, proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;
	    return value === proto;
	}
	exports.default = isPrototype;
	});

	var _baseTimes = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	function baseTimes(n, iteratee) {
	    var index = -1, result = Array(n);
	    while (++index < n) {
	        result[index] = iteratee(index);
	    }
	    return result;
	}
	exports.default = baseTimes;
	});

	var stubFalse_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	function stubFalse() {
	    return false;
	}
	exports.default = stubFalse;
	});

	var isBuffer_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _root_js_1 = _root;
	var stubFalse_js_1 = stubFalse_1;
	var freeExports = 'object' == 'object' && exports && !exports.nodeType && exports;
	var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;
	var moduleExports = freeModule && freeModule.exports === freeExports;
	var Buffer = moduleExports ? _root_js_1.default.Buffer : undefined;
	var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;
	var isBuffer = nativeIsBuffer || stubFalse_js_1.default;
	exports.default = isBuffer;
	});

	var _baseIsTypedArray = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseGetTag_js_1 = _baseGetTag;
	var isLength_js_1 = isLength_1;
	var isObjectLike_js_1 = isObjectLike_1;
	var argsTag = '[object Arguments]', arrayTag = '[object Array]', boolTag = '[object Boolean]', dateTag = '[object Date]', errorTag = '[object Error]', funcTag = '[object Function]', mapTag = '[object Map]', numberTag = '[object Number]', objectTag = '[object Object]', regexpTag = '[object RegExp]', setTag = '[object Set]', stringTag = '[object String]', weakMapTag = '[object WeakMap]';
	var arrayBufferTag = '[object ArrayBuffer]', dataViewTag = '[object DataView]', float32Tag = '[object Float32Array]', float64Tag = '[object Float64Array]', int8Tag = '[object Int8Array]', int16Tag = '[object Int16Array]', int32Tag = '[object Int32Array]', uint8Tag = '[object Uint8Array]', uint8ClampedTag = '[object Uint8ClampedArray]', uint16Tag = '[object Uint16Array]', uint32Tag = '[object Uint32Array]';
	var typedArrayTags = {};
	typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
	    typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
	        typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
	            typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
	                typedArrayTags[uint32Tag] = true;
	typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
	    typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
	        typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
	            typedArrayTags[errorTag] = typedArrayTags[funcTag] =
	                typedArrayTags[mapTag] = typedArrayTags[numberTag] =
	                    typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
	                        typedArrayTags[setTag] = typedArrayTags[stringTag] =
	                            typedArrayTags[weakMapTag] = false;
	function baseIsTypedArray(value) {
	    return isObjectLike_js_1.default(value) &&
	        isLength_js_1.default(value.length) && !!typedArrayTags[_baseGetTag_js_1.default(value)];
	}
	exports.default = baseIsTypedArray;
	});

	var _baseUnary = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	function baseUnary(func) {
	    return function (value) {
	        return func(value);
	    };
	}
	exports.default = baseUnary;
	});

	var _nodeUtil = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _freeGlobal_js_1 = _freeGlobal;
	var freeExports = 'object' == 'object' && exports && !exports.nodeType && exports;
	var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;
	var moduleExports = freeModule && freeModule.exports === freeExports;
	var freeProcess = moduleExports && _freeGlobal_js_1.default.process;
	var nodeUtil = (function () {
	    try {
	        return freeProcess && freeProcess.binding && freeProcess.binding('util');
	    }
	    catch (e) { }
	}());
	exports.default = nodeUtil;
	});

	var isTypedArray_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseIsTypedArray_js_1 = _baseIsTypedArray;
	var _baseUnary_js_1 = _baseUnary;
	var _nodeUtil_js_1 = _nodeUtil;
	var nodeIsTypedArray = _nodeUtil_js_1.default && _nodeUtil_js_1.default.isTypedArray;
	var isTypedArray = nodeIsTypedArray ? _baseUnary_js_1.default(nodeIsTypedArray) : _baseIsTypedArray_js_1.default;
	exports.default = isTypedArray;
	});

	var _arrayLikeKeys = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseTimes_js_1 = _baseTimes;
	var isArguments_js_1 = isArguments_1;
	var isArray_js_1 = isArray_1;
	var isBuffer_js_1 = isBuffer_1;
	var _isIndex_js_1 = _isIndex;
	var isTypedArray_js_1 = isTypedArray_1;
	var objectProto = Object.prototype;
	var hasOwnProperty = objectProto.hasOwnProperty;
	function arrayLikeKeys(value, inherited) {
	    var isArr = isArray_js_1.default(value), isArg = !isArr && isArguments_js_1.default(value), isBuff = !isArr && !isArg && isBuffer_js_1.default(value), isType = !isArr && !isArg && !isBuff && isTypedArray_js_1.default(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? _baseTimes_js_1.default(value.length, String) : [], length = result.length;
	    for (var key in value) {
	        if ((inherited || hasOwnProperty.call(value, key)) &&
	            !(skipIndexes && (key == 'length' ||
	                (isBuff && (key == 'offset' || key == 'parent')) ||
	                (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
	                _isIndex_js_1.default(key, length)))) {
	            result.push(key);
	        }
	    }
	    return result;
	}
	exports.default = arrayLikeKeys;
	});

	var _overArg = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	function overArg(func, transform) {
	    return function (arg) {
	        return func(transform(arg));
	    };
	}
	exports.default = overArg;
	});

	var _nativeKeys = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _overArg_js_1 = _overArg;
	var nativeKeys = _overArg_js_1.default(Object.keys, Object);
	exports.default = nativeKeys;
	});

	var _baseKeys = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _isPrototype_js_1 = _isPrototype;
	var _nativeKeys_js_1 = _nativeKeys;
	var objectProto = Object.prototype;
	var hasOwnProperty = objectProto.hasOwnProperty;
	function baseKeys(object) {
	    if (!_isPrototype_js_1.default(object)) {
	        return _nativeKeys_js_1.default(object);
	    }
	    var result = [];
	    for (var key in Object(object)) {
	        if (hasOwnProperty.call(object, key) && key != 'constructor') {
	            result.push(key);
	        }
	    }
	    return result;
	}
	exports.default = baseKeys;
	});

	var keys_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _arrayLikeKeys_js_1 = _arrayLikeKeys;
	var _baseKeys_js_1 = _baseKeys;
	var isArrayLike_js_1 = isArrayLike_1;
	function keys(object) {
	    return isArrayLike_js_1.default(object) ? _arrayLikeKeys_js_1.default(object) : _baseKeys_js_1.default(object);
	}
	exports.default = keys;
	});

	var assign_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _assignValue_js_1 = _assignValue;
	var _copyObject_js_1 = _copyObject;
	var _createAssigner_js_1 = _createAssigner;
	var isArrayLike_js_1 = isArrayLike_1;
	var _isPrototype_js_1 = _isPrototype;
	var keys_js_1 = keys_1;
	var objectProto = Object.prototype;
	var hasOwnProperty = objectProto.hasOwnProperty;
	var assign = _createAssigner_js_1.default(function (object, source) {
	    if (_isPrototype_js_1.default(source) || isArrayLike_js_1.default(source)) {
	        _copyObject_js_1.default(source, keys_js_1.default(source), object);
	        return;
	    }
	    for (var key in source) {
	        if (hasOwnProperty.call(source, key)) {
	            _assignValue_js_1.default(object, key, source[key]);
	        }
	    }
	});
	exports.default = assign;
	});

	var _nativeKeysIn = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	function nativeKeysIn(object) {
	    var result = [];
	    if (object != null) {
	        for (var key in Object(object)) {
	            result.push(key);
	        }
	    }
	    return result;
	}
	exports.default = nativeKeysIn;
	});

	var _baseKeysIn = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var isObject_js_1 = isObject_1;
	var _isPrototype_js_1 = _isPrototype;
	var _nativeKeysIn_js_1 = _nativeKeysIn;
	var objectProto = Object.prototype;
	var hasOwnProperty = objectProto.hasOwnProperty;
	function baseKeysIn(object) {
	    if (!isObject_js_1.default(object)) {
	        return _nativeKeysIn_js_1.default(object);
	    }
	    var isProto = _isPrototype_js_1.default(object), result = [];
	    for (var key in object) {
	        if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
	            result.push(key);
	        }
	    }
	    return result;
	}
	exports.default = baseKeysIn;
	});

	var keysIn_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _arrayLikeKeys_js_1 = _arrayLikeKeys;
	var _baseKeysIn_js_1 = _baseKeysIn;
	var isArrayLike_js_1 = isArrayLike_1;
	function keysIn(object) {
	    return isArrayLike_js_1.default(object) ? _arrayLikeKeys_js_1.default(object, true) : _baseKeysIn_js_1.default(object);
	}
	exports.default = keysIn;
	});

	var assignIn_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _copyObject_js_1 = _copyObject;
	var _createAssigner_js_1 = _createAssigner;
	var keysIn_js_1 = keysIn_1;
	var assignIn = _createAssigner_js_1.default(function (object, source) {
	    _copyObject_js_1.default(source, keysIn_js_1.default(source), object);
	});
	exports.default = assignIn;
	});

	var assignInWith_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _copyObject_js_1 = _copyObject;
	var _createAssigner_js_1 = _createAssigner;
	var keysIn_js_1 = keysIn_1;
	var assignInWith = _createAssigner_js_1.default(function (object, source, srcIndex, customizer) {
	    _copyObject_js_1.default(source, keysIn_js_1.default(source), object, customizer);
	});
	exports.default = assignInWith;
	});

	var assignWith_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _copyObject_js_1 = _copyObject;
	var _createAssigner_js_1 = _createAssigner;
	var keys_js_1 = keys_1;
	var assignWith = _createAssigner_js_1.default(function (object, source, srcIndex, customizer) {
	    _copyObject_js_1.default(source, keys_js_1.default(source), object, customizer);
	});
	exports.default = assignWith;
	});

	var _isKey = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var isArray_js_1 = isArray_1;
	var isSymbol_js_1 = isSymbol_1;
	var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
	function isKey(value, object) {
	    if (isArray_js_1.default(value)) {
	        return false;
	    }
	    var type = typeof value;
	    if (type == 'number' || type == 'symbol' || type == 'boolean' ||
	        value == null || isSymbol_js_1.default(value)) {
	        return true;
	    }
	    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
	        (object != null && value in Object(object));
	}
	exports.default = isKey;
	});

	var _nativeCreate = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _getNative_js_1 = _getNative;
	var nativeCreate = _getNative_js_1.default(Object, 'create');
	exports.default = nativeCreate;
	});

	var _hashClear = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _nativeCreate_js_1 = _nativeCreate;
	function hashClear() {
	    this.__data__ = _nativeCreate_js_1.default ? _nativeCreate_js_1.default(null) : {};
	    this.size = 0;
	}
	exports.default = hashClear;
	});

	var _hashDelete = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	function hashDelete(key) {
	    var result = this.has(key) && delete this.__data__[key];
	    this.size -= result ? 1 : 0;
	    return result;
	}
	exports.default = hashDelete;
	});

	var _hashGet = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _nativeCreate_js_1 = _nativeCreate;
	var HASH_UNDEFINED = '__lodash_hash_undefined__';
	var objectProto = Object.prototype;
	var hasOwnProperty = objectProto.hasOwnProperty;
	function hashGet(key) {
	    var data = this.__data__;
	    if (_nativeCreate_js_1.default) {
	        var result = data[key];
	        return result === HASH_UNDEFINED ? undefined : result;
	    }
	    return hasOwnProperty.call(data, key) ? data[key] : undefined;
	}
	exports.default = hashGet;
	});

	var _hashHas = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _nativeCreate_js_1 = _nativeCreate;
	var objectProto = Object.prototype;
	var hasOwnProperty = objectProto.hasOwnProperty;
	function hashHas(key) {
	    var data = this.__data__;
	    return _nativeCreate_js_1.default ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
	}
	exports.default = hashHas;
	});

	var _hashSet = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _nativeCreate_js_1 = _nativeCreate;
	var HASH_UNDEFINED = '__lodash_hash_undefined__';
	function hashSet(key, value) {
	    var data = this.__data__;
	    this.size += this.has(key) ? 0 : 1;
	    data[key] = (_nativeCreate_js_1.default && value === undefined) ? HASH_UNDEFINED : value;
	    return this;
	}
	exports.default = hashSet;
	});

	var _Hash = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _hashClear_js_1 = _hashClear;
	var _hashDelete_js_1 = _hashDelete;
	var _hashGet_js_1 = _hashGet;
	var _hashHas_js_1 = _hashHas;
	var _hashSet_js_1 = _hashSet;
	function Hash(entries) {
	    var index = -1, length = entries == null ? 0 : entries.length;
	    this.clear();
	    while (++index < length) {
	        var entry = entries[index];
	        this.set(entry[0], entry[1]);
	    }
	}
	Hash.prototype.clear = _hashClear_js_1.default;
	Hash.prototype['delete'] = _hashDelete_js_1.default;
	Hash.prototype.get = _hashGet_js_1.default;
	Hash.prototype.has = _hashHas_js_1.default;
	Hash.prototype.set = _hashSet_js_1.default;
	exports.default = Hash;
	});

	var _listCacheClear = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	function listCacheClear() {
	    this.__data__ = [];
	    this.size = 0;
	}
	exports.default = listCacheClear;
	});

	var _assocIndexOf = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var eq_js_1 = eq_1;
	function assocIndexOf(array, key) {
	    var length = array.length;
	    while (length--) {
	        if (eq_js_1.default(array[length][0], key)) {
	            return length;
	        }
	    }
	    return -1;
	}
	exports.default = assocIndexOf;
	});

	var _listCacheDelete = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _assocIndexOf_js_1 = _assocIndexOf;
	var arrayProto = Array.prototype;
	var splice = arrayProto.splice;
	function listCacheDelete(key) {
	    var data = this.__data__, index = _assocIndexOf_js_1.default(data, key);
	    if (index < 0) {
	        return false;
	    }
	    var lastIndex = data.length - 1;
	    if (index == lastIndex) {
	        data.pop();
	    }
	    else {
	        splice.call(data, index, 1);
	    }
	    --this.size;
	    return true;
	}
	exports.default = listCacheDelete;
	});

	var _listCacheGet = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _assocIndexOf_js_1 = _assocIndexOf;
	function listCacheGet(key) {
	    var data = this.__data__, index = _assocIndexOf_js_1.default(data, key);
	    return index < 0 ? undefined : data[index][1];
	}
	exports.default = listCacheGet;
	});

	var _listCacheHas = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _assocIndexOf_js_1 = _assocIndexOf;
	function listCacheHas(key) {
	    return _assocIndexOf_js_1.default(this.__data__, key) > -1;
	}
	exports.default = listCacheHas;
	});

	var _listCacheSet = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _assocIndexOf_js_1 = _assocIndexOf;
	function listCacheSet(key, value) {
	    var data = this.__data__, index = _assocIndexOf_js_1.default(data, key);
	    if (index < 0) {
	        ++this.size;
	        data.push([key, value]);
	    }
	    else {
	        data[index][1] = value;
	    }
	    return this;
	}
	exports.default = listCacheSet;
	});

	var _ListCache = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _listCacheClear_js_1 = _listCacheClear;
	var _listCacheDelete_js_1 = _listCacheDelete;
	var _listCacheGet_js_1 = _listCacheGet;
	var _listCacheHas_js_1 = _listCacheHas;
	var _listCacheSet_js_1 = _listCacheSet;
	function ListCache(entries) {
	    var index = -1, length = entries == null ? 0 : entries.length;
	    this.clear();
	    while (++index < length) {
	        var entry = entries[index];
	        this.set(entry[0], entry[1]);
	    }
	}
	ListCache.prototype.clear = _listCacheClear_js_1.default;
	ListCache.prototype['delete'] = _listCacheDelete_js_1.default;
	ListCache.prototype.get = _listCacheGet_js_1.default;
	ListCache.prototype.has = _listCacheHas_js_1.default;
	ListCache.prototype.set = _listCacheSet_js_1.default;
	exports.default = ListCache;
	});

	var _Map = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _getNative_js_1 = _getNative;
	var _root_js_1 = _root;
	var Map = _getNative_js_1.default(_root_js_1.default, 'Map');
	exports.default = Map;
	});

	var _mapCacheClear = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _Hash_js_1 = _Hash;
	var _ListCache_js_1 = _ListCache;
	var _Map_js_1 = _Map;
	function mapCacheClear() {
	    this.size = 0;
	    this.__data__ = {
	        'hash': new _Hash_js_1.default,
	        'map': new (_Map_js_1.default || _ListCache_js_1.default),
	        'string': new _Hash_js_1.default
	    };
	}
	exports.default = mapCacheClear;
	});

	var _isKeyable = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	function isKeyable(value) {
	    var type = typeof value;
	    return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
	        ? (value !== '__proto__')
	        : (value === null);
	}
	exports.default = isKeyable;
	});

	var _getMapData = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _isKeyable_js_1 = _isKeyable;
	function getMapData(map, key) {
	    var data = map.__data__;
	    return _isKeyable_js_1.default(key)
	        ? data[typeof key == 'string' ? 'string' : 'hash']
	        : data.map;
	}
	exports.default = getMapData;
	});

	var _mapCacheDelete = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _getMapData_js_1 = _getMapData;
	function mapCacheDelete(key) {
	    var result = _getMapData_js_1.default(this, key)['delete'](key);
	    this.size -= result ? 1 : 0;
	    return result;
	}
	exports.default = mapCacheDelete;
	});

	var _mapCacheGet = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _getMapData_js_1 = _getMapData;
	function mapCacheGet(key) {
	    return _getMapData_js_1.default(this, key).get(key);
	}
	exports.default = mapCacheGet;
	});

	var _mapCacheHas = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _getMapData_js_1 = _getMapData;
	function mapCacheHas(key) {
	    return _getMapData_js_1.default(this, key).has(key);
	}
	exports.default = mapCacheHas;
	});

	var _mapCacheSet = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _getMapData_js_1 = _getMapData;
	function mapCacheSet(key, value) {
	    var data = _getMapData_js_1.default(this, key), size = data.size;
	    data.set(key, value);
	    this.size += data.size == size ? 0 : 1;
	    return this;
	}
	exports.default = mapCacheSet;
	});

	var _MapCache = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _mapCacheClear_js_1 = _mapCacheClear;
	var _mapCacheDelete_js_1 = _mapCacheDelete;
	var _mapCacheGet_js_1 = _mapCacheGet;
	var _mapCacheHas_js_1 = _mapCacheHas;
	var _mapCacheSet_js_1 = _mapCacheSet;
	function MapCache(entries) {
	    var index = -1, length = entries == null ? 0 : entries.length;
	    this.clear();
	    while (++index < length) {
	        var entry = entries[index];
	        this.set(entry[0], entry[1]);
	    }
	}
	MapCache.prototype.clear = _mapCacheClear_js_1.default;
	MapCache.prototype['delete'] = _mapCacheDelete_js_1.default;
	MapCache.prototype.get = _mapCacheGet_js_1.default;
	MapCache.prototype.has = _mapCacheHas_js_1.default;
	MapCache.prototype.set = _mapCacheSet_js_1.default;
	exports.default = MapCache;
	});

	var memoize_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _MapCache_js_1 = _MapCache;
	var FUNC_ERROR_TEXT = 'Expected a function';
	function memoize(func, resolver) {
	    if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
	        throw new TypeError(FUNC_ERROR_TEXT);
	    }
	    var memoized = function () {
	        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
	        if (cache.has(key)) {
	            return cache.get(key);
	        }
	        var result = func.apply(this, args);
	        memoized.cache = cache.set(key, result) || cache;
	        return result;
	    };
	    memoized.cache = new (memoize.Cache || _MapCache_js_1.default);
	    return memoized;
	}
	memoize.Cache = _MapCache_js_1.default;
	exports.default = memoize;
	});

	var _memoizeCapped = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var memoize_js_1 = memoize_1;
	var MAX_MEMOIZE_SIZE = 500;
	function memoizeCapped(func) {
	    var result = memoize_js_1.default(func, function (key) {
	        if (cache.size === MAX_MEMOIZE_SIZE) {
	            cache.clear();
	        }
	        return key;
	    });
	    var cache = result.cache;
	    return result;
	}
	exports.default = memoizeCapped;
	});

	var _stringToPath = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _memoizeCapped_js_1 = _memoizeCapped;
	var reLeadingDot = /^\./, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
	var reEscapeChar = /\\(\\)?/g;
	var stringToPath = _memoizeCapped_js_1.default(function (string) {
	    var result = [];
	    if (reLeadingDot.test(string)) {
	        result.push('');
	    }
	    string.replace(rePropName, function (match, number, quote, string) {
	        result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
	    });
	    return result;
	});
	exports.default = stringToPath;
	});

	var _castPath = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var isArray_js_1 = isArray_1;
	var _isKey_js_1 = _isKey;
	var _stringToPath_js_1 = _stringToPath;
	var toString_js_1 = toString_1;
	function castPath(value, object) {
	    if (isArray_js_1.default(value)) {
	        return value;
	    }
	    return _isKey_js_1.default(value, object) ? [value] : _stringToPath_js_1.default(toString_js_1.default(value));
	}
	exports.default = castPath;
	});

	var _toKey = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var isSymbol_js_1 = isSymbol_1;
	var INFINITY = 1 / 0;
	function toKey(value) {
	    if (typeof value == 'string' || isSymbol_js_1.default(value)) {
	        return value;
	    }
	    var result = (value + '');
	    return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
	}
	exports.default = toKey;
	});

	var _baseGet = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _castPath_js_1 = _castPath;
	var _toKey_js_1 = _toKey;
	function baseGet(object, path) {
	    path = _castPath_js_1.default(path, object);
	    var index = 0, length = path.length;
	    while (object != null && index < length) {
	        object = object[_toKey_js_1.default(path[index++])];
	    }
	    return (index && index == length) ? object : undefined;
	}
	exports.default = baseGet;
	});

	var get_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseGet_js_1 = _baseGet;
	function get(object, path, defaultValue) {
	    var result = object == null ? undefined : _baseGet_js_1.default(object, path);
	    return result === undefined ? defaultValue : result;
	}
	exports.default = get;
	});

	var _baseAt = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var get_js_1 = get_1;
	function baseAt(object, paths) {
	    var index = -1, length = paths.length, result = Array(length), skip = object == null;
	    while (++index < length) {
	        result[index] = skip ? undefined : get_js_1.default(object, paths[index]);
	    }
	    return result;
	}
	exports.default = baseAt;
	});

	var at_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseAt_js_1 = _baseAt;
	var _flatRest_js_1 = _flatRest;
	var at = _flatRest_js_1.default(_baseAt_js_1.default);
	exports.default = at;
	});

	var _getPrototype = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _overArg_js_1 = _overArg;
	var getPrototype = _overArg_js_1.default(Object.getPrototypeOf, Object);
	exports.default = getPrototype;
	});

	var isPlainObject_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseGetTag_js_1 = _baseGetTag;
	var _getPrototype_js_1 = _getPrototype;
	var isObjectLike_js_1 = isObjectLike_1;
	var objectTag = '[object Object]';
	var funcProto = Function.prototype, objectProto = Object.prototype;
	var funcToString = funcProto.toString;
	var hasOwnProperty = objectProto.hasOwnProperty;
	var objectCtorString = funcToString.call(Object);
	function isPlainObject(value) {
	    if (!isObjectLike_js_1.default(value) || _baseGetTag_js_1.default(value) != objectTag) {
	        return false;
	    }
	    var proto = _getPrototype_js_1.default(value);
	    if (proto === null) {
	        return true;
	    }
	    var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
	    return typeof Ctor == 'function' && Ctor instanceof Ctor &&
	        funcToString.call(Ctor) == objectCtorString;
	}
	exports.default = isPlainObject;
	});

	var isError_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseGetTag_js_1 = _baseGetTag;
	var isObjectLike_js_1 = isObjectLike_1;
	var isPlainObject_js_1 = isPlainObject_1;
	var domExcTag = '[object DOMException]', errorTag = '[object Error]';
	function isError(value) {
	    if (!isObjectLike_js_1.default(value)) {
	        return false;
	    }
	    var tag = _baseGetTag_js_1.default(value);
	    return tag == errorTag || tag == domExcTag ||
	        (typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject_js_1.default(value));
	}
	exports.default = isError;
	});

	var attempt_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _apply_js_1 = _apply;
	var _baseRest_js_1 = _baseRest;
	var isError_js_1 = isError_1;
	var attempt = _baseRest_js_1.default(function (func, args) {
	    try {
	        return _apply_js_1.default(func, undefined, args);
	    }
	    catch (e) {
	        return isError_js_1.default(e) ? e : new Error(e);
	    }
	});
	exports.default = attempt;
	});

	var before_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var toInteger_js_1 = toInteger_1;
	var FUNC_ERROR_TEXT = 'Expected a function';
	function before(n, func) {
	    var result;
	    if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	    }
	    n = toInteger_js_1.default(n);
	    return function () {
	        if (--n > 0) {
	            result = func.apply(this, arguments);
	        }
	        if (n <= 1) {
	            func = undefined;
	        }
	        return result;
	    };
	}
	exports.default = before;
	});

	var bind_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseRest_js_1 = _baseRest;
	var _createWrap_js_1 = _createWrap;
	var _getHolder_js_1 = _getHolder;
	var _replaceHolders_js_1 = _replaceHolders;
	var WRAP_BIND_FLAG = 1, WRAP_PARTIAL_FLAG = 32;
	var bind = _baseRest_js_1.default(function (func, thisArg, partials) {
	    var bitmask = WRAP_BIND_FLAG;
	    if (partials.length) {
	        var holders = _replaceHolders_js_1.default(partials, _getHolder_js_1.default(bind));
	        bitmask |= WRAP_PARTIAL_FLAG;
	    }
	    return _createWrap_js_1.default(func, bitmask, thisArg, partials, holders);
	});
	bind.placeholder = {};
	exports.default = bind;
	});

	var bindAll_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _arrayEach_js_1 = _arrayEach;
	var _baseAssignValue_js_1 = _baseAssignValue;
	var bind_js_1 = bind_1;
	var _flatRest_js_1 = _flatRest;
	var _toKey_js_1 = _toKey;
	var bindAll = _flatRest_js_1.default(function (object, methodNames) {
	    _arrayEach_js_1.default(methodNames, function (key) {
	        key = _toKey_js_1.default(key);
	        _baseAssignValue_js_1.default(object, key, bind_js_1.default(object[key], object));
	    });
	    return object;
	});
	exports.default = bindAll;
	});

	var bindKey_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseRest_js_1 = _baseRest;
	var _createWrap_js_1 = _createWrap;
	var _getHolder_js_1 = _getHolder;
	var _replaceHolders_js_1 = _replaceHolders;
	var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_PARTIAL_FLAG = 32;
	var bindKey = _baseRest_js_1.default(function (object, key, partials) {
	    var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
	    if (partials.length) {
	        var holders = _replaceHolders_js_1.default(partials, _getHolder_js_1.default(bindKey));
	        bitmask |= WRAP_PARTIAL_FLAG;
	    }
	    return _createWrap_js_1.default(key, bitmask, object, partials, holders);
	});
	bindKey.placeholder = {};
	exports.default = bindKey;
	});

	var _baseSlice = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	function baseSlice(array, start, end) {
	    var index = -1, length = array.length;
	    if (start < 0) {
	        start = -start > length ? 0 : (length + start);
	    }
	    end = end > length ? length : end;
	    if (end < 0) {
	        end += length;
	    }
	    length = start > end ? 0 : ((end - start) >>> 0);
	    start >>>= 0;
	    var result = Array(length);
	    while (++index < length) {
	        result[index] = array[index + start];
	    }
	    return result;
	}
	exports.default = baseSlice;
	});

	var _castSlice = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseSlice_js_1 = _baseSlice;
	function castSlice(array, start, end) {
	    var length = array.length;
	    end = end === undefined ? length : end;
	    return (!start && end >= length) ? array : _baseSlice_js_1.default(array, start, end);
	}
	exports.default = castSlice;
	});

	var _hasUnicode = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var rsAstralRange = '\\ud800-\\udfff', rsComboMarksRange = '\\u0300-\\u036f', reComboHalfMarksRange = '\\ufe20-\\ufe2f', rsComboSymbolsRange = '\\u20d0-\\u20ff', rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsVarRange = '\\ufe0e\\ufe0f';
	var rsZWJ = '\\u200d';
	var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + ']');
	function hasUnicode(string) {
	    return reHasUnicode.test(string);
	}
	exports.default = hasUnicode;
	});

	var _asciiToArray = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	function asciiToArray(string) {
	    return string.split('');
	}
	exports.default = asciiToArray;
	});

	var _unicodeToArray = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var rsAstralRange = '\\ud800-\\udfff', rsComboMarksRange = '\\u0300-\\u036f', reComboHalfMarksRange = '\\ufe20-\\ufe2f', rsComboSymbolsRange = '\\u20d0-\\u20ff', rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsVarRange = '\\ufe0e\\ufe0f';
	var rsAstral = '[' + rsAstralRange + ']', rsCombo = '[' + rsComboRange + ']', rsFitz = '\\ud83c[\\udffb-\\udfff]', rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')', rsNonAstral = '[^' + rsAstralRange + ']', rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}', rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]', rsZWJ = '\\u200d';
	var reOptMod = rsModifier + '?', rsOptVar = '[' + rsVarRange + ']?', rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*', rsSeq = rsOptVar + reOptMod + rsOptJoin, rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';
	var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');
	function unicodeToArray(string) {
	    return string.match(reUnicode) || [];
	}
	exports.default = unicodeToArray;
	});

	var _stringToArray = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _asciiToArray_js_1 = _asciiToArray;
	var _hasUnicode_js_1 = _hasUnicode;
	var _unicodeToArray_js_1 = _unicodeToArray;
	function stringToArray(string) {
	    return _hasUnicode_js_1.default(string)
	        ? _unicodeToArray_js_1.default(string)
	        : _asciiToArray_js_1.default(string);
	}
	exports.default = stringToArray;
	});

	var _createCaseFirst = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _castSlice_js_1 = _castSlice;
	var _hasUnicode_js_1 = _hasUnicode;
	var _stringToArray_js_1 = _stringToArray;
	var toString_js_1 = toString_1;
	function createCaseFirst(methodName) {
	    return function (string) {
	        string = toString_js_1.default(string);
	        var strSymbols = _hasUnicode_js_1.default(string)
	            ? _stringToArray_js_1.default(string)
	            : undefined;
	        var chr = strSymbols
	            ? strSymbols[0]
	            : string.charAt(0);
	        var trailing = strSymbols
	            ? _castSlice_js_1.default(strSymbols, 1).join('')
	            : string.slice(1);
	        return chr[methodName]() + trailing;
	    };
	}
	exports.default = createCaseFirst;
	});

	var upperFirst_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _createCaseFirst_js_1 = _createCaseFirst;
	var upperFirst = _createCaseFirst_js_1.default('toUpperCase');
	exports.default = upperFirst;
	});

	var capitalize_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var toString_js_1 = toString_1;
	var upperFirst_js_1 = upperFirst_1;
	function capitalize(string) {
	    return upperFirst_js_1.default(toString_js_1.default(string).toLowerCase());
	}
	exports.default = capitalize;
	});

	var _arrayReduce = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	function arrayReduce(array, iteratee, accumulator, initAccum) {
	    var index = -1, length = array == null ? 0 : array.length;
	    if (initAccum && length) {
	        accumulator = array[++index];
	    }
	    while (++index < length) {
	        accumulator = iteratee(accumulator, array[index], index, array);
	    }
	    return accumulator;
	}
	exports.default = arrayReduce;
	});

	var _basePropertyOf = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	function basePropertyOf(object) {
	    return function (key) {
	        return object == null ? undefined : object[key];
	    };
	}
	exports.default = basePropertyOf;
	});

	var _deburrLetter = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _basePropertyOf_js_1 = _basePropertyOf;
	var deburredLetters = {
	    '\xc0': 'A', '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
	    '\xe0': 'a', '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
	    '\xc7': 'C', '\xe7': 'c',
	    '\xd0': 'D', '\xf0': 'd',
	    '\xc8': 'E', '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
	    '\xe8': 'e', '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
	    '\xcc': 'I', '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
	    '\xec': 'i', '\xed': 'i', '\xee': 'i', '\xef': 'i',
	    '\xd1': 'N', '\xf1': 'n',
	    '\xd2': 'O', '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
	    '\xf2': 'o', '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
	    '\xd9': 'U', '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
	    '\xf9': 'u', '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
	    '\xdd': 'Y', '\xfd': 'y', '\xff': 'y',
	    '\xc6': 'Ae', '\xe6': 'ae',
	    '\xde': 'Th', '\xfe': 'th',
	    '\xdf': 'ss',
	    '\u0100': 'A', '\u0102': 'A', '\u0104': 'A',
	    '\u0101': 'a', '\u0103': 'a', '\u0105': 'a',
	    '\u0106': 'C', '\u0108': 'C', '\u010a': 'C', '\u010c': 'C',
	    '\u0107': 'c', '\u0109': 'c', '\u010b': 'c', '\u010d': 'c',
	    '\u010e': 'D', '\u0110': 'D', '\u010f': 'd', '\u0111': 'd',
	    '\u0112': 'E', '\u0114': 'E', '\u0116': 'E', '\u0118': 'E', '\u011a': 'E',
	    '\u0113': 'e', '\u0115': 'e', '\u0117': 'e', '\u0119': 'e', '\u011b': 'e',
	    '\u011c': 'G', '\u011e': 'G', '\u0120': 'G', '\u0122': 'G',
	    '\u011d': 'g', '\u011f': 'g', '\u0121': 'g', '\u0123': 'g',
	    '\u0124': 'H', '\u0126': 'H', '\u0125': 'h', '\u0127': 'h',
	    '\u0128': 'I', '\u012a': 'I', '\u012c': 'I', '\u012e': 'I', '\u0130': 'I',
	    '\u0129': 'i', '\u012b': 'i', '\u012d': 'i', '\u012f': 'i', '\u0131': 'i',
	    '\u0134': 'J', '\u0135': 'j',
	    '\u0136': 'K', '\u0137': 'k', '\u0138': 'k',
	    '\u0139': 'L', '\u013b': 'L', '\u013d': 'L', '\u013f': 'L', '\u0141': 'L',
	    '\u013a': 'l', '\u013c': 'l', '\u013e': 'l', '\u0140': 'l', '\u0142': 'l',
	    '\u0143': 'N', '\u0145': 'N', '\u0147': 'N', '\u014a': 'N',
	    '\u0144': 'n', '\u0146': 'n', '\u0148': 'n', '\u014b': 'n',
	    '\u014c': 'O', '\u014e': 'O', '\u0150': 'O',
	    '\u014d': 'o', '\u014f': 'o', '\u0151': 'o',
	    '\u0154': 'R', '\u0156': 'R', '\u0158': 'R',
	    '\u0155': 'r', '\u0157': 'r', '\u0159': 'r',
	    '\u015a': 'S', '\u015c': 'S', '\u015e': 'S', '\u0160': 'S',
	    '\u015b': 's', '\u015d': 's', '\u015f': 's', '\u0161': 's',
	    '\u0162': 'T', '\u0164': 'T', '\u0166': 'T',
	    '\u0163': 't', '\u0165': 't', '\u0167': 't',
	    '\u0168': 'U', '\u016a': 'U', '\u016c': 'U', '\u016e': 'U', '\u0170': 'U', '\u0172': 'U',
	    '\u0169': 'u', '\u016b': 'u', '\u016d': 'u', '\u016f': 'u', '\u0171': 'u', '\u0173': 'u',
	    '\u0174': 'W', '\u0175': 'w',
	    '\u0176': 'Y', '\u0177': 'y', '\u0178': 'Y',
	    '\u0179': 'Z', '\u017b': 'Z', '\u017d': 'Z',
	    '\u017a': 'z', '\u017c': 'z', '\u017e': 'z',
	    '\u0132': 'IJ', '\u0133': 'ij',
	    '\u0152': 'Oe', '\u0153': 'oe',
	    '\u0149': "'n", '\u017f': 's'
	};
	var deburrLetter = _basePropertyOf_js_1.default(deburredLetters);
	exports.default = deburrLetter;
	});

	var deburr_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _deburrLetter_js_1 = _deburrLetter;
	var toString_js_1 = toString_1;
	var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
	var rsComboMarksRange = '\\u0300-\\u036f', reComboHalfMarksRange = '\\ufe20-\\ufe2f', rsComboSymbolsRange = '\\u20d0-\\u20ff', rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
	var rsCombo = '[' + rsComboRange + ']';
	var reComboMark = RegExp(rsCombo, 'g');
	function deburr(string) {
	    string = toString_js_1.default(string);
	    return string && string.replace(reLatin, _deburrLetter_js_1.default).replace(reComboMark, '');
	}
	exports.default = deburr;
	});

	var _asciiWords = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
	function asciiWords(string) {
	    return string.match(reAsciiWord) || [];
	}
	exports.default = asciiWords;
	});

	var _hasUnicodeWord = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
	function hasUnicodeWord(string) {
	    return reHasUnicodeWord.test(string);
	}
	exports.default = hasUnicodeWord;
	});

	var _unicodeWords = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var rsAstralRange = '\\ud800-\\udfff', rsComboMarksRange = '\\u0300-\\u036f', reComboHalfMarksRange = '\\ufe20-\\ufe2f', rsComboSymbolsRange = '\\u20d0-\\u20ff', rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = '\\u2700-\\u27bf', rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff', rsMathOpRange = '\\xac\\xb1\\xd7\\xf7', rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf', rsPunctuationRange = '\\u2000-\\u206f', rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000', rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde', rsVarRange = '\\ufe0e\\ufe0f', rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
	var rsApos = "['\u2019]", rsBreak = '[' + rsBreakRange + ']', rsCombo = '[' + rsComboRange + ']', rsDigits = '\\d+', rsDingbat = '[' + rsDingbatRange + ']', rsLower = '[' + rsLowerRange + ']', rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']', rsFitz = '\\ud83c[\\udffb-\\udfff]', rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')', rsNonAstral = '[^' + rsAstralRange + ']', rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}', rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]', rsUpper = '[' + rsUpperRange + ']', rsZWJ = '\\u200d';
	var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')', rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')', rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?', rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?', reOptMod = rsModifier + '?', rsOptVar = '[' + rsVarRange + ']?', rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*', rsOrdLower = '\\d*(?:(?:1st|2nd|3rd|(?![123])\\dth)\\b)', rsOrdUpper = '\\d*(?:(?:1ST|2ND|3RD|(?![123])\\dTH)\\b)', rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq;
	var reUnicodeWord = RegExp([
	    rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',
	    rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',
	    rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,
	    rsUpper + '+' + rsOptContrUpper,
	    rsOrdUpper,
	    rsOrdLower,
	    rsDigits,
	    rsEmoji
	].join('|'), 'g');
	function unicodeWords(string) {
	    return string.match(reUnicodeWord) || [];
	}
	exports.default = unicodeWords;
	});

	var words_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _asciiWords_js_1 = _asciiWords;
	var _hasUnicodeWord_js_1 = _hasUnicodeWord;
	var toString_js_1 = toString_1;
	var _unicodeWords_js_1 = _unicodeWords;
	function words(string, pattern, guard) {
	    string = toString_js_1.default(string);
	    pattern = guard ? undefined : pattern;
	    if (pattern === undefined) {
	        return _hasUnicodeWord_js_1.default(string) ? _unicodeWords_js_1.default(string) : _asciiWords_js_1.default(string);
	    }
	    return string.match(pattern) || [];
	}
	exports.default = words;
	});

	var _createCompounder = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _arrayReduce_js_1 = _arrayReduce;
	var deburr_js_1 = deburr_1;
	var words_js_1 = words_1;
	var rsApos = "['\u2019]";
	var reApos = RegExp(rsApos, 'g');
	function createCompounder(callback) {
	    return function (string) {
	        return _arrayReduce_js_1.default(words_js_1.default(deburr_js_1.default(string).replace(reApos, '')), callback, '');
	    };
	}
	exports.default = createCompounder;
	});

	var camelCase_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var capitalize_js_1 = capitalize_1;
	var _createCompounder_js_1 = _createCompounder;
	var camelCase = _createCompounder_js_1.default(function (result, word, index) {
	    word = word.toLowerCase();
	    return result + (index ? capitalize_js_1.default(word) : word);
	});
	exports.default = camelCase;
	});

	var castArray_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var isArray_js_1 = isArray_1;
	function castArray() {
	    if (!arguments.length) {
	        return [];
	    }
	    var value = arguments[0];
	    return isArray_js_1.default(value) ? value : [value];
	}
	exports.default = castArray;
	});

	var _createRound = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var toInteger_js_1 = toInteger_1;
	var toNumber_js_1 = toNumber_1;
	var toString_js_1 = toString_1;
	var nativeMin = Math.min;
	function createRound(methodName) {
	    var func = Math[methodName];
	    return function (number, precision) {
	        number = toNumber_js_1.default(number);
	        precision = precision == null ? 0 : nativeMin(toInteger_js_1.default(precision), 292);
	        if (precision) {
	            var pair = (toString_js_1.default(number) + 'e').split('e'), value = func(pair[0] + 'e' + (+pair[1] + precision));
	            pair = (toString_js_1.default(value) + 'e').split('e');
	            return +(pair[0] + 'e' + (+pair[1] - precision));
	        }
	        return func(number);
	    };
	}
	exports.default = createRound;
	});

	var ceil_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _createRound_js_1 = _createRound;
	var ceil = _createRound_js_1.default('ceil');
	exports.default = ceil;
	});

	var chain_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var wrapperLodash_js_1 = wrapperLodash;
	function chain(value) {
	    var result = wrapperLodash_js_1.default(value);
	    result.__chain__ = true;
	    return result;
	}
	exports.default = chain;
	});

	var chunk_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseSlice_js_1 = _baseSlice;
	var _isIterateeCall_js_1 = _isIterateeCall;
	var toInteger_js_1 = toInteger_1;
	var nativeCeil = Math.ceil, nativeMax = Math.max;
	function chunk(array, size, guard) {
	    if ((guard ? _isIterateeCall_js_1.default(array, size, guard) : size === undefined)) {
	        size = 1;
	    }
	    else {
	        size = nativeMax(toInteger_js_1.default(size), 0);
	    }
	    var length = array == null ? 0 : array.length;
	    if (!length || size < 1) {
	        return [];
	    }
	    var index = 0, resIndex = 0, result = Array(nativeCeil(length / size));
	    while (index < length) {
	        result[resIndex++] = _baseSlice_js_1.default(array, index, (index += size));
	    }
	    return result;
	}
	exports.default = chunk;
	});

	var _baseClamp = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	function baseClamp(number, lower, upper) {
	    if (number === number) {
	        if (upper !== undefined) {
	            number = number <= upper ? number : upper;
	        }
	        if (lower !== undefined) {
	            number = number >= lower ? number : lower;
	        }
	    }
	    return number;
	}
	exports.default = baseClamp;
	});

	var clamp_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseClamp_js_1 = _baseClamp;
	var toNumber_js_1 = toNumber_1;
	function clamp(number, lower, upper) {
	    if (upper === undefined) {
	        upper = lower;
	        lower = undefined;
	    }
	    if (upper !== undefined) {
	        upper = toNumber_js_1.default(upper);
	        upper = upper === upper ? upper : 0;
	    }
	    if (lower !== undefined) {
	        lower = toNumber_js_1.default(lower);
	        lower = lower === lower ? lower : 0;
	    }
	    return _baseClamp_js_1.default(toNumber_js_1.default(number), lower, upper);
	}
	exports.default = clamp;
	});

	var _stackClear = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _ListCache_js_1 = _ListCache;
	function stackClear() {
	    this.__data__ = new _ListCache_js_1.default;
	    this.size = 0;
	}
	exports.default = stackClear;
	});

	var _stackDelete = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	function stackDelete(key) {
	    var data = this.__data__, result = data['delete'](key);
	    this.size = data.size;
	    return result;
	}
	exports.default = stackDelete;
	});

	var _stackGet = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	function stackGet(key) {
	    return this.__data__.get(key);
	}
	exports.default = stackGet;
	});

	var _stackHas = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	function stackHas(key) {
	    return this.__data__.has(key);
	}
	exports.default = stackHas;
	});

	var _stackSet = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _ListCache_js_1 = _ListCache;
	var _Map_js_1 = _Map;
	var _MapCache_js_1 = _MapCache;
	var LARGE_ARRAY_SIZE = 200;
	function stackSet(key, value) {
	    var data = this.__data__;
	    if (data instanceof _ListCache_js_1.default) {
	        var pairs = data.__data__;
	        if (!_Map_js_1.default || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
	            pairs.push([key, value]);
	            this.size = ++data.size;
	            return this;
	        }
	        data = this.__data__ = new _MapCache_js_1.default(pairs);
	    }
	    data.set(key, value);
	    this.size = data.size;
	    return this;
	}
	exports.default = stackSet;
	});

	var _Stack = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _ListCache_js_1 = _ListCache;
	var _stackClear_js_1 = _stackClear;
	var _stackDelete_js_1 = _stackDelete;
	var _stackGet_js_1 = _stackGet;
	var _stackHas_js_1 = _stackHas;
	var _stackSet_js_1 = _stackSet;
	function Stack(entries) {
	    var data = this.__data__ = new _ListCache_js_1.default(entries);
	    this.size = data.size;
	}
	Stack.prototype.clear = _stackClear_js_1.default;
	Stack.prototype['delete'] = _stackDelete_js_1.default;
	Stack.prototype.get = _stackGet_js_1.default;
	Stack.prototype.has = _stackHas_js_1.default;
	Stack.prototype.set = _stackSet_js_1.default;
	exports.default = Stack;
	});

	var _baseAssign = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _copyObject_js_1 = _copyObject;
	var keys_js_1 = keys_1;
	function baseAssign(object, source) {
	    return object && _copyObject_js_1.default(source, keys_js_1.default(source), object);
	}
	exports.default = baseAssign;
	});

	var _baseAssignIn = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _copyObject_js_1 = _copyObject;
	var keysIn_js_1 = keysIn_1;
	function baseAssignIn(object, source) {
	    return object && _copyObject_js_1.default(source, keysIn_js_1.default(source), object);
	}
	exports.default = baseAssignIn;
	});

	var _cloneBuffer = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _root_js_1 = _root;
	var freeExports = 'object' == 'object' && exports && !exports.nodeType && exports;
	var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;
	var moduleExports = freeModule && freeModule.exports === freeExports;
	var Buffer = moduleExports ? _root_js_1.default.Buffer : undefined, allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;
	function cloneBuffer(buffer, isDeep) {
	    if (isDeep) {
	        return buffer.slice();
	    }
	    var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
	    buffer.copy(result);
	    return result;
	}
	exports.default = cloneBuffer;
	});

	var _arrayFilter = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	function arrayFilter(array, predicate) {
	    var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
	    while (++index < length) {
	        var value = array[index];
	        if (predicate(value, index, array)) {
	            result[resIndex++] = value;
	        }
	    }
	    return result;
	}
	exports.default = arrayFilter;
	});

	var stubArray_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	function stubArray() {
	    return [];
	}
	exports.default = stubArray;
	});

	var _getSymbols = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _arrayFilter_js_1 = _arrayFilter;
	var stubArray_js_1 = stubArray_1;
	var objectProto = Object.prototype;
	var propertyIsEnumerable = objectProto.propertyIsEnumerable;
	var nativeGetSymbols = Object.getOwnPropertySymbols;
	var getSymbols = !nativeGetSymbols ? stubArray_js_1.default : function (object) {
	    if (object == null) {
	        return [];
	    }
	    object = Object(object);
	    return _arrayFilter_js_1.default(nativeGetSymbols(object), function (symbol) {
	        return propertyIsEnumerable.call(object, symbol);
	    });
	};
	exports.default = getSymbols;
	});

	var _copySymbols = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _copyObject_js_1 = _copyObject;
	var _getSymbols_js_1 = _getSymbols;
	function copySymbols(source, object) {
	    return _copyObject_js_1.default(source, _getSymbols_js_1.default(source), object);
	}
	exports.default = copySymbols;
	});

	var _getSymbolsIn = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _arrayPush_js_1 = _arrayPush;
	var _getPrototype_js_1 = _getPrototype;
	var _getSymbols_js_1 = _getSymbols;
	var stubArray_js_1 = stubArray_1;
	var nativeGetSymbols = Object.getOwnPropertySymbols;
	var getSymbolsIn = !nativeGetSymbols ? stubArray_js_1.default : function (object) {
	    var result = [];
	    while (object) {
	        _arrayPush_js_1.default(result, _getSymbols_js_1.default(object));
	        object = _getPrototype_js_1.default(object);
	    }
	    return result;
	};
	exports.default = getSymbolsIn;
	});

	var _copySymbolsIn = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _copyObject_js_1 = _copyObject;
	var _getSymbolsIn_js_1 = _getSymbolsIn;
	function copySymbolsIn(source, object) {
	    return _copyObject_js_1.default(source, _getSymbolsIn_js_1.default(source), object);
	}
	exports.default = copySymbolsIn;
	});

	var _baseGetAllKeys = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _arrayPush_js_1 = _arrayPush;
	var isArray_js_1 = isArray_1;
	function baseGetAllKeys(object, keysFunc, symbolsFunc) {
	    var result = keysFunc(object);
	    return isArray_js_1.default(object) ? result : _arrayPush_js_1.default(result, symbolsFunc(object));
	}
	exports.default = baseGetAllKeys;
	});

	var _getAllKeys = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseGetAllKeys_js_1 = _baseGetAllKeys;
	var _getSymbols_js_1 = _getSymbols;
	var keys_js_1 = keys_1;
	function getAllKeys(object) {
	    return _baseGetAllKeys_js_1.default(object, keys_js_1.default, _getSymbols_js_1.default);
	}
	exports.default = getAllKeys;
	});

	var _getAllKeysIn = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseGetAllKeys_js_1 = _baseGetAllKeys;
	var _getSymbolsIn_js_1 = _getSymbolsIn;
	var keysIn_js_1 = keysIn_1;
	function getAllKeysIn(object) {
	    return _baseGetAllKeys_js_1.default(object, keysIn_js_1.default, _getSymbolsIn_js_1.default);
	}
	exports.default = getAllKeysIn;
	});

	var _DataView = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _getNative_js_1 = _getNative;
	var _root_js_1 = _root;
	var DataView = _getNative_js_1.default(_root_js_1.default, 'DataView');
	exports.default = DataView;
	});

	var _Promise = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _getNative_js_1 = _getNative;
	var _root_js_1 = _root;
	var Promise = _getNative_js_1.default(_root_js_1.default, 'Promise');
	exports.default = Promise;
	});

	var _Set = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _getNative_js_1 = _getNative;
	var _root_js_1 = _root;
	var Set = _getNative_js_1.default(_root_js_1.default, 'Set');
	exports.default = Set;
	});

	var _getTag = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _DataView_js_1 = _DataView;
	var _Map_js_1 = _Map;
	var _Promise_js_1 = _Promise;
	var _Set_js_1 = _Set;
	var _WeakMap_js_1 = _WeakMap;
	var _baseGetTag_js_1 = _baseGetTag;
	var _toSource_js_1 = _toSource;
	var mapTag = '[object Map]', objectTag = '[object Object]', promiseTag = '[object Promise]', setTag = '[object Set]', weakMapTag = '[object WeakMap]';
	var dataViewTag = '[object DataView]';
	var dataViewCtorString = _toSource_js_1.default(_DataView_js_1.default), mapCtorString = _toSource_js_1.default(_Map_js_1.default), promiseCtorString = _toSource_js_1.default(_Promise_js_1.default), setCtorString = _toSource_js_1.default(_Set_js_1.default), weakMapCtorString = _toSource_js_1.default(_WeakMap_js_1.default);
	var getTag = _baseGetTag_js_1.default;
	if ((_DataView_js_1.default && getTag(new _DataView_js_1.default(new ArrayBuffer(1))) != dataViewTag) ||
	    (_Map_js_1.default && getTag(new _Map_js_1.default) != mapTag) ||
	    (_Promise_js_1.default && getTag(_Promise_js_1.default.resolve()) != promiseTag) ||
	    (_Set_js_1.default && getTag(new _Set_js_1.default) != setTag) ||
	    (_WeakMap_js_1.default && getTag(new _WeakMap_js_1.default) != weakMapTag)) {
	    getTag = function (value) {
	        var result = _baseGetTag_js_1.default(value), Ctor = result == objectTag ? value.constructor : undefined, ctorString = Ctor ? _toSource_js_1.default(Ctor) : '';
	        if (ctorString) {
	            switch (ctorString) {
	                case dataViewCtorString: return dataViewTag;
	                case mapCtorString: return mapTag;
	                case promiseCtorString: return promiseTag;
	                case setCtorString: return setTag;
	                case weakMapCtorString: return weakMapTag;
	            }
	        }
	        return result;
	    };
	}
	exports.default = getTag;
	});

	var _initCloneArray = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var objectProto = Object.prototype;
	var hasOwnProperty = objectProto.hasOwnProperty;
	function initCloneArray(array) {
	    var length = array.length, result = array.constructor(length);
	    if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
	        result.index = array.index;
	        result.input = array.input;
	    }
	    return result;
	}
	exports.default = initCloneArray;
	});

	var _Uint8Array = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _root_js_1 = _root;
	var Uint8Array = _root_js_1.default.Uint8Array;
	exports.default = Uint8Array;
	});

	var _cloneArrayBuffer = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _Uint8Array_js_1 = _Uint8Array;
	function cloneArrayBuffer(arrayBuffer) {
	    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
	    new _Uint8Array_js_1.default(result).set(new _Uint8Array_js_1.default(arrayBuffer));
	    return result;
	}
	exports.default = cloneArrayBuffer;
	});

	var _cloneDataView = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _cloneArrayBuffer_js_1 = _cloneArrayBuffer;
	function cloneDataView(dataView, isDeep) {
	    var buffer = isDeep ? _cloneArrayBuffer_js_1.default(dataView.buffer) : dataView.buffer;
	    return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
	}
	exports.default = cloneDataView;
	});

	var _addMapEntry = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	function addMapEntry(map, pair) {
	    map.set(pair[0], pair[1]);
	    return map;
	}
	exports.default = addMapEntry;
	});

	var _mapToArray = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	function mapToArray(map) {
	    var index = -1, result = Array(map.size);
	    map.forEach(function (value, key) {
	        result[++index] = [key, value];
	    });
	    return result;
	}
	exports.default = mapToArray;
	});

	var _cloneMap = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _addMapEntry_js_1 = _addMapEntry;
	var _arrayReduce_js_1 = _arrayReduce;
	var _mapToArray_js_1 = _mapToArray;
	var CLONE_DEEP_FLAG = 1;
	function cloneMap(map, isDeep, cloneFunc) {
	    var array = isDeep ? cloneFunc(_mapToArray_js_1.default(map), CLONE_DEEP_FLAG) : _mapToArray_js_1.default(map);
	    return _arrayReduce_js_1.default(array, _addMapEntry_js_1.default, new map.constructor);
	}
	exports.default = cloneMap;
	});

	var _cloneRegExp = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var reFlags = /\w*$/;
	function cloneRegExp(regexp) {
	    var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
	    result.lastIndex = regexp.lastIndex;
	    return result;
	}
	exports.default = cloneRegExp;
	});

	var _addSetEntry = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	function addSetEntry(set, value) {
	    set.add(value);
	    return set;
	}
	exports.default = addSetEntry;
	});

	var _setToArray = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	function setToArray(set) {
	    var index = -1, result = Array(set.size);
	    set.forEach(function (value) {
	        result[++index] = value;
	    });
	    return result;
	}
	exports.default = setToArray;
	});

	var _cloneSet = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _addSetEntry_js_1 = _addSetEntry;
	var _arrayReduce_js_1 = _arrayReduce;
	var _setToArray_js_1 = _setToArray;
	var CLONE_DEEP_FLAG = 1;
	function cloneSet(set, isDeep, cloneFunc) {
	    var array = isDeep ? cloneFunc(_setToArray_js_1.default(set), CLONE_DEEP_FLAG) : _setToArray_js_1.default(set);
	    return _arrayReduce_js_1.default(array, _addSetEntry_js_1.default, new set.constructor);
	}
	exports.default = cloneSet;
	});

	var _cloneSymbol = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _Symbol_js_1 = _Symbol;
	var symbolProto = _Symbol_js_1.default ? _Symbol_js_1.default.prototype : undefined, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;
	function cloneSymbol(symbol) {
	    return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
	}
	exports.default = cloneSymbol;
	});

	var _cloneTypedArray = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _cloneArrayBuffer_js_1 = _cloneArrayBuffer;
	function cloneTypedArray(typedArray, isDeep) {
	    var buffer = isDeep ? _cloneArrayBuffer_js_1.default(typedArray.buffer) : typedArray.buffer;
	    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
	}
	exports.default = cloneTypedArray;
	});

	var _initCloneByTag = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _cloneArrayBuffer_js_1 = _cloneArrayBuffer;
	var _cloneDataView_js_1 = _cloneDataView;
	var _cloneMap_js_1 = _cloneMap;
	var _cloneRegExp_js_1 = _cloneRegExp;
	var _cloneSet_js_1 = _cloneSet;
	var _cloneSymbol_js_1 = _cloneSymbol;
	var _cloneTypedArray_js_1 = _cloneTypedArray;
	var boolTag = '[object Boolean]', dateTag = '[object Date]', mapTag = '[object Map]', numberTag = '[object Number]', regexpTag = '[object RegExp]', setTag = '[object Set]', stringTag = '[object String]', symbolTag = '[object Symbol]';
	var arrayBufferTag = '[object ArrayBuffer]', dataViewTag = '[object DataView]', float32Tag = '[object Float32Array]', float64Tag = '[object Float64Array]', int8Tag = '[object Int8Array]', int16Tag = '[object Int16Array]', int32Tag = '[object Int32Array]', uint8Tag = '[object Uint8Array]', uint8ClampedTag = '[object Uint8ClampedArray]', uint16Tag = '[object Uint16Array]', uint32Tag = '[object Uint32Array]';
	function initCloneByTag(object, tag, cloneFunc, isDeep) {
	    var Ctor = object.constructor;
	    switch (tag) {
	        case arrayBufferTag:
	            return _cloneArrayBuffer_js_1.default(object);
	        case boolTag:
	        case dateTag:
	            return new Ctor(+object);
	        case dataViewTag:
	            return _cloneDataView_js_1.default(object, isDeep);
	        case float32Tag:
	        case float64Tag:
	        case int8Tag:
	        case int16Tag:
	        case int32Tag:
	        case uint8Tag:
	        case uint8ClampedTag:
	        case uint16Tag:
	        case uint32Tag:
	            return _cloneTypedArray_js_1.default(object, isDeep);
	        case mapTag:
	            return _cloneMap_js_1.default(object, isDeep, cloneFunc);
	        case numberTag:
	        case stringTag:
	            return new Ctor(object);
	        case regexpTag:
	            return _cloneRegExp_js_1.default(object);
	        case setTag:
	            return _cloneSet_js_1.default(object, isDeep, cloneFunc);
	        case symbolTag:
	            return _cloneSymbol_js_1.default(object);
	    }
	}
	exports.default = initCloneByTag;
	});

	var _initCloneObject = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseCreate_js_1 = _baseCreate;
	var _getPrototype_js_1 = _getPrototype;
	var _isPrototype_js_1 = _isPrototype;
	function initCloneObject(object) {
	    return (typeof object.constructor == 'function' && !_isPrototype_js_1.default(object))
	        ? _baseCreate_js_1.default(_getPrototype_js_1.default(object))
	        : {};
	}
	exports.default = initCloneObject;
	});

	var _baseClone = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _Stack_js_1 = _Stack;
	var _arrayEach_js_1 = _arrayEach;
	var _assignValue_js_1 = _assignValue;
	var _baseAssign_js_1 = _baseAssign;
	var _baseAssignIn_js_1 = _baseAssignIn;
	var _cloneBuffer_js_1 = _cloneBuffer;
	var _copyArray_js_1 = _copyArray;
	var _copySymbols_js_1 = _copySymbols;
	var _copySymbolsIn_js_1 = _copySymbolsIn;
	var _getAllKeys_js_1 = _getAllKeys;
	var _getAllKeysIn_js_1 = _getAllKeysIn;
	var _getTag_js_1 = _getTag;
	var _initCloneArray_js_1 = _initCloneArray;
	var _initCloneByTag_js_1 = _initCloneByTag;
	var _initCloneObject_js_1 = _initCloneObject;
	var isArray_js_1 = isArray_1;
	var isBuffer_js_1 = isBuffer_1;
	var isObject_js_1 = isObject_1;
	var keys_js_1 = keys_1;
	var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
	var argsTag = '[object Arguments]', arrayTag = '[object Array]', boolTag = '[object Boolean]', dateTag = '[object Date]', errorTag = '[object Error]', funcTag = '[object Function]', genTag = '[object GeneratorFunction]', mapTag = '[object Map]', numberTag = '[object Number]', objectTag = '[object Object]', regexpTag = '[object RegExp]', setTag = '[object Set]', stringTag = '[object String]', symbolTag = '[object Symbol]', weakMapTag = '[object WeakMap]';
	var arrayBufferTag = '[object ArrayBuffer]', dataViewTag = '[object DataView]', float32Tag = '[object Float32Array]', float64Tag = '[object Float64Array]', int8Tag = '[object Int8Array]', int16Tag = '[object Int16Array]', int32Tag = '[object Int32Array]', uint8Tag = '[object Uint8Array]', uint8ClampedTag = '[object Uint8ClampedArray]', uint16Tag = '[object Uint16Array]', uint32Tag = '[object Uint32Array]';
	var cloneableTags = {};
	cloneableTags[argsTag] = cloneableTags[arrayTag] =
	    cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
	        cloneableTags[boolTag] = cloneableTags[dateTag] =
	            cloneableTags[float32Tag] = cloneableTags[float64Tag] =
	                cloneableTags[int8Tag] = cloneableTags[int16Tag] =
	                    cloneableTags[int32Tag] = cloneableTags[mapTag] =
	                        cloneableTags[numberTag] = cloneableTags[objectTag] =
	                            cloneableTags[regexpTag] = cloneableTags[setTag] =
	                                cloneableTags[stringTag] = cloneableTags[symbolTag] =
	                                    cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
	                                        cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
	cloneableTags[errorTag] = cloneableTags[funcTag] =
	    cloneableTags[weakMapTag] = false;
	function baseClone(value, bitmask, customizer, key, object, stack) {
	    var result, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
	    if (customizer) {
	        result = object ? customizer(value, key, object, stack) : customizer(value);
	    }
	    if (result !== undefined) {
	        return result;
	    }
	    if (!isObject_js_1.default(value)) {
	        return value;
	    }
	    var isArr = isArray_js_1.default(value);
	    if (isArr) {
	        result = _initCloneArray_js_1.default(value);
	        if (!isDeep) {
	            return _copyArray_js_1.default(value, result);
	        }
	    }
	    else {
	        var tag = _getTag_js_1.default(value), isFunc = tag == funcTag || tag == genTag;
	        if (isBuffer_js_1.default(value)) {
	            return _cloneBuffer_js_1.default(value, isDeep);
	        }
	        if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
	            result = (isFlat || isFunc) ? {} : _initCloneObject_js_1.default(value);
	            if (!isDeep) {
	                return isFlat
	                    ? _copySymbolsIn_js_1.default(value, _baseAssignIn_js_1.default(result, value))
	                    : _copySymbols_js_1.default(value, _baseAssign_js_1.default(result, value));
	            }
	        }
	        else {
	            if (!cloneableTags[tag]) {
	                return object ? value : {};
	            }
	            result = _initCloneByTag_js_1.default(value, tag, baseClone, isDeep);
	        }
	    }
	    stack || (stack = new _Stack_js_1.default);
	    var stacked = stack.get(value);
	    if (stacked) {
	        return stacked;
	    }
	    stack.set(value, result);
	    var keysFunc = isFull
	        ? (isFlat ? _getAllKeysIn_js_1.default : _getAllKeys_js_1.default)
	        : (isFlat ? keysIn : keys_js_1.default);
	    var props = isArr ? undefined : keysFunc(value);
	    _arrayEach_js_1.default(props || value, function (subValue, key) {
	        if (props) {
	            key = subValue;
	            subValue = value[key];
	        }
	        _assignValue_js_1.default(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
	    });
	    return result;
	}
	exports.default = baseClone;
	});

	var clone_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseClone_js_1 = _baseClone;
	var CLONE_SYMBOLS_FLAG = 4;
	function clone(value) {
	    return _baseClone_js_1.default(value, CLONE_SYMBOLS_FLAG);
	}
	exports.default = clone;
	});

	var cloneDeep_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseClone_js_1 = _baseClone;
	var CLONE_DEEP_FLAG = 1, CLONE_SYMBOLS_FLAG = 4;
	function cloneDeep(value) {
	    return _baseClone_js_1.default(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
	}
	exports.default = cloneDeep;
	});

	var cloneDeepWith_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseClone_js_1 = _baseClone;
	var CLONE_DEEP_FLAG = 1, CLONE_SYMBOLS_FLAG = 4;
	function cloneDeepWith(value, customizer) {
	    customizer = typeof customizer == 'function' ? customizer : undefined;
	    return _baseClone_js_1.default(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
	}
	exports.default = cloneDeepWith;
	});

	var cloneWith_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseClone_js_1 = _baseClone;
	var CLONE_SYMBOLS_FLAG = 4;
	function cloneWith(value, customizer) {
	    customizer = typeof customizer == 'function' ? customizer : undefined;
	    return _baseClone_js_1.default(value, CLONE_SYMBOLS_FLAG, customizer);
	}
	exports.default = cloneWith;
	});

	var commit = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _LodashWrapper_js_1 = _LodashWrapper;
	function wrapperCommit() {
	    return new _LodashWrapper_js_1.default(this.value(), this.__chain__);
	}
	exports.default = wrapperCommit;
	});

	var compact_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	function compact(array) {
	    var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
	    while (++index < length) {
	        var value = array[index];
	        if (value) {
	            result[resIndex++] = value;
	        }
	    }
	    return result;
	}
	exports.default = compact;
	});

	var concat_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _arrayPush_js_1 = _arrayPush;
	var _baseFlatten_js_1 = _baseFlatten;
	var _copyArray_js_1 = _copyArray;
	var isArray_js_1 = isArray_1;
	function concat() {
	    var length = arguments.length;
	    if (!length) {
	        return [];
	    }
	    var args = Array(length - 1), array = arguments[0], index = length;
	    while (index--) {
	        args[index - 1] = arguments[index];
	    }
	    return _arrayPush_js_1.default(isArray_js_1.default(array) ? _copyArray_js_1.default(array) : [array], _baseFlatten_js_1.default(args, 1));
	}
	exports.default = concat;
	});

	var _setCacheAdd = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var HASH_UNDEFINED = '__lodash_hash_undefined__';
	function setCacheAdd(value) {
	    this.__data__.set(value, HASH_UNDEFINED);
	    return this;
	}
	exports.default = setCacheAdd;
	});

	var _setCacheHas = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	function setCacheHas(value) {
	    return this.__data__.has(value);
	}
	exports.default = setCacheHas;
	});

	var _SetCache = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _MapCache_js_1 = _MapCache;
	var _setCacheAdd_js_1 = _setCacheAdd;
	var _setCacheHas_js_1 = _setCacheHas;
	function SetCache(values) {
	    var index = -1, length = values == null ? 0 : values.length;
	    this.__data__ = new _MapCache_js_1.default;
	    while (++index < length) {
	        this.add(values[index]);
	    }
	}
	SetCache.prototype.add = SetCache.prototype.push = _setCacheAdd_js_1.default;
	SetCache.prototype.has = _setCacheHas_js_1.default;
	exports.default = SetCache;
	});

	var _arraySome = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	function arraySome(array, predicate) {
	    var index = -1, length = array == null ? 0 : array.length;
	    while (++index < length) {
	        if (predicate(array[index], index, array)) {
	            return true;
	        }
	    }
	    return false;
	}
	exports.default = arraySome;
	});

	var _cacheHas = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	function cacheHas(cache, key) {
	    return cache.has(key);
	}
	exports.default = cacheHas;
	});

	var _equalArrays = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _SetCache_js_1 = _SetCache;
	var _arraySome_js_1 = _arraySome;
	var _cacheHas_js_1 = _cacheHas;
	var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
	function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
	    var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
	    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
	        return false;
	    }
	    var stacked = stack.get(array);
	    if (stacked && stack.get(other)) {
	        return stacked == other;
	    }
	    var index = -1, result = true, seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new _SetCache_js_1.default : undefined;
	    stack.set(array, other);
	    stack.set(other, array);
	    while (++index < arrLength) {
	        var arrValue = array[index], othValue = other[index];
	        if (customizer) {
	            var compared = isPartial
	                ? customizer(othValue, arrValue, index, other, array, stack)
	                : customizer(arrValue, othValue, index, array, other, stack);
	        }
	        if (compared !== undefined) {
	            if (compared) {
	                continue;
	            }
	            result = false;
	            break;
	        }
	        if (seen) {
	            if (!_arraySome_js_1.default(other, function (othValue, othIndex) {
	                if (!_cacheHas_js_1.default(seen, othIndex) &&
	                    (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
	                    return seen.push(othIndex);
	                }
	            })) {
	                result = false;
	                break;
	            }
	        }
	        else if (!(arrValue === othValue ||
	            equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
	            result = false;
	            break;
	        }
	    }
	    stack['delete'](array);
	    stack['delete'](other);
	    return result;
	}
	exports.default = equalArrays;
	});

	var _equalByTag = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _Symbol_js_1 = _Symbol;
	var _Uint8Array_js_1 = _Uint8Array;
	var eq_js_1 = eq_1;
	var _equalArrays_js_1 = _equalArrays;
	var _mapToArray_js_1 = _mapToArray;
	var _setToArray_js_1 = _setToArray;
	var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
	var boolTag = '[object Boolean]', dateTag = '[object Date]', errorTag = '[object Error]', mapTag = '[object Map]', numberTag = '[object Number]', regexpTag = '[object RegExp]', setTag = '[object Set]', stringTag = '[object String]', symbolTag = '[object Symbol]';
	var arrayBufferTag = '[object ArrayBuffer]', dataViewTag = '[object DataView]';
	var symbolProto = _Symbol_js_1.default ? _Symbol_js_1.default.prototype : undefined, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;
	function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
	    switch (tag) {
	        case dataViewTag:
	            if ((object.byteLength != other.byteLength) ||
	                (object.byteOffset != other.byteOffset)) {
	                return false;
	            }
	            object = object.buffer;
	            other = other.buffer;
	        case arrayBufferTag:
	            if ((object.byteLength != other.byteLength) ||
	                !equalFunc(new _Uint8Array_js_1.default(object), new _Uint8Array_js_1.default(other))) {
	                return false;
	            }
	            return true;
	        case boolTag:
	        case dateTag:
	        case numberTag:
	            return eq_js_1.default(+object, +other);
	        case errorTag:
	            return object.name == other.name && object.message == other.message;
	        case regexpTag:
	        case stringTag:
	            return object == (other + '');
	        case mapTag:
	            var convert = _mapToArray_js_1.default;
	        case setTag:
	            var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
	            convert || (convert = _setToArray_js_1.default);
	            if (object.size != other.size && !isPartial) {
	                return false;
	            }
	            var stacked = stack.get(object);
	            if (stacked) {
	                return stacked == other;
	            }
	            bitmask |= COMPARE_UNORDERED_FLAG;
	            stack.set(object, other);
	            var result = _equalArrays_js_1.default(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
	            stack['delete'](object);
	            return result;
	        case symbolTag:
	            if (symbolValueOf) {
	                return symbolValueOf.call(object) == symbolValueOf.call(other);
	            }
	    }
	    return false;
	}
	exports.default = equalByTag;
	});

	var _equalObjects = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _getAllKeys_js_1 = _getAllKeys;
	var COMPARE_PARTIAL_FLAG = 1;
	var objectProto = Object.prototype;
	var hasOwnProperty = objectProto.hasOwnProperty;
	function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
	    var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = _getAllKeys_js_1.default(object), objLength = objProps.length, othProps = _getAllKeys_js_1.default(other), othLength = othProps.length;
	    if (objLength != othLength && !isPartial) {
	        return false;
	    }
	    var index = objLength;
	    while (index--) {
	        var key = objProps[index];
	        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
	            return false;
	        }
	    }
	    var stacked = stack.get(object);
	    if (stacked && stack.get(other)) {
	        return stacked == other;
	    }
	    var result = true;
	    stack.set(object, other);
	    stack.set(other, object);
	    var skipCtor = isPartial;
	    while (++index < objLength) {
	        key = objProps[index];
	        var objValue = object[key], othValue = other[key];
	        if (customizer) {
	            var compared = isPartial
	                ? customizer(othValue, objValue, key, other, object, stack)
	                : customizer(objValue, othValue, key, object, other, stack);
	        }
	        if (!(compared === undefined
	            ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
	            : compared)) {
	            result = false;
	            break;
	        }
	        skipCtor || (skipCtor = key == 'constructor');
	    }
	    if (result && !skipCtor) {
	        var objCtor = object.constructor, othCtor = other.constructor;
	        if (objCtor != othCtor &&
	            ('constructor' in object && 'constructor' in other) &&
	            !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
	                typeof othCtor == 'function' && othCtor instanceof othCtor)) {
	            result = false;
	        }
	    }
	    stack['delete'](object);
	    stack['delete'](other);
	    return result;
	}
	exports.default = equalObjects;
	});

	var _baseIsEqualDeep = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _Stack_js_1 = _Stack;
	var _equalArrays_js_1 = _equalArrays;
	var _equalByTag_js_1 = _equalByTag;
	var _equalObjects_js_1 = _equalObjects;
	var _getTag_js_1 = _getTag;
	var isArray_js_1 = isArray_1;
	var isBuffer_js_1 = isBuffer_1;
	var isTypedArray_js_1 = isTypedArray_1;
	var COMPARE_PARTIAL_FLAG = 1;
	var argsTag = '[object Arguments]', arrayTag = '[object Array]', objectTag = '[object Object]';
	var objectProto = Object.prototype;
	var hasOwnProperty = objectProto.hasOwnProperty;
	function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
	    var objIsArr = isArray_js_1.default(object), othIsArr = isArray_js_1.default(other), objTag = objIsArr ? arrayTag : _getTag_js_1.default(object), othTag = othIsArr ? arrayTag : _getTag_js_1.default(other);
	    objTag = objTag == argsTag ? objectTag : objTag;
	    othTag = othTag == argsTag ? objectTag : othTag;
	    var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
	    if (isSameTag && isBuffer_js_1.default(object)) {
	        if (!isBuffer_js_1.default(other)) {
	            return false;
	        }
	        objIsArr = true;
	        objIsObj = false;
	    }
	    if (isSameTag && !objIsObj) {
	        stack || (stack = new _Stack_js_1.default);
	        return (objIsArr || isTypedArray_js_1.default(object))
	            ? _equalArrays_js_1.default(object, other, bitmask, customizer, equalFunc, stack)
	            : _equalByTag_js_1.default(object, other, objTag, bitmask, customizer, equalFunc, stack);
	    }
	    if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
	        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'), othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');
	        if (objIsWrapped || othIsWrapped) {
	            var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
	            stack || (stack = new _Stack_js_1.default);
	            return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
	        }
	    }
	    if (!isSameTag) {
	        return false;
	    }
	    stack || (stack = new _Stack_js_1.default);
	    return _equalObjects_js_1.default(object, other, bitmask, customizer, equalFunc, stack);
	}
	exports.default = baseIsEqualDeep;
	});

	var _baseIsEqual = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseIsEqualDeep_js_1 = _baseIsEqualDeep;
	var isObjectLike_js_1 = isObjectLike_1;
	function baseIsEqual(value, other, bitmask, customizer, stack) {
	    if (value === other) {
	        return true;
	    }
	    if (value == null || other == null || (!isObjectLike_js_1.default(value) && !isObjectLike_js_1.default(other))) {
	        return value !== value && other !== other;
	    }
	    return _baseIsEqualDeep_js_1.default(value, other, bitmask, customizer, baseIsEqual, stack);
	}
	exports.default = baseIsEqual;
	});

	var _baseIsMatch = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _Stack_js_1 = _Stack;
	var _baseIsEqual_js_1 = _baseIsEqual;
	var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
	function baseIsMatch(object, source, matchData, customizer) {
	    var index = matchData.length, length = index, noCustomizer = !customizer;
	    if (object == null) {
	        return !length;
	    }
	    object = Object(object);
	    while (index--) {
	        var data = matchData[index];
	        if ((noCustomizer && data[2])
	            ? data[1] !== object[data[0]]
	            : !(data[0] in object)) {
	            return false;
	        }
	    }
	    while (++index < length) {
	        data = matchData[index];
	        var key = data[0], objValue = object[key], srcValue = data[1];
	        if (noCustomizer && data[2]) {
	            if (objValue === undefined && !(key in object)) {
	                return false;
	            }
	        }
	        else {
	            var stack = new _Stack_js_1.default;
	            if (customizer) {
	                var result = customizer(objValue, srcValue, key, object, source, stack);
	            }
	            if (!(result === undefined
	                ? _baseIsEqual_js_1.default(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
	                : result)) {
	                return false;
	            }
	        }
	    }
	    return true;
	}
	exports.default = baseIsMatch;
	});

	var _isStrictComparable = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var isObject_js_1 = isObject_1;
	function isStrictComparable(value) {
	    return value === value && !isObject_js_1.default(value);
	}
	exports.default = isStrictComparable;
	});

	var _getMatchData = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _isStrictComparable_js_1 = _isStrictComparable;
	var keys_js_1 = keys_1;
	function getMatchData(object) {
	    var result = keys_js_1.default(object), length = result.length;
	    while (length--) {
	        var key = result[length], value = object[key];
	        result[length] = [key, value, _isStrictComparable_js_1.default(value)];
	    }
	    return result;
	}
	exports.default = getMatchData;
	});

	var _matchesStrictComparable = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	function matchesStrictComparable(key, srcValue) {
	    return function (object) {
	        if (object == null) {
	            return false;
	        }
	        return object[key] === srcValue &&
	            (srcValue !== undefined || (key in Object(object)));
	    };
	}
	exports.default = matchesStrictComparable;
	});

	var _baseMatches = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseIsMatch_js_1 = _baseIsMatch;
	var _getMatchData_js_1 = _getMatchData;
	var _matchesStrictComparable_js_1 = _matchesStrictComparable;
	function baseMatches(source) {
	    var matchData = _getMatchData_js_1.default(source);
	    if (matchData.length == 1 && matchData[0][2]) {
	        return _matchesStrictComparable_js_1.default(matchData[0][0], matchData[0][1]);
	    }
	    return function (object) {
	        return object === source || _baseIsMatch_js_1.default(object, source, matchData);
	    };
	}
	exports.default = baseMatches;
	});

	var _baseHasIn = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	function baseHasIn(object, key) {
	    return object != null && key in Object(object);
	}
	exports.default = baseHasIn;
	});

	var _hasPath = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _castPath_js_1 = _castPath;
	var isArguments_js_1 = isArguments_1;
	var isArray_js_1 = isArray_1;
	var _isIndex_js_1 = _isIndex;
	var isLength_js_1 = isLength_1;
	var _toKey_js_1 = _toKey;
	function hasPath(object, path, hasFunc) {
	    path = _castPath_js_1.default(path, object);
	    var index = -1, length = path.length, result = false;
	    while (++index < length) {
	        var key = _toKey_js_1.default(path[index]);
	        if (!(result = object != null && hasFunc(object, key))) {
	            break;
	        }
	        object = object[key];
	    }
	    if (result || ++index != length) {
	        return result;
	    }
	    length = object == null ? 0 : object.length;
	    return !!length && isLength_js_1.default(length) && _isIndex_js_1.default(key, length) &&
	        (isArray_js_1.default(object) || isArguments_js_1.default(object));
	}
	exports.default = hasPath;
	});

	var hasIn_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseHasIn_js_1 = _baseHasIn;
	var _hasPath_js_1 = _hasPath;
	function hasIn(object, path) {
	    return object != null && _hasPath_js_1.default(object, path, _baseHasIn_js_1.default);
	}
	exports.default = hasIn;
	});

	var _baseMatchesProperty = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseIsEqual_js_1 = _baseIsEqual;
	var get_js_1 = get_1;
	var hasIn_js_1 = hasIn_1;
	var _isKey_js_1 = _isKey;
	var _isStrictComparable_js_1 = _isStrictComparable;
	var _matchesStrictComparable_js_1 = _matchesStrictComparable;
	var _toKey_js_1 = _toKey;
	var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
	function baseMatchesProperty(path, srcValue) {
	    if (_isKey_js_1.default(path) && _isStrictComparable_js_1.default(srcValue)) {
	        return _matchesStrictComparable_js_1.default(_toKey_js_1.default(path), srcValue);
	    }
	    return function (object) {
	        var objValue = get_js_1.default(object, path);
	        return (objValue === undefined && objValue === srcValue)
	            ? hasIn_js_1.default(object, path)
	            : _baseIsEqual_js_1.default(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
	    };
	}
	exports.default = baseMatchesProperty;
	});

	var _baseProperty = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	function baseProperty(key) {
	    return function (object) {
	        return object == null ? undefined : object[key];
	    };
	}
	exports.default = baseProperty;
	});

	var _basePropertyDeep = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseGet_js_1 = _baseGet;
	function basePropertyDeep(path) {
	    return function (object) {
	        return _baseGet_js_1.default(object, path);
	    };
	}
	exports.default = basePropertyDeep;
	});

	var property_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseProperty_js_1 = _baseProperty;
	var _basePropertyDeep_js_1 = _basePropertyDeep;
	var _isKey_js_1 = _isKey;
	var _toKey_js_1 = _toKey;
	function property(path) {
	    return _isKey_js_1.default(path) ? _baseProperty_js_1.default(_toKey_js_1.default(path)) : _basePropertyDeep_js_1.default(path);
	}
	exports.default = property;
	});

	var _baseIteratee = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseMatches_js_1 = _baseMatches;
	var _baseMatchesProperty_js_1 = _baseMatchesProperty;
	var identity_js_1 = identity_1;
	var isArray_js_1 = isArray_1;
	var property_js_1 = property_1;
	function baseIteratee(value) {
	    if (typeof value == 'function') {
	        return value;
	    }
	    if (value == null) {
	        return identity_js_1.default;
	    }
	    if (typeof value == 'object') {
	        return isArray_js_1.default(value)
	            ? _baseMatchesProperty_js_1.default(value[0], value[1])
	            : _baseMatches_js_1.default(value);
	    }
	    return property_js_1.default(value);
	}
	exports.default = baseIteratee;
	});

	var cond_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _apply_js_1 = _apply;
	var _arrayMap_js_1 = _arrayMap;
	var _baseIteratee_js_1 = _baseIteratee;
	var _baseRest_js_1 = _baseRest;
	var FUNC_ERROR_TEXT = 'Expected a function';
	function cond(pairs) {
	    var length = pairs == null ? 0 : pairs.length, toIteratee = _baseIteratee_js_1.default;
	    pairs = !length ? [] : _arrayMap_js_1.default(pairs, function (pair) {
	        if (typeof pair[1] != 'function') {
	            throw new TypeError(FUNC_ERROR_TEXT);
	        }
	        return [toIteratee(pair[0]), pair[1]];
	    });
	    return _baseRest_js_1.default(function (args) {
	        var index = -1;
	        while (++index < length) {
	            var pair = pairs[index];
	            if (_apply_js_1.default(pair[0], this, args)) {
	                return _apply_js_1.default(pair[1], this, args);
	            }
	        }
	    });
	}
	exports.default = cond;
	});

	var _baseConformsTo = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	function baseConformsTo(object, source, props) {
	    var length = props.length;
	    if (object == null) {
	        return !length;
	    }
	    object = Object(object);
	    while (length--) {
	        var key = props[length], predicate = source[key], value = object[key];
	        if ((value === undefined && !(key in object)) || !predicate(value)) {
	            return false;
	        }
	    }
	    return true;
	}
	exports.default = baseConformsTo;
	});

	var _baseConforms = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseConformsTo_js_1 = _baseConformsTo;
	var keys_js_1 = keys_1;
	function baseConforms(source) {
	    var props = keys_js_1.default(source);
	    return function (object) {
	        return _baseConformsTo_js_1.default(object, source, props);
	    };
	}
	exports.default = baseConforms;
	});

	var conforms_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseClone_js_1 = _baseClone;
	var _baseConforms_js_1 = _baseConforms;
	var CLONE_DEEP_FLAG = 1;
	function conforms(source) {
	    return _baseConforms_js_1.default(_baseClone_js_1.default(source, CLONE_DEEP_FLAG));
	}
	exports.default = conforms;
	});

	var conformsTo_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseConformsTo_js_1 = _baseConformsTo;
	var keys_js_1 = keys_1;
	function conformsTo(object, source) {
	    return source == null || _baseConformsTo_js_1.default(object, source, keys_js_1.default(source));
	}
	exports.default = conformsTo;
	});

	var _arrayAggregator = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	function arrayAggregator(array, setter, iteratee, accumulator) {
	    var index = -1, length = array == null ? 0 : array.length;
	    while (++index < length) {
	        var value = array[index];
	        setter(accumulator, value, iteratee(value), array);
	    }
	    return accumulator;
	}
	exports.default = arrayAggregator;
	});

	var _createBaseFor = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	function createBaseFor(fromRight) {
	    return function (object, iteratee, keysFunc) {
	        var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
	        while (length--) {
	            var key = props[fromRight ? length : ++index];
	            if (iteratee(iterable[key], key, iterable) === false) {
	                break;
	            }
	        }
	        return object;
	    };
	}
	exports.default = createBaseFor;
	});

	var _baseFor = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _createBaseFor_js_1 = _createBaseFor;
	var baseFor = _createBaseFor_js_1.default();
	exports.default = baseFor;
	});

	var _baseForOwn = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseFor_js_1 = _baseFor;
	var keys_js_1 = keys_1;
	function baseForOwn(object, iteratee) {
	    return object && _baseFor_js_1.default(object, iteratee, keys_js_1.default);
	}
	exports.default = baseForOwn;
	});

	var _createBaseEach = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var isArrayLike_js_1 = isArrayLike_1;
	function createBaseEach(eachFunc, fromRight) {
	    return function (collection, iteratee) {
	        if (collection == null) {
	            return collection;
	        }
	        if (!isArrayLike_js_1.default(collection)) {
	            return eachFunc(collection, iteratee);
	        }
	        var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection);
	        while ((fromRight ? index-- : ++index < length)) {
	            if (iteratee(iterable[index], index, iterable) === false) {
	                break;
	            }
	        }
	        return collection;
	    };
	}
	exports.default = createBaseEach;
	});

	var _baseEach = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseForOwn_js_1 = _baseForOwn;
	var _createBaseEach_js_1 = _createBaseEach;
	var baseEach = _createBaseEach_js_1.default(_baseForOwn_js_1.default);
	exports.default = baseEach;
	});

	var _baseAggregator = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseEach_js_1 = _baseEach;
	function baseAggregator(collection, setter, iteratee, accumulator) {
	    _baseEach_js_1.default(collection, function (value, key, collection) {
	        setter(accumulator, value, iteratee(value), collection);
	    });
	    return accumulator;
	}
	exports.default = baseAggregator;
	});

	var _createAggregator = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _arrayAggregator_js_1 = _arrayAggregator;
	var _baseAggregator_js_1 = _baseAggregator;
	var _baseIteratee_js_1 = _baseIteratee;
	var isArray_js_1 = isArray_1;
	function createAggregator(setter, initializer) {
	    return function (collection, iteratee) {
	        var func = isArray_js_1.default(collection) ? _arrayAggregator_js_1.default : _baseAggregator_js_1.default, accumulator = initializer ? initializer() : {};
	        return func(collection, setter, _baseIteratee_js_1.default(iteratee, 2), accumulator);
	    };
	}
	exports.default = createAggregator;
	});

	var countBy_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseAssignValue_js_1 = _baseAssignValue;
	var _createAggregator_js_1 = _createAggregator;
	var objectProto = Object.prototype;
	var hasOwnProperty = objectProto.hasOwnProperty;
	var countBy = _createAggregator_js_1.default(function (result, value, key) {
	    if (hasOwnProperty.call(result, key)) {
	        ++result[key];
	    }
	    else {
	        _baseAssignValue_js_1.default(result, key, 1);
	    }
	});
	exports.default = countBy;
	});

	var create_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseAssign_js_1 = _baseAssign;
	var _baseCreate_js_1 = _baseCreate;
	function create(prototype, properties) {
	    var result = _baseCreate_js_1.default(prototype);
	    return properties == null ? result : _baseAssign_js_1.default(result, properties);
	}
	exports.default = create;
	});

	var curry_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _createWrap_js_1 = _createWrap;
	var WRAP_CURRY_FLAG = 8;
	function curry(func, arity, guard) {
	    arity = guard ? undefined : arity;
	    var result = _createWrap_js_1.default(func, WRAP_CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
	    result.placeholder = curry.placeholder;
	    return result;
	}
	curry.placeholder = {};
	exports.default = curry;
	});

	var curry = unwrapExports(curry_1);

	var curryRight_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _createWrap_js_1 = _createWrap;
	var WRAP_CURRY_RIGHT_FLAG = 16;
	function curryRight(func, arity, guard) {
	    arity = guard ? undefined : arity;
	    var result = _createWrap_js_1.default(func, WRAP_CURRY_RIGHT_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
	    result.placeholder = curryRight.placeholder;
	    return result;
	}
	curryRight.placeholder = {};
	exports.default = curryRight;
	});

	var now_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _root_js_1 = _root;
	var now = function () {
	    return _root_js_1.default.Date.now();
	};
	exports.default = now;
	});

	var debounce_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var isObject_js_1 = isObject_1;
	var now_js_1 = now_1;
	var toNumber_js_1 = toNumber_1;
	var FUNC_ERROR_TEXT = 'Expected a function';
	var nativeMax = Math.max, nativeMin = Math.min;
	function debounce(func, wait, options) {
	    var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
	    if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	    }
	    wait = toNumber_js_1.default(wait) || 0;
	    if (isObject_js_1.default(options)) {
	        leading = !!options.leading;
	        maxing = 'maxWait' in options;
	        maxWait = maxing ? nativeMax(toNumber_js_1.default(options.maxWait) || 0, wait) : maxWait;
	        trailing = 'trailing' in options ? !!options.trailing : trailing;
	    }
	    function invokeFunc(time) {
	        var args = lastArgs, thisArg = lastThis;
	        lastArgs = lastThis = undefined;
	        lastInvokeTime = time;
	        result = func.apply(thisArg, args);
	        return result;
	    }
	    function leadingEdge(time) {
	        lastInvokeTime = time;
	        timerId = setTimeout(timerExpired, wait);
	        return leading ? invokeFunc(time) : result;
	    }
	    function remainingWait(time) {
	        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, result = wait - timeSinceLastCall;
	        return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
	    }
	    function shouldInvoke(time) {
	        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
	        return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
	            (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
	    }
	    function timerExpired() {
	        var time = now_js_1.default();
	        if (shouldInvoke(time)) {
	            return trailingEdge(time);
	        }
	        timerId = setTimeout(timerExpired, remainingWait(time));
	    }
	    function trailingEdge(time) {
	        timerId = undefined;
	        if (trailing && lastArgs) {
	            return invokeFunc(time);
	        }
	        lastArgs = lastThis = undefined;
	        return result;
	    }
	    function cancel() {
	        if (timerId !== undefined) {
	            clearTimeout(timerId);
	        }
	        lastInvokeTime = 0;
	        lastArgs = lastCallTime = lastThis = timerId = undefined;
	    }
	    function flush() {
	        return timerId === undefined ? result : trailingEdge(now_js_1.default());
	    }
	    function debounced() {
	        var time = now_js_1.default(), isInvoking = shouldInvoke(time);
	        lastArgs = arguments;
	        lastThis = this;
	        lastCallTime = time;
	        if (isInvoking) {
	            if (timerId === undefined) {
	                return leadingEdge(lastCallTime);
	            }
	            if (maxing) {
	                timerId = setTimeout(timerExpired, wait);
	                return invokeFunc(lastCallTime);
	            }
	        }
	        if (timerId === undefined) {
	            timerId = setTimeout(timerExpired, wait);
	        }
	        return result;
	    }
	    debounced.cancel = cancel;
	    debounced.flush = flush;
	    return debounced;
	}
	exports.default = debounce;
	});

	var defaultTo_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	function defaultTo(value, defaultValue) {
	    return (value == null || value !== value) ? defaultValue : value;
	}
	exports.default = defaultTo;
	});

	var _customDefaultsAssignIn = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var eq_js_1 = eq_1;
	var objectProto = Object.prototype;
	var hasOwnProperty = objectProto.hasOwnProperty;
	function customDefaultsAssignIn(objValue, srcValue, key, object) {
	    if (objValue === undefined ||
	        (eq_js_1.default(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {
	        return srcValue;
	    }
	    return objValue;
	}
	exports.default = customDefaultsAssignIn;
	});

	var defaults_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _apply_js_1 = _apply;
	var assignInWith_js_1 = assignInWith_1;
	var _baseRest_js_1 = _baseRest;
	var _customDefaultsAssignIn_js_1 = _customDefaultsAssignIn;
	var defaults = _baseRest_js_1.default(function (args) {
	    args.push(undefined, _customDefaultsAssignIn_js_1.default);
	    return _apply_js_1.default(assignInWith_js_1.default, undefined, args);
	});
	exports.default = defaults;
	});

	var _assignMergeValue = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseAssignValue_js_1 = _baseAssignValue;
	var eq_js_1 = eq_1;
	function assignMergeValue(object, key, value) {
	    if ((value !== undefined && !eq_js_1.default(object[key], value)) ||
	        (value === undefined && !(key in object))) {
	        _baseAssignValue_js_1.default(object, key, value);
	    }
	}
	exports.default = assignMergeValue;
	});

	var isArrayLikeObject_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var isArrayLike_js_1 = isArrayLike_1;
	var isObjectLike_js_1 = isObjectLike_1;
	function isArrayLikeObject(value) {
	    return isObjectLike_js_1.default(value) && isArrayLike_js_1.default(value);
	}
	exports.default = isArrayLikeObject;
	});

	var toPlainObject_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _copyObject_js_1 = _copyObject;
	var keysIn_js_1 = keysIn_1;
	function toPlainObject(value) {
	    return _copyObject_js_1.default(value, keysIn_js_1.default(value));
	}
	exports.default = toPlainObject;
	});

	var _baseMergeDeep = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _assignMergeValue_js_1 = _assignMergeValue;
	var _cloneBuffer_js_1 = _cloneBuffer;
	var _cloneTypedArray_js_1 = _cloneTypedArray;
	var _copyArray_js_1 = _copyArray;
	var _initCloneObject_js_1 = _initCloneObject;
	var isArguments_js_1 = isArguments_1;
	var isArray_js_1 = isArray_1;
	var isArrayLikeObject_js_1 = isArrayLikeObject_1;
	var isBuffer_js_1 = isBuffer_1;
	var isFunction_js_1 = isFunction_1;
	var isObject_js_1 = isObject_1;
	var isPlainObject_js_1 = isPlainObject_1;
	var isTypedArray_js_1 = isTypedArray_1;
	var toPlainObject_js_1 = toPlainObject_1;
	function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
	    var objValue = object[key], srcValue = source[key], stacked = stack.get(srcValue);
	    if (stacked) {
	        _assignMergeValue_js_1.default(object, key, stacked);
	        return;
	    }
	    var newValue = customizer
	        ? customizer(objValue, srcValue, (key + ''), object, source, stack)
	        : undefined;
	    var isCommon = newValue === undefined;
	    if (isCommon) {
	        var isArr = isArray_js_1.default(srcValue), isBuff = !isArr && isBuffer_js_1.default(srcValue), isTyped = !isArr && !isBuff && isTypedArray_js_1.default(srcValue);
	        newValue = srcValue;
	        if (isArr || isBuff || isTyped) {
	            if (isArray_js_1.default(objValue)) {
	                newValue = objValue;
	            }
	            else if (isArrayLikeObject_js_1.default(objValue)) {
	                newValue = _copyArray_js_1.default(objValue);
	            }
	            else if (isBuff) {
	                isCommon = false;
	                newValue = _cloneBuffer_js_1.default(srcValue, true);
	            }
	            else if (isTyped) {
	                isCommon = false;
	                newValue = _cloneTypedArray_js_1.default(srcValue, true);
	            }
	            else {
	                newValue = [];
	            }
	        }
	        else if (isPlainObject_js_1.default(srcValue) || isArguments_js_1.default(srcValue)) {
	            newValue = objValue;
	            if (isArguments_js_1.default(objValue)) {
	                newValue = toPlainObject_js_1.default(objValue);
	            }
	            else if (!isObject_js_1.default(objValue) || (srcIndex && isFunction_js_1.default(objValue))) {
	                newValue = _initCloneObject_js_1.default(srcValue);
	            }
	        }
	        else {
	            isCommon = false;
	        }
	    }
	    if (isCommon) {
	        stack.set(srcValue, newValue);
	        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
	        stack['delete'](srcValue);
	    }
	    _assignMergeValue_js_1.default(object, key, newValue);
	}
	exports.default = baseMergeDeep;
	});

	var _baseMerge = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _Stack_js_1 = _Stack;
	var _assignMergeValue_js_1 = _assignMergeValue;
	var _baseFor_js_1 = _baseFor;
	var _baseMergeDeep_js_1 = _baseMergeDeep;
	var isObject_js_1 = isObject_1;
	var keysIn_js_1 = keysIn_1;
	function baseMerge(object, source, srcIndex, customizer, stack) {
	    if (object === source) {
	        return;
	    }
	    _baseFor_js_1.default(source, function (srcValue, key) {
	        if (isObject_js_1.default(srcValue)) {
	            stack || (stack = new _Stack_js_1.default);
	            _baseMergeDeep_js_1.default(object, source, key, srcIndex, baseMerge, customizer, stack);
	        }
	        else {
	            var newValue = customizer
	                ? customizer(object[key], srcValue, (key + ''), object, source, stack)
	                : undefined;
	            if (newValue === undefined) {
	                newValue = srcValue;
	            }
	            _assignMergeValue_js_1.default(object, key, newValue);
	        }
	    }, keysIn_js_1.default);
	}
	exports.default = baseMerge;
	});

	var _customDefaultsMerge = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseMerge_js_1 = _baseMerge;
	var isObject_js_1 = isObject_1;
	function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
	    if (isObject_js_1.default(objValue) && isObject_js_1.default(srcValue)) {
	        stack.set(srcValue, objValue);
	        _baseMerge_js_1.default(objValue, srcValue, undefined, customDefaultsMerge, stack);
	        stack['delete'](srcValue);
	    }
	    return objValue;
	}
	exports.default = customDefaultsMerge;
	});

	var mergeWith_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseMerge_js_1 = _baseMerge;
	var _createAssigner_js_1 = _createAssigner;
	var mergeWith = _createAssigner_js_1.default(function (object, source, srcIndex, customizer) {
	    _baseMerge_js_1.default(object, source, srcIndex, customizer);
	});
	exports.default = mergeWith;
	});

	var defaultsDeep_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _apply_js_1 = _apply;
	var _baseRest_js_1 = _baseRest;
	var _customDefaultsMerge_js_1 = _customDefaultsMerge;
	var mergeWith_js_1 = mergeWith_1;
	var defaultsDeep = _baseRest_js_1.default(function (args) {
	    args.push(undefined, _customDefaultsMerge_js_1.default);
	    return _apply_js_1.default(mergeWith_js_1.default, undefined, args);
	});
	exports.default = defaultsDeep;
	});

	var _baseDelay = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var FUNC_ERROR_TEXT = 'Expected a function';
	function baseDelay(func, wait, args) {
	    if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	    }
	    return setTimeout(function () { func.apply(undefined, args); }, wait);
	}
	exports.default = baseDelay;
	});

	var defer_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseDelay_js_1 = _baseDelay;
	var _baseRest_js_1 = _baseRest;
	var defer = _baseRest_js_1.default(function (func, args) {
	    return _baseDelay_js_1.default(func, 1, args);
	});
	exports.default = defer;
	});

	var delay_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseDelay_js_1 = _baseDelay;
	var _baseRest_js_1 = _baseRest;
	var toNumber_js_1 = toNumber_1;
	var delay = _baseRest_js_1.default(function (func, wait, args) {
	    return _baseDelay_js_1.default(func, toNumber_js_1.default(wait) || 0, args);
	});
	exports.default = delay;
	});

	var _arrayIncludesWith = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	function arrayIncludesWith(array, value, comparator) {
	    var index = -1, length = array == null ? 0 : array.length;
	    while (++index < length) {
	        if (comparator(value, array[index])) {
	            return true;
	        }
	    }
	    return false;
	}
	exports.default = arrayIncludesWith;
	});

	var _baseDifference = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _SetCache_js_1 = _SetCache;
	var _arrayIncludes_js_1 = _arrayIncludes;
	var _arrayIncludesWith_js_1 = _arrayIncludesWith;
	var _arrayMap_js_1 = _arrayMap;
	var _baseUnary_js_1 = _baseUnary;
	var _cacheHas_js_1 = _cacheHas;
	var LARGE_ARRAY_SIZE = 200;
	function baseDifference(array, values, iteratee, comparator) {
	    var index = -1, includes = _arrayIncludes_js_1.default, isCommon = true, length = array.length, result = [], valuesLength = values.length;
	    if (!length) {
	        return result;
	    }
	    if (iteratee) {
	        values = _arrayMap_js_1.default(values, _baseUnary_js_1.default(iteratee));
	    }
	    if (comparator) {
	        includes = _arrayIncludesWith_js_1.default;
	        isCommon = false;
	    }
	    else if (values.length >= LARGE_ARRAY_SIZE) {
	        includes = _cacheHas_js_1.default;
	        isCommon = false;
	        values = new _SetCache_js_1.default(values);
	    }
	    outer: while (++index < length) {
	        var value = array[index], computed = iteratee == null ? value : iteratee(value);
	        value = (comparator || value !== 0) ? value : 0;
	        if (isCommon && computed === computed) {
	            var valuesIndex = valuesLength;
	            while (valuesIndex--) {
	                if (values[valuesIndex] === computed) {
	                    continue outer;
	                }
	            }
	            result.push(value);
	        }
	        else if (!includes(values, computed, comparator)) {
	            result.push(value);
	        }
	    }
	    return result;
	}
	exports.default = baseDifference;
	});

	var difference_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseDifference_js_1 = _baseDifference;
	var _baseFlatten_js_1 = _baseFlatten;
	var _baseRest_js_1 = _baseRest;
	var isArrayLikeObject_js_1 = isArrayLikeObject_1;
	var difference = _baseRest_js_1.default(function (array, values) {
	    return isArrayLikeObject_js_1.default(array)
	        ? _baseDifference_js_1.default(array, _baseFlatten_js_1.default(values, 1, isArrayLikeObject_js_1.default, true))
	        : [];
	});
	exports.default = difference;
	});

	var last_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	function last(array) {
	    var length = array == null ? 0 : array.length;
	    return length ? array[length - 1] : undefined;
	}
	exports.default = last;
	});

	var differenceBy_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseDifference_js_1 = _baseDifference;
	var _baseFlatten_js_1 = _baseFlatten;
	var _baseIteratee_js_1 = _baseIteratee;
	var _baseRest_js_1 = _baseRest;
	var isArrayLikeObject_js_1 = isArrayLikeObject_1;
	var last_js_1 = last_1;
	var differenceBy = _baseRest_js_1.default(function (array, values) {
	    var iteratee = last_js_1.default(values);
	    if (isArrayLikeObject_js_1.default(iteratee)) {
	        iteratee = undefined;
	    }
	    return isArrayLikeObject_js_1.default(array)
	        ? _baseDifference_js_1.default(array, _baseFlatten_js_1.default(values, 1, isArrayLikeObject_js_1.default, true), _baseIteratee_js_1.default(iteratee, 2))
	        : [];
	});
	exports.default = differenceBy;
	});

	var differenceWith_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseDifference_js_1 = _baseDifference;
	var _baseFlatten_js_1 = _baseFlatten;
	var _baseRest_js_1 = _baseRest;
	var isArrayLikeObject_js_1 = isArrayLikeObject_1;
	var last_js_1 = last_1;
	var differenceWith = _baseRest_js_1.default(function (array, values) {
	    var comparator = last_js_1.default(values);
	    if (isArrayLikeObject_js_1.default(comparator)) {
	        comparator = undefined;
	    }
	    return isArrayLikeObject_js_1.default(array)
	        ? _baseDifference_js_1.default(array, _baseFlatten_js_1.default(values, 1, isArrayLikeObject_js_1.default, true), undefined, comparator)
	        : [];
	});
	exports.default = differenceWith;
	});

	var divide_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _createMathOperation_js_1 = _createMathOperation;
	var divide = _createMathOperation_js_1.default(function (dividend, divisor) {
	    return dividend / divisor;
	}, 1);
	exports.default = divide;
	});

	var drop_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseSlice_js_1 = _baseSlice;
	var toInteger_js_1 = toInteger_1;
	function drop(array, n, guard) {
	    var length = array == null ? 0 : array.length;
	    if (!length) {
	        return [];
	    }
	    n = (guard || n === undefined) ? 1 : toInteger_js_1.default(n);
	    return _baseSlice_js_1.default(array, n < 0 ? 0 : n, length);
	}
	exports.default = drop;
	});

	var dropRight_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseSlice_js_1 = _baseSlice;
	var toInteger_js_1 = toInteger_1;
	function dropRight(array, n, guard) {
	    var length = array == null ? 0 : array.length;
	    if (!length) {
	        return [];
	    }
	    n = (guard || n === undefined) ? 1 : toInteger_js_1.default(n);
	    n = length - n;
	    return _baseSlice_js_1.default(array, 0, n < 0 ? 0 : n);
	}
	exports.default = dropRight;
	});

	var _baseWhile = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseSlice_js_1 = _baseSlice;
	function baseWhile(array, predicate, isDrop, fromRight) {
	    var length = array.length, index = fromRight ? length : -1;
	    while ((fromRight ? index-- : ++index < length) &&
	        predicate(array[index], index, array)) { }
	    return isDrop
	        ? _baseSlice_js_1.default(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))
	        : _baseSlice_js_1.default(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));
	}
	exports.default = baseWhile;
	});

	var dropRightWhile_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseIteratee_js_1 = _baseIteratee;
	var _baseWhile_js_1 = _baseWhile;
	function dropRightWhile(array, predicate) {
	    return (array && array.length)
	        ? _baseWhile_js_1.default(array, _baseIteratee_js_1.default(predicate, 3), true, true)
	        : [];
	}
	exports.default = dropRightWhile;
	});

	var dropWhile_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseIteratee_js_1 = _baseIteratee;
	var _baseWhile_js_1 = _baseWhile;
	function dropWhile(array, predicate) {
	    return (array && array.length)
	        ? _baseWhile_js_1.default(array, _baseIteratee_js_1.default(predicate, 3), true)
	        : [];
	}
	exports.default = dropWhile;
	});

	var _castFunction = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var identity_js_1 = identity_1;
	function castFunction(value) {
	    return typeof value == 'function' ? value : identity_js_1.default;
	}
	exports.default = castFunction;
	});

	var forEach_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _arrayEach_js_1 = _arrayEach;
	var _baseEach_js_1 = _baseEach;
	var _castFunction_js_1 = _castFunction;
	var isArray_js_1 = isArray_1;
	function forEach(collection, iteratee) {
	    var func = isArray_js_1.default(collection) ? _arrayEach_js_1.default : _baseEach_js_1.default;
	    return func(collection, _castFunction_js_1.default(iteratee));
	}
	exports.default = forEach;
	});

	var each = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var forEach_js_1 = forEach_1;
	exports.default = forEach_js_1.default;
	});

	var _arrayEachRight = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	function arrayEachRight(array, iteratee) {
	    var length = array == null ? 0 : array.length;
	    while (length--) {
	        if (iteratee(array[length], length, array) === false) {
	            break;
	        }
	    }
	    return array;
	}
	exports.default = arrayEachRight;
	});

	var _baseForRight = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _createBaseFor_js_1 = _createBaseFor;
	var baseForRight = _createBaseFor_js_1.default(true);
	exports.default = baseForRight;
	});

	var _baseForOwnRight = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseForRight_js_1 = _baseForRight;
	var keys_js_1 = keys_1;
	function baseForOwnRight(object, iteratee) {
	    return object && _baseForRight_js_1.default(object, iteratee, keys_js_1.default);
	}
	exports.default = baseForOwnRight;
	});

	var _baseEachRight = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseForOwnRight_js_1 = _baseForOwnRight;
	var _createBaseEach_js_1 = _createBaseEach;
	var baseEachRight = _createBaseEach_js_1.default(_baseForOwnRight_js_1.default, true);
	exports.default = baseEachRight;
	});

	var forEachRight_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _arrayEachRight_js_1 = _arrayEachRight;
	var _baseEachRight_js_1 = _baseEachRight;
	var _castFunction_js_1 = _castFunction;
	var isArray_js_1 = isArray_1;
	function forEachRight(collection, iteratee) {
	    var func = isArray_js_1.default(collection) ? _arrayEachRight_js_1.default : _baseEachRight_js_1.default;
	    return func(collection, _castFunction_js_1.default(iteratee));
	}
	exports.default = forEachRight;
	});

	var eachRight = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var forEachRight_js_1 = forEachRight_1;
	exports.default = forEachRight_js_1.default;
	});

	var endsWith_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseClamp_js_1 = _baseClamp;
	var _baseToString_js_1 = _baseToString;
	var toInteger_js_1 = toInteger_1;
	var toString_js_1 = toString_1;
	function endsWith(string, target, position) {
	    string = toString_js_1.default(string);
	    target = _baseToString_js_1.default(target);
	    var length = string.length;
	    position = position === undefined
	        ? length
	        : _baseClamp_js_1.default(toInteger_js_1.default(position), 0, length);
	    var end = position;
	    position -= target.length;
	    return position >= 0 && string.slice(position, end) == target;
	}
	exports.default = endsWith;
	});

	var _baseToPairs = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _arrayMap_js_1 = _arrayMap;
	function baseToPairs(object, props) {
	    return _arrayMap_js_1.default(props, function (key) {
	        return [key, object[key]];
	    });
	}
	exports.default = baseToPairs;
	});

	var _setToPairs = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	function setToPairs(set) {
	    var index = -1, result = Array(set.size);
	    set.forEach(function (value) {
	        result[++index] = [value, value];
	    });
	    return result;
	}
	exports.default = setToPairs;
	});

	var _createToPairs = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseToPairs_js_1 = _baseToPairs;
	var _getTag_js_1 = _getTag;
	var _mapToArray_js_1 = _mapToArray;
	var _setToPairs_js_1 = _setToPairs;
	var mapTag = '[object Map]', setTag = '[object Set]';
	function createToPairs(keysFunc) {
	    return function (object) {
	        var tag = _getTag_js_1.default(object);
	        if (tag == mapTag) {
	            return _mapToArray_js_1.default(object);
	        }
	        if (tag == setTag) {
	            return _setToPairs_js_1.default(object);
	        }
	        return _baseToPairs_js_1.default(object, keysFunc(object));
	    };
	}
	exports.default = createToPairs;
	});

	var toPairs_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _createToPairs_js_1 = _createToPairs;
	var keys_js_1 = keys_1;
	var toPairs = _createToPairs_js_1.default(keys_js_1.default);
	exports.default = toPairs;
	});

	var entries = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var toPairs_js_1 = toPairs_1;
	exports.default = toPairs_js_1.default;
	});

	var toPairsIn_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _createToPairs_js_1 = _createToPairs;
	var keysIn_js_1 = keysIn_1;
	var toPairsIn = _createToPairs_js_1.default(keysIn_js_1.default);
	exports.default = toPairsIn;
	});

	var entriesIn = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var toPairsIn_js_1 = toPairsIn_1;
	exports.default = toPairsIn_js_1.default;
	});

	var _escapeHtmlChar = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _basePropertyOf_js_1 = _basePropertyOf;
	var htmlEscapes = {
	    '&': '&amp;',
	    '<': '&lt;',
	    '>': '&gt;',
	    '"': '&quot;',
	    "'": '&#39;'
	};
	var escapeHtmlChar = _basePropertyOf_js_1.default(htmlEscapes);
	exports.default = escapeHtmlChar;
	});

	var _escape = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _escapeHtmlChar_js_1 = _escapeHtmlChar;
	var toString_js_1 = toString_1;
	var reUnescapedHtml = /[&<>"']/g, reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
	function escape(string) {
	    string = toString_js_1.default(string);
	    return (string && reHasUnescapedHtml.test(string))
	        ? string.replace(reUnescapedHtml, _escapeHtmlChar_js_1.default)
	        : string;
	}
	exports.default = escape;
	});

	var escapeRegExp_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var toString_js_1 = toString_1;
	var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
	function escapeRegExp(string) {
	    string = toString_js_1.default(string);
	    return (string && reHasRegExpChar.test(string))
	        ? string.replace(reRegExpChar, '\\$&')
	        : string;
	}
	exports.default = escapeRegExp;
	});

	var _arrayEvery = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	function arrayEvery(array, predicate) {
	    var index = -1, length = array == null ? 0 : array.length;
	    while (++index < length) {
	        if (!predicate(array[index], index, array)) {
	            return false;
	        }
	    }
	    return true;
	}
	exports.default = arrayEvery;
	});

	var _baseEvery = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseEach_js_1 = _baseEach;
	function baseEvery(collection, predicate) {
	    var result = true;
	    _baseEach_js_1.default(collection, function (value, index, collection) {
	        result = !!predicate(value, index, collection);
	        return result;
	    });
	    return result;
	}
	exports.default = baseEvery;
	});

	var every_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _arrayEvery_js_1 = _arrayEvery;
	var _baseEvery_js_1 = _baseEvery;
	var _baseIteratee_js_1 = _baseIteratee;
	var isArray_js_1 = isArray_1;
	var _isIterateeCall_js_1 = _isIterateeCall;
	function every(collection, predicate, guard) {
	    var func = isArray_js_1.default(collection) ? _arrayEvery_js_1.default : _baseEvery_js_1.default;
	    if (guard && _isIterateeCall_js_1.default(collection, predicate, guard)) {
	        predicate = undefined;
	    }
	    return func(collection, _baseIteratee_js_1.default(predicate, 3));
	}
	exports.default = every;
	});

	var extend = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var assignIn_js_1 = assignIn_1;
	exports.default = assignIn_js_1.default;
	});

	var extendWith = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var assignInWith_js_1 = assignInWith_1;
	exports.default = assignInWith_js_1.default;
	});

	var toLength_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseClamp_js_1 = _baseClamp;
	var toInteger_js_1 = toInteger_1;
	var MAX_ARRAY_LENGTH = 4294967295;
	function toLength(value) {
	    return value ? _baseClamp_js_1.default(toInteger_js_1.default(value), 0, MAX_ARRAY_LENGTH) : 0;
	}
	exports.default = toLength;
	});

	var _baseFill = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var toInteger_js_1 = toInteger_1;
	var toLength_js_1 = toLength_1;
	function baseFill(array, value, start, end) {
	    var length = array.length;
	    start = toInteger_js_1.default(start);
	    if (start < 0) {
	        start = -start > length ? 0 : (length + start);
	    }
	    end = (end === undefined || end > length) ? length : toInteger_js_1.default(end);
	    if (end < 0) {
	        end += length;
	    }
	    end = start > end ? 0 : toLength_js_1.default(end);
	    while (start < end) {
	        array[start++] = value;
	    }
	    return array;
	}
	exports.default = baseFill;
	});

	var fill_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseFill_js_1 = _baseFill;
	var _isIterateeCall_js_1 = _isIterateeCall;
	function fill(array, value, start, end) {
	    var length = array == null ? 0 : array.length;
	    if (!length) {
	        return [];
	    }
	    if (start && typeof start != 'number' && _isIterateeCall_js_1.default(array, value, start)) {
	        start = 0;
	        end = length;
	    }
	    return _baseFill_js_1.default(array, value, start, end);
	}
	exports.default = fill;
	});

	var _baseFilter = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseEach_js_1 = _baseEach;
	function baseFilter(collection, predicate) {
	    var result = [];
	    _baseEach_js_1.default(collection, function (value, index, collection) {
	        if (predicate(value, index, collection)) {
	            result.push(value);
	        }
	    });
	    return result;
	}
	exports.default = baseFilter;
	});

	var filter_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _arrayFilter_js_1 = _arrayFilter;
	var _baseFilter_js_1 = _baseFilter;
	var _baseIteratee_js_1 = _baseIteratee;
	var isArray_js_1 = isArray_1;
	function filter(collection, predicate) {
	    var func = isArray_js_1.default(collection) ? _arrayFilter_js_1.default : _baseFilter_js_1.default;
	    return func(collection, _baseIteratee_js_1.default(predicate, 3));
	}
	exports.default = filter;
	});

	var _createFind = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseIteratee_js_1 = _baseIteratee;
	var isArrayLike_js_1 = isArrayLike_1;
	var keys_js_1 = keys_1;
	function createFind(findIndexFunc) {
	    return function (collection, predicate, fromIndex) {
	        var iterable = Object(collection);
	        if (!isArrayLike_js_1.default(collection)) {
	            var iteratee = _baseIteratee_js_1.default(predicate, 3);
	            collection = keys_js_1.default(collection);
	            predicate = function (key) { return iteratee(iterable[key], key, iterable); };
	        }
	        var index = findIndexFunc(collection, predicate, fromIndex);
	        return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;
	    };
	}
	exports.default = createFind;
	});

	var findIndex_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseFindIndex_js_1 = _baseFindIndex;
	var _baseIteratee_js_1 = _baseIteratee;
	var toInteger_js_1 = toInteger_1;
	var nativeMax = Math.max;
	function findIndex(array, predicate, fromIndex) {
	    var length = array == null ? 0 : array.length;
	    if (!length) {
	        return -1;
	    }
	    var index = fromIndex == null ? 0 : toInteger_js_1.default(fromIndex);
	    if (index < 0) {
	        index = nativeMax(length + index, 0);
	    }
	    return _baseFindIndex_js_1.default(array, _baseIteratee_js_1.default(predicate, 3), index);
	}
	exports.default = findIndex;
	});

	var find_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _createFind_js_1 = _createFind;
	var findIndex_js_1 = findIndex_1;
	var find = _createFind_js_1.default(findIndex_js_1.default);
	exports.default = find;
	});

	var _baseFindKey = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	function baseFindKey(collection, predicate, eachFunc) {
	    var result;
	    eachFunc(collection, function (value, key, collection) {
	        if (predicate(value, key, collection)) {
	            result = key;
	            return false;
	        }
	    });
	    return result;
	}
	exports.default = baseFindKey;
	});

	var findKey_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseFindKey_js_1 = _baseFindKey;
	var _baseForOwn_js_1 = _baseForOwn;
	var _baseIteratee_js_1 = _baseIteratee;
	function findKey(object, predicate) {
	    return _baseFindKey_js_1.default(object, _baseIteratee_js_1.default(predicate, 3), _baseForOwn_js_1.default);
	}
	exports.default = findKey;
	});

	var findLastIndex_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseFindIndex_js_1 = _baseFindIndex;
	var _baseIteratee_js_1 = _baseIteratee;
	var toInteger_js_1 = toInteger_1;
	var nativeMax = Math.max, nativeMin = Math.min;
	function findLastIndex(array, predicate, fromIndex) {
	    var length = array == null ? 0 : array.length;
	    if (!length) {
	        return -1;
	    }
	    var index = length - 1;
	    if (fromIndex !== undefined) {
	        index = toInteger_js_1.default(fromIndex);
	        index = fromIndex < 0
	            ? nativeMax(length + index, 0)
	            : nativeMin(index, length - 1);
	    }
	    return _baseFindIndex_js_1.default(array, _baseIteratee_js_1.default(predicate, 3), index, true);
	}
	exports.default = findLastIndex;
	});

	var findLast_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _createFind_js_1 = _createFind;
	var findLastIndex_js_1 = findLastIndex_1;
	var findLast = _createFind_js_1.default(findLastIndex_js_1.default);
	exports.default = findLast;
	});

	var findLastKey_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseFindKey_js_1 = _baseFindKey;
	var _baseForOwnRight_js_1 = _baseForOwnRight;
	var _baseIteratee_js_1 = _baseIteratee;
	function findLastKey(object, predicate) {
	    return _baseFindKey_js_1.default(object, _baseIteratee_js_1.default(predicate, 3), _baseForOwnRight_js_1.default);
	}
	exports.default = findLastKey;
	});

	var head_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	function head(array) {
	    return (array && array.length) ? array[0] : undefined;
	}
	exports.default = head;
	});

	var first = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var head_js_1 = head_1;
	exports.default = head_js_1.default;
	});

	var _baseMap = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseEach_js_1 = _baseEach;
	var isArrayLike_js_1 = isArrayLike_1;
	function baseMap(collection, iteratee) {
	    var index = -1, result = isArrayLike_js_1.default(collection) ? Array(collection.length) : [];
	    _baseEach_js_1.default(collection, function (value, key, collection) {
	        result[++index] = iteratee(value, key, collection);
	    });
	    return result;
	}
	exports.default = baseMap;
	});

	var map_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _arrayMap_js_1 = _arrayMap;
	var _baseIteratee_js_1 = _baseIteratee;
	var _baseMap_js_1 = _baseMap;
	var isArray_js_1 = isArray_1;
	function map(collection, iteratee) {
	    var func = isArray_js_1.default(collection) ? _arrayMap_js_1.default : _baseMap_js_1.default;
	    return func(collection, _baseIteratee_js_1.default(iteratee, 3));
	}
	exports.default = map;
	});

	var flatMap_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseFlatten_js_1 = _baseFlatten;
	var map_js_1 = map_1;
	function flatMap(collection, iteratee) {
	    return _baseFlatten_js_1.default(map_js_1.default(collection, iteratee), 1);
	}
	exports.default = flatMap;
	});

	var flatMapDeep_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseFlatten_js_1 = _baseFlatten;
	var map_js_1 = map_1;
	var INFINITY = 1 / 0;
	function flatMapDeep(collection, iteratee) {
	    return _baseFlatten_js_1.default(map_js_1.default(collection, iteratee), INFINITY);
	}
	exports.default = flatMapDeep;
	});

	var flatMapDepth_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseFlatten_js_1 = _baseFlatten;
	var map_js_1 = map_1;
	var toInteger_js_1 = toInteger_1;
	function flatMapDepth(collection, iteratee, depth) {
	    depth = depth === undefined ? 1 : toInteger_js_1.default(depth);
	    return _baseFlatten_js_1.default(map_js_1.default(collection, iteratee), depth);
	}
	exports.default = flatMapDepth;
	});

	var flattenDeep_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseFlatten_js_1 = _baseFlatten;
	var INFINITY = 1 / 0;
	function flattenDeep(array) {
	    var length = array == null ? 0 : array.length;
	    return length ? _baseFlatten_js_1.default(array, INFINITY) : [];
	}
	exports.default = flattenDeep;
	});

	var flattenDepth_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseFlatten_js_1 = _baseFlatten;
	var toInteger_js_1 = toInteger_1;
	function flattenDepth(array, depth) {
	    var length = array == null ? 0 : array.length;
	    if (!length) {
	        return [];
	    }
	    depth = depth === undefined ? 1 : toInteger_js_1.default(depth);
	    return _baseFlatten_js_1.default(array, depth);
	}
	exports.default = flattenDepth;
	});

	var flip_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _createWrap_js_1 = _createWrap;
	var WRAP_FLIP_FLAG = 512;
	function flip(func) {
	    return _createWrap_js_1.default(func, WRAP_FLIP_FLAG);
	}
	exports.default = flip;
	});

	var floor_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _createRound_js_1 = _createRound;
	var floor = _createRound_js_1.default('floor');
	exports.default = floor;
	});

	var flow_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _createFlow_js_1 = _createFlow;
	var flow = _createFlow_js_1.default();
	exports.default = flow;
	});

	var forIn_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseFor_js_1 = _baseFor;
	var _castFunction_js_1 = _castFunction;
	var keysIn_js_1 = keysIn_1;
	function forIn(object, iteratee) {
	    return object == null
	        ? object
	        : _baseFor_js_1.default(object, _castFunction_js_1.default(iteratee), keysIn_js_1.default);
	}
	exports.default = forIn;
	});

	var forInRight_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseForRight_js_1 = _baseForRight;
	var _castFunction_js_1 = _castFunction;
	var keysIn_js_1 = keysIn_1;
	function forInRight(object, iteratee) {
	    return object == null
	        ? object
	        : _baseForRight_js_1.default(object, _castFunction_js_1.default(iteratee), keysIn_js_1.default);
	}
	exports.default = forInRight;
	});

	var forOwn_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseForOwn_js_1 = _baseForOwn;
	var _castFunction_js_1 = _castFunction;
	function forOwn(object, iteratee) {
	    return object && _baseForOwn_js_1.default(object, _castFunction_js_1.default(iteratee));
	}
	exports.default = forOwn;
	});

	var forOwnRight_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseForOwnRight_js_1 = _baseForOwnRight;
	var _castFunction_js_1 = _castFunction;
	function forOwnRight(object, iteratee) {
	    return object && _baseForOwnRight_js_1.default(object, _castFunction_js_1.default(iteratee));
	}
	exports.default = forOwnRight;
	});

	var fromPairs_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	function fromPairs(pairs) {
	    var index = -1, length = pairs == null ? 0 : pairs.length, result = {};
	    while (++index < length) {
	        var pair = pairs[index];
	        result[pair[0]] = pair[1];
	    }
	    return result;
	}
	exports.default = fromPairs;
	});

	var _baseFunctions = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _arrayFilter_js_1 = _arrayFilter;
	var isFunction_js_1 = isFunction_1;
	function baseFunctions(object, props) {
	    return _arrayFilter_js_1.default(props, function (key) {
	        return isFunction_js_1.default(object[key]);
	    });
	}
	exports.default = baseFunctions;
	});

	var functions_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseFunctions_js_1 = _baseFunctions;
	var keys_js_1 = keys_1;
	function functions(object) {
	    return object == null ? [] : _baseFunctions_js_1.default(object, keys_js_1.default(object));
	}
	exports.default = functions;
	});

	var functionsIn_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseFunctions_js_1 = _baseFunctions;
	var keysIn_js_1 = keysIn_1;
	function functionsIn(object) {
	    return object == null ? [] : _baseFunctions_js_1.default(object, keysIn_js_1.default(object));
	}
	exports.default = functionsIn;
	});

	var groupBy_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseAssignValue_js_1 = _baseAssignValue;
	var _createAggregator_js_1 = _createAggregator;
	var objectProto = Object.prototype;
	var hasOwnProperty = objectProto.hasOwnProperty;
	var groupBy = _createAggregator_js_1.default(function (result, value, key) {
	    if (hasOwnProperty.call(result, key)) {
	        result[key].push(value);
	    }
	    else {
	        _baseAssignValue_js_1.default(result, key, [value]);
	    }
	});
	exports.default = groupBy;
	});

	var _baseGt = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	function baseGt(value, other) {
	    return value > other;
	}
	exports.default = baseGt;
	});

	var _createRelationalOperation = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var toNumber_js_1 = toNumber_1;
	function createRelationalOperation(operator) {
	    return function (value, other) {
	        if (!(typeof value == 'string' && typeof other == 'string')) {
	            value = toNumber_js_1.default(value);
	            other = toNumber_js_1.default(other);
	        }
	        return operator(value, other);
	    };
	}
	exports.default = createRelationalOperation;
	});

	var gt_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseGt_js_1 = _baseGt;
	var _createRelationalOperation_js_1 = _createRelationalOperation;
	var gt = _createRelationalOperation_js_1.default(_baseGt_js_1.default);
	exports.default = gt;
	});

	var gte_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _createRelationalOperation_js_1 = _createRelationalOperation;
	var gte = _createRelationalOperation_js_1.default(function (value, other) {
	    return value >= other;
	});
	exports.default = gte;
	});

	var _baseHas = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var objectProto = Object.prototype;
	var hasOwnProperty = objectProto.hasOwnProperty;
	function baseHas(object, key) {
	    return object != null && hasOwnProperty.call(object, key);
	}
	exports.default = baseHas;
	});

	var has_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseHas_js_1 = _baseHas;
	var _hasPath_js_1 = _hasPath;
	function has(object, path) {
	    return object != null && _hasPath_js_1.default(object, path, _baseHas_js_1.default);
	}
	exports.default = has;
	});

	var _baseInRange = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var nativeMax = Math.max, nativeMin = Math.min;
	function baseInRange(number, start, end) {
	    return number >= nativeMin(start, end) && number < nativeMax(start, end);
	}
	exports.default = baseInRange;
	});

	var inRange_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseInRange_js_1 = _baseInRange;
	var toFinite_js_1 = toFinite_1;
	var toNumber_js_1 = toNumber_1;
	function inRange(number, start, end) {
	    start = toFinite_js_1.default(start);
	    if (end === undefined) {
	        end = start;
	        start = 0;
	    }
	    else {
	        end = toFinite_js_1.default(end);
	    }
	    number = toNumber_js_1.default(number);
	    return _baseInRange_js_1.default(number, start, end);
	}
	exports.default = inRange;
	});

	var isString_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseGetTag_js_1 = _baseGetTag;
	var isArray_js_1 = isArray_1;
	var isObjectLike_js_1 = isObjectLike_1;
	var stringTag = '[object String]';
	function isString(value) {
	    return typeof value == 'string' ||
	        (!isArray_js_1.default(value) && isObjectLike_js_1.default(value) && _baseGetTag_js_1.default(value) == stringTag);
	}
	exports.default = isString;
	});

	var _baseValues = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _arrayMap_js_1 = _arrayMap;
	function baseValues(object, props) {
	    return _arrayMap_js_1.default(props, function (key) {
	        return object[key];
	    });
	}
	exports.default = baseValues;
	});

	var values_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseValues_js_1 = _baseValues;
	var keys_js_1 = keys_1;
	function values(object) {
	    return object == null ? [] : _baseValues_js_1.default(object, keys_js_1.default(object));
	}
	exports.default = values;
	});

	var includes_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseIndexOf_js_1 = _baseIndexOf;
	var isArrayLike_js_1 = isArrayLike_1;
	var isString_js_1 = isString_1;
	var toInteger_js_1 = toInteger_1;
	var values_js_1 = values_1;
	var nativeMax = Math.max;
	function includes(collection, value, fromIndex, guard) {
	    collection = isArrayLike_js_1.default(collection) ? collection : values_js_1.default(collection);
	    fromIndex = (fromIndex && !guard) ? toInteger_js_1.default(fromIndex) : 0;
	    var length = collection.length;
	    if (fromIndex < 0) {
	        fromIndex = nativeMax(length + fromIndex, 0);
	    }
	    return isString_js_1.default(collection)
	        ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)
	        : (!!length && _baseIndexOf_js_1.default(collection, value, fromIndex) > -1);
	}
	exports.default = includes;
	});

	var indexOf_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseIndexOf_js_1 = _baseIndexOf;
	var toInteger_js_1 = toInteger_1;
	var nativeMax = Math.max;
	function indexOf(array, value, fromIndex) {
	    var length = array == null ? 0 : array.length;
	    if (!length) {
	        return -1;
	    }
	    var index = fromIndex == null ? 0 : toInteger_js_1.default(fromIndex);
	    if (index < 0) {
	        index = nativeMax(length + index, 0);
	    }
	    return _baseIndexOf_js_1.default(array, value, index);
	}
	exports.default = indexOf;
	});

	var initial_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseSlice_js_1 = _baseSlice;
	function initial(array) {
	    var length = array == null ? 0 : array.length;
	    return length ? _baseSlice_js_1.default(array, 0, -1) : [];
	}
	exports.default = initial;
	});

	var _baseIntersection = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _SetCache_js_1 = _SetCache;
	var _arrayIncludes_js_1 = _arrayIncludes;
	var _arrayIncludesWith_js_1 = _arrayIncludesWith;
	var _arrayMap_js_1 = _arrayMap;
	var _baseUnary_js_1 = _baseUnary;
	var _cacheHas_js_1 = _cacheHas;
	var nativeMin = Math.min;
	function baseIntersection(arrays, iteratee, comparator) {
	    var includes = comparator ? _arrayIncludesWith_js_1.default : _arrayIncludes_js_1.default, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array(othLength), maxLength = Infinity, result = [];
	    while (othIndex--) {
	        var array = arrays[othIndex];
	        if (othIndex && iteratee) {
	            array = _arrayMap_js_1.default(array, _baseUnary_js_1.default(iteratee));
	        }
	        maxLength = nativeMin(array.length, maxLength);
	        caches[othIndex] = !comparator && (iteratee || (length >= 120 && array.length >= 120))
	            ? new _SetCache_js_1.default(othIndex && array)
	            : undefined;
	    }
	    array = arrays[0];
	    var index = -1, seen = caches[0];
	    outer: while (++index < length && result.length < maxLength) {
	        var value = array[index], computed = iteratee ? iteratee(value) : value;
	        value = (comparator || value !== 0) ? value : 0;
	        if (!(seen
	            ? _cacheHas_js_1.default(seen, computed)
	            : includes(result, computed, comparator))) {
	            othIndex = othLength;
	            while (--othIndex) {
	                var cache = caches[othIndex];
	                if (!(cache
	                    ? _cacheHas_js_1.default(cache, computed)
	                    : includes(arrays[othIndex], computed, comparator))) {
	                    continue outer;
	                }
	            }
	            if (seen) {
	                seen.push(computed);
	            }
	            result.push(value);
	        }
	    }
	    return result;
	}
	exports.default = baseIntersection;
	});

	var _castArrayLikeObject = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var isArrayLikeObject_js_1 = isArrayLikeObject_1;
	function castArrayLikeObject(value) {
	    return isArrayLikeObject_js_1.default(value) ? value : [];
	}
	exports.default = castArrayLikeObject;
	});

	var intersection_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _arrayMap_js_1 = _arrayMap;
	var _baseIntersection_js_1 = _baseIntersection;
	var _baseRest_js_1 = _baseRest;
	var _castArrayLikeObject_js_1 = _castArrayLikeObject;
	var intersection = _baseRest_js_1.default(function (arrays) {
	    var mapped = _arrayMap_js_1.default(arrays, _castArrayLikeObject_js_1.default);
	    return (mapped.length && mapped[0] === arrays[0])
	        ? _baseIntersection_js_1.default(mapped)
	        : [];
	});
	exports.default = intersection;
	});

	var intersectionBy_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _arrayMap_js_1 = _arrayMap;
	var _baseIntersection_js_1 = _baseIntersection;
	var _baseIteratee_js_1 = _baseIteratee;
	var _baseRest_js_1 = _baseRest;
	var _castArrayLikeObject_js_1 = _castArrayLikeObject;
	var last_js_1 = last_1;
	var intersectionBy = _baseRest_js_1.default(function (arrays) {
	    var iteratee = last_js_1.default(arrays), mapped = _arrayMap_js_1.default(arrays, _castArrayLikeObject_js_1.default);
	    if (iteratee === last_js_1.default(mapped)) {
	        iteratee = undefined;
	    }
	    else {
	        mapped.pop();
	    }
	    return (mapped.length && mapped[0] === arrays[0])
	        ? _baseIntersection_js_1.default(mapped, _baseIteratee_js_1.default(iteratee, 2))
	        : [];
	});
	exports.default = intersectionBy;
	});

	var intersectionWith_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _arrayMap_js_1 = _arrayMap;
	var _baseIntersection_js_1 = _baseIntersection;
	var _baseRest_js_1 = _baseRest;
	var _castArrayLikeObject_js_1 = _castArrayLikeObject;
	var last_js_1 = last_1;
	var intersectionWith = _baseRest_js_1.default(function (arrays) {
	    var comparator = last_js_1.default(arrays), mapped = _arrayMap_js_1.default(arrays, _castArrayLikeObject_js_1.default);
	    comparator = typeof comparator == 'function' ? comparator : undefined;
	    if (comparator) {
	        mapped.pop();
	    }
	    return (mapped.length && mapped[0] === arrays[0])
	        ? _baseIntersection_js_1.default(mapped, undefined, comparator)
	        : [];
	});
	exports.default = intersectionWith;
	});

	var _baseInverter = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseForOwn_js_1 = _baseForOwn;
	function baseInverter(object, setter, iteratee, accumulator) {
	    _baseForOwn_js_1.default(object, function (value, key, object) {
	        setter(accumulator, iteratee(value), key, object);
	    });
	    return accumulator;
	}
	exports.default = baseInverter;
	});

	var _createInverter = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseInverter_js_1 = _baseInverter;
	function createInverter(setter, toIteratee) {
	    return function (object, iteratee) {
	        return _baseInverter_js_1.default(object, setter, toIteratee(iteratee), {});
	    };
	}
	exports.default = createInverter;
	});

	var invert_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var constant_js_1 = constant_1;
	var _createInverter_js_1 = _createInverter;
	var identity_js_1 = identity_1;
	var invert = _createInverter_js_1.default(function (result, value, key) {
	    result[value] = key;
	}, constant_js_1.default(identity_js_1.default));
	exports.default = invert;
	});

	var invertBy_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseIteratee_js_1 = _baseIteratee;
	var _createInverter_js_1 = _createInverter;
	var objectProto = Object.prototype;
	var hasOwnProperty = objectProto.hasOwnProperty;
	var invertBy = _createInverter_js_1.default(function (result, value, key) {
	    if (hasOwnProperty.call(result, value)) {
	        result[value].push(key);
	    }
	    else {
	        result[value] = [key];
	    }
	}, _baseIteratee_js_1.default);
	exports.default = invertBy;
	});

	var _parent = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseGet_js_1 = _baseGet;
	var _baseSlice_js_1 = _baseSlice;
	function parent(object, path) {
	    return path.length < 2 ? object : _baseGet_js_1.default(object, _baseSlice_js_1.default(path, 0, -1));
	}
	exports.default = parent;
	});

	var _baseInvoke = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _apply_js_1 = _apply;
	var _castPath_js_1 = _castPath;
	var last_js_1 = last_1;
	var _parent_js_1 = _parent;
	var _toKey_js_1 = _toKey;
	function baseInvoke(object, path, args) {
	    path = _castPath_js_1.default(path, object);
	    object = _parent_js_1.default(object, path);
	    var func = object == null ? object : object[_toKey_js_1.default(last_js_1.default(path))];
	    return func == null ? undefined : _apply_js_1.default(func, object, args);
	}
	exports.default = baseInvoke;
	});

	var invoke_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseInvoke_js_1 = _baseInvoke;
	var _baseRest_js_1 = _baseRest;
	var invoke = _baseRest_js_1.default(_baseInvoke_js_1.default);
	exports.default = invoke;
	});

	var invokeMap_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _apply_js_1 = _apply;
	var _baseEach_js_1 = _baseEach;
	var _baseInvoke_js_1 = _baseInvoke;
	var _baseRest_js_1 = _baseRest;
	var isArrayLike_js_1 = isArrayLike_1;
	var invokeMap = _baseRest_js_1.default(function (collection, path, args) {
	    var index = -1, isFunc = typeof path == 'function', result = isArrayLike_js_1.default(collection) ? Array(collection.length) : [];
	    _baseEach_js_1.default(collection, function (value) {
	        result[++index] = isFunc ? _apply_js_1.default(path, value, args) : _baseInvoke_js_1.default(value, path, args);
	    });
	    return result;
	});
	exports.default = invokeMap;
	});

	var _baseIsArrayBuffer = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseGetTag_js_1 = _baseGetTag;
	var isObjectLike_js_1 = isObjectLike_1;
	var arrayBufferTag = '[object ArrayBuffer]';
	function baseIsArrayBuffer(value) {
	    return isObjectLike_js_1.default(value) && _baseGetTag_js_1.default(value) == arrayBufferTag;
	}
	exports.default = baseIsArrayBuffer;
	});

	var isArrayBuffer_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseIsArrayBuffer_js_1 = _baseIsArrayBuffer;
	var _baseUnary_js_1 = _baseUnary;
	var _nodeUtil_js_1 = _nodeUtil;
	var nodeIsArrayBuffer = _nodeUtil_js_1.default && _nodeUtil_js_1.default.isArrayBuffer;
	var isArrayBuffer = nodeIsArrayBuffer ? _baseUnary_js_1.default(nodeIsArrayBuffer) : _baseIsArrayBuffer_js_1.default;
	exports.default = isArrayBuffer;
	});

	var isBoolean_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseGetTag_js_1 = _baseGetTag;
	var isObjectLike_js_1 = isObjectLike_1;
	var boolTag = '[object Boolean]';
	function isBoolean(value) {
	    return value === true || value === false ||
	        (isObjectLike_js_1.default(value) && _baseGetTag_js_1.default(value) == boolTag);
	}
	exports.default = isBoolean;
	});

	var _baseIsDate = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseGetTag_js_1 = _baseGetTag;
	var isObjectLike_js_1 = isObjectLike_1;
	var dateTag = '[object Date]';
	function baseIsDate(value) {
	    return isObjectLike_js_1.default(value) && _baseGetTag_js_1.default(value) == dateTag;
	}
	exports.default = baseIsDate;
	});

	var isDate_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseIsDate_js_1 = _baseIsDate;
	var _baseUnary_js_1 = _baseUnary;
	var _nodeUtil_js_1 = _nodeUtil;
	var nodeIsDate = _nodeUtil_js_1.default && _nodeUtil_js_1.default.isDate;
	var isDate = nodeIsDate ? _baseUnary_js_1.default(nodeIsDate) : _baseIsDate_js_1.default;
	exports.default = isDate;
	});

	var isElement_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var isObjectLike_js_1 = isObjectLike_1;
	var isPlainObject_js_1 = isPlainObject_1;
	function isElement(value) {
	    return isObjectLike_js_1.default(value) && value.nodeType === 1 && !isPlainObject_js_1.default(value);
	}
	exports.default = isElement;
	});

	var isEmpty_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseKeys_js_1 = _baseKeys;
	var _getTag_js_1 = _getTag;
	var isArguments_js_1 = isArguments_1;
	var isArray_js_1 = isArray_1;
	var isArrayLike_js_1 = isArrayLike_1;
	var isBuffer_js_1 = isBuffer_1;
	var _isPrototype_js_1 = _isPrototype;
	var isTypedArray_js_1 = isTypedArray_1;
	var mapTag = '[object Map]', setTag = '[object Set]';
	var objectProto = Object.prototype;
	var hasOwnProperty = objectProto.hasOwnProperty;
	function isEmpty(value) {
	    if (value == null) {
	        return true;
	    }
	    if (isArrayLike_js_1.default(value) &&
	        (isArray_js_1.default(value) || typeof value == 'string' || typeof value.splice == 'function' ||
	            isBuffer_js_1.default(value) || isTypedArray_js_1.default(value) || isArguments_js_1.default(value))) {
	        return !value.length;
	    }
	    var tag = _getTag_js_1.default(value);
	    if (tag == mapTag || tag == setTag) {
	        return !value.size;
	    }
	    if (_isPrototype_js_1.default(value)) {
	        return !_baseKeys_js_1.default(value).length;
	    }
	    for (var key in value) {
	        if (hasOwnProperty.call(value, key)) {
	            return false;
	        }
	    }
	    return true;
	}
	exports.default = isEmpty;
	});

	var isEqual_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseIsEqual_js_1 = _baseIsEqual;
	function isEqual(value, other) {
	    return _baseIsEqual_js_1.default(value, other);
	}
	exports.default = isEqual;
	});

	var isEqualWith_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseIsEqual_js_1 = _baseIsEqual;
	function isEqualWith(value, other, customizer) {
	    customizer = typeof customizer == 'function' ? customizer : undefined;
	    var result = customizer ? customizer(value, other) : undefined;
	    return result === undefined ? _baseIsEqual_js_1.default(value, other, undefined, customizer) : !!result;
	}
	exports.default = isEqualWith;
	});

	var _isFinite = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _root_js_1 = _root;
	var nativeIsFinite = _root_js_1.default.isFinite;
	function isFinite(value) {
	    return typeof value == 'number' && nativeIsFinite(value);
	}
	exports.default = isFinite;
	});

	var isInteger_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var toInteger_js_1 = toInteger_1;
	function isInteger(value) {
	    return typeof value == 'number' && value == toInteger_js_1.default(value);
	}
	exports.default = isInteger;
	});

	var _baseIsMap = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _getTag_js_1 = _getTag;
	var isObjectLike_js_1 = isObjectLike_1;
	var mapTag = '[object Map]';
	function baseIsMap(value) {
	    return isObjectLike_js_1.default(value) && _getTag_js_1.default(value) == mapTag;
	}
	exports.default = baseIsMap;
	});

	var isMap_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseIsMap_js_1 = _baseIsMap;
	var _baseUnary_js_1 = _baseUnary;
	var _nodeUtil_js_1 = _nodeUtil;
	var nodeIsMap = _nodeUtil_js_1.default && _nodeUtil_js_1.default.isMap;
	var isMap = nodeIsMap ? _baseUnary_js_1.default(nodeIsMap) : _baseIsMap_js_1.default;
	exports.default = isMap;
	});

	var isMatch_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseIsMatch_js_1 = _baseIsMatch;
	var _getMatchData_js_1 = _getMatchData;
	function isMatch(object, source) {
	    return object === source || _baseIsMatch_js_1.default(object, source, _getMatchData_js_1.default(source));
	}
	exports.default = isMatch;
	});

	var isMatchWith_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseIsMatch_js_1 = _baseIsMatch;
	var _getMatchData_js_1 = _getMatchData;
	function isMatchWith(object, source, customizer) {
	    customizer = typeof customizer == 'function' ? customizer : undefined;
	    return _baseIsMatch_js_1.default(object, source, _getMatchData_js_1.default(source), customizer);
	}
	exports.default = isMatchWith;
	});

	var isNumber_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseGetTag_js_1 = _baseGetTag;
	var isObjectLike_js_1 = isObjectLike_1;
	var numberTag = '[object Number]';
	function isNumber(value) {
	    return typeof value == 'number' ||
	        (isObjectLike_js_1.default(value) && _baseGetTag_js_1.default(value) == numberTag);
	}
	exports.default = isNumber;
	});

	var _isNaN = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var isNumber_js_1 = isNumber_1;
	function isNaN(value) {
	    return isNumber_js_1.default(value) && value != +value;
	}
	exports.default = isNaN;
	});

	var _isMaskable = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _coreJsData_js_1 = _coreJsData;
	var isFunction_js_1 = isFunction_1;
	var stubFalse_js_1 = stubFalse_1;
	var isMaskable = _coreJsData_js_1.default ? isFunction_js_1.default : stubFalse_js_1.default;
	exports.default = isMaskable;
	});

	var isNative_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseIsNative_js_1 = _baseIsNative;
	var _isMaskable_js_1 = _isMaskable;
	var CORE_ERROR_TEXT = 'Unsupported core-js use. Try https://npms.io/search?q=ponyfill.';
	function isNative(value) {
	    if (_isMaskable_js_1.default(value)) {
	        throw new Error(CORE_ERROR_TEXT);
	    }
	    return _baseIsNative_js_1.default(value);
	}
	exports.default = isNative;
	});

	var isNil_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	function isNil(value) {
	    return value == null;
	}
	exports.default = isNil;
	});

	var isNull_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	function isNull(value) {
	    return value === null;
	}
	exports.default = isNull;
	});

	var _baseIsRegExp = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseGetTag_js_1 = _baseGetTag;
	var isObjectLike_js_1 = isObjectLike_1;
	var regexpTag = '[object RegExp]';
	function baseIsRegExp(value) {
	    return isObjectLike_js_1.default(value) && _baseGetTag_js_1.default(value) == regexpTag;
	}
	exports.default = baseIsRegExp;
	});

	var isRegExp_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseIsRegExp_js_1 = _baseIsRegExp;
	var _baseUnary_js_1 = _baseUnary;
	var _nodeUtil_js_1 = _nodeUtil;
	var nodeIsRegExp = _nodeUtil_js_1.default && _nodeUtil_js_1.default.isRegExp;
	var isRegExp = nodeIsRegExp ? _baseUnary_js_1.default(nodeIsRegExp) : _baseIsRegExp_js_1.default;
	exports.default = isRegExp;
	});

	var isSafeInteger_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var isInteger_js_1 = isInteger_1;
	var MAX_SAFE_INTEGER = 9007199254740991;
	function isSafeInteger(value) {
	    return isInteger_js_1.default(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
	}
	exports.default = isSafeInteger;
	});

	var _baseIsSet = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _getTag_js_1 = _getTag;
	var isObjectLike_js_1 = isObjectLike_1;
	var setTag = '[object Set]';
	function baseIsSet(value) {
	    return isObjectLike_js_1.default(value) && _getTag_js_1.default(value) == setTag;
	}
	exports.default = baseIsSet;
	});

	var isSet_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseIsSet_js_1 = _baseIsSet;
	var _baseUnary_js_1 = _baseUnary;
	var _nodeUtil_js_1 = _nodeUtil;
	var nodeIsSet = _nodeUtil_js_1.default && _nodeUtil_js_1.default.isSet;
	var isSet = nodeIsSet ? _baseUnary_js_1.default(nodeIsSet) : _baseIsSet_js_1.default;
	exports.default = isSet;
	});

	var isUndefined_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	function isUndefined(value) {
	    return value === undefined;
	}
	exports.default = isUndefined;
	});

	var isWeakMap_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _getTag_js_1 = _getTag;
	var isObjectLike_js_1 = isObjectLike_1;
	var weakMapTag = '[object WeakMap]';
	function isWeakMap(value) {
	    return isObjectLike_js_1.default(value) && _getTag_js_1.default(value) == weakMapTag;
	}
	exports.default = isWeakMap;
	});

	var isWeakSet_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseGetTag_js_1 = _baseGetTag;
	var isObjectLike_js_1 = isObjectLike_1;
	var weakSetTag = '[object WeakSet]';
	function isWeakSet(value) {
	    return isObjectLike_js_1.default(value) && _baseGetTag_js_1.default(value) == weakSetTag;
	}
	exports.default = isWeakSet;
	});

	var iteratee_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseClone_js_1 = _baseClone;
	var _baseIteratee_js_1 = _baseIteratee;
	var CLONE_DEEP_FLAG = 1;
	function iteratee(func) {
	    return _baseIteratee_js_1.default(typeof func == 'function' ? func : _baseClone_js_1.default(func, CLONE_DEEP_FLAG));
	}
	exports.default = iteratee;
	});

	var join_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var arrayProto = Array.prototype;
	var nativeJoin = arrayProto.join;
	function join(array, separator) {
	    return array == null ? '' : nativeJoin.call(array, separator);
	}
	exports.default = join;
	});

	var kebabCase_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _createCompounder_js_1 = _createCompounder;
	var kebabCase = _createCompounder_js_1.default(function (result, word, index) {
	    return result + (index ? '-' : '') + word.toLowerCase();
	});
	exports.default = kebabCase;
	});

	var keyBy_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseAssignValue_js_1 = _baseAssignValue;
	var _createAggregator_js_1 = _createAggregator;
	var keyBy = _createAggregator_js_1.default(function (result, value, key) {
	    _baseAssignValue_js_1.default(result, key, value);
	});
	exports.default = keyBy;
	});

	var _strictLastIndexOf = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	function strictLastIndexOf(array, value, fromIndex) {
	    var index = fromIndex + 1;
	    while (index--) {
	        if (array[index] === value) {
	            return index;
	        }
	    }
	    return index;
	}
	exports.default = strictLastIndexOf;
	});

	var lastIndexOf_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseFindIndex_js_1 = _baseFindIndex;
	var _baseIsNaN_js_1 = _baseIsNaN;
	var _strictLastIndexOf_js_1 = _strictLastIndexOf;
	var toInteger_js_1 = toInteger_1;
	var nativeMax = Math.max, nativeMin = Math.min;
	function lastIndexOf(array, value, fromIndex) {
	    var length = array == null ? 0 : array.length;
	    if (!length) {
	        return -1;
	    }
	    var index = length;
	    if (fromIndex !== undefined) {
	        index = toInteger_js_1.default(fromIndex);
	        index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
	    }
	    return value === value
	        ? _strictLastIndexOf_js_1.default(array, value, index)
	        : _baseFindIndex_js_1.default(array, _baseIsNaN_js_1.default, index, true);
	}
	exports.default = lastIndexOf;
	});

	var lowerCase_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _createCompounder_js_1 = _createCompounder;
	var lowerCase = _createCompounder_js_1.default(function (result, word, index) {
	    return result + (index ? ' ' : '') + word.toLowerCase();
	});
	exports.default = lowerCase;
	});

	var lowerFirst_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _createCaseFirst_js_1 = _createCaseFirst;
	var lowerFirst = _createCaseFirst_js_1.default('toLowerCase');
	exports.default = lowerFirst;
	});

	var _baseLt = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	function baseLt(value, other) {
	    return value < other;
	}
	exports.default = baseLt;
	});

	var lt_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseLt_js_1 = _baseLt;
	var _createRelationalOperation_js_1 = _createRelationalOperation;
	var lt = _createRelationalOperation_js_1.default(_baseLt_js_1.default);
	exports.default = lt;
	});

	var lte_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _createRelationalOperation_js_1 = _createRelationalOperation;
	var lte = _createRelationalOperation_js_1.default(function (value, other) {
	    return value <= other;
	});
	exports.default = lte;
	});

	var mapKeys_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseAssignValue_js_1 = _baseAssignValue;
	var _baseForOwn_js_1 = _baseForOwn;
	var _baseIteratee_js_1 = _baseIteratee;
	function mapKeys(object, iteratee) {
	    var result = {};
	    iteratee = _baseIteratee_js_1.default(iteratee, 3);
	    _baseForOwn_js_1.default(object, function (value, key, object) {
	        _baseAssignValue_js_1.default(result, iteratee(value, key, object), value);
	    });
	    return result;
	}
	exports.default = mapKeys;
	});

	var mapValues_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseAssignValue_js_1 = _baseAssignValue;
	var _baseForOwn_js_1 = _baseForOwn;
	var _baseIteratee_js_1 = _baseIteratee;
	function mapValues(object, iteratee) {
	    var result = {};
	    iteratee = _baseIteratee_js_1.default(iteratee, 3);
	    _baseForOwn_js_1.default(object, function (value, key, object) {
	        _baseAssignValue_js_1.default(result, key, iteratee(value, key, object));
	    });
	    return result;
	}
	exports.default = mapValues;
	});

	var matches_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseClone_js_1 = _baseClone;
	var _baseMatches_js_1 = _baseMatches;
	var CLONE_DEEP_FLAG = 1;
	function matches(source) {
	    return _baseMatches_js_1.default(_baseClone_js_1.default(source, CLONE_DEEP_FLAG));
	}
	exports.default = matches;
	});

	var matchesProperty_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseClone_js_1 = _baseClone;
	var _baseMatchesProperty_js_1 = _baseMatchesProperty;
	var CLONE_DEEP_FLAG = 1;
	function matchesProperty(path, srcValue) {
	    return _baseMatchesProperty_js_1.default(path, _baseClone_js_1.default(srcValue, CLONE_DEEP_FLAG));
	}
	exports.default = matchesProperty;
	});

	var _baseExtremum = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var isSymbol_js_1 = isSymbol_1;
	function baseExtremum(array, iteratee, comparator) {
	    var index = -1, length = array.length;
	    while (++index < length) {
	        var value = array[index], current = iteratee(value);
	        if (current != null && (computed === undefined
	            ? (current === current && !isSymbol_js_1.default(current))
	            : comparator(current, computed))) {
	            var computed = current, result = value;
	        }
	    }
	    return result;
	}
	exports.default = baseExtremum;
	});

	var max_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseExtremum_js_1 = _baseExtremum;
	var _baseGt_js_1 = _baseGt;
	var identity_js_1 = identity_1;
	function max(array) {
	    return (array && array.length)
	        ? _baseExtremum_js_1.default(array, identity_js_1.default, _baseGt_js_1.default)
	        : undefined;
	}
	exports.default = max;
	});

	var maxBy_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseExtremum_js_1 = _baseExtremum;
	var _baseGt_js_1 = _baseGt;
	var _baseIteratee_js_1 = _baseIteratee;
	function maxBy(array, iteratee) {
	    return (array && array.length)
	        ? _baseExtremum_js_1.default(array, _baseIteratee_js_1.default(iteratee, 2), _baseGt_js_1.default)
	        : undefined;
	}
	exports.default = maxBy;
	});

	var _baseSum = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	function baseSum(array, iteratee) {
	    var result, index = -1, length = array.length;
	    while (++index < length) {
	        var current = iteratee(array[index]);
	        if (current !== undefined) {
	            result = result === undefined ? current : (result + current);
	        }
	    }
	    return result;
	}
	exports.default = baseSum;
	});

	var _baseMean = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseSum_js_1 = _baseSum;
	var NAN = 0 / 0;
	function baseMean(array, iteratee) {
	    var length = array == null ? 0 : array.length;
	    return length ? (_baseSum_js_1.default(array, iteratee) / length) : NAN;
	}
	exports.default = baseMean;
	});

	var mean_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseMean_js_1 = _baseMean;
	var identity_js_1 = identity_1;
	function mean(array) {
	    return _baseMean_js_1.default(array, identity_js_1.default);
	}
	exports.default = mean;
	});

	var meanBy_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseIteratee_js_1 = _baseIteratee;
	var _baseMean_js_1 = _baseMean;
	function meanBy(array, iteratee) {
	    return _baseMean_js_1.default(array, _baseIteratee_js_1.default(iteratee, 2));
	}
	exports.default = meanBy;
	});

	var merge_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseMerge_js_1 = _baseMerge;
	var _createAssigner_js_1 = _createAssigner;
	var merge = _createAssigner_js_1.default(function (object, source, srcIndex) {
	    _baseMerge_js_1.default(object, source, srcIndex);
	});
	exports.default = merge;
	});

	var method_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseInvoke_js_1 = _baseInvoke;
	var _baseRest_js_1 = _baseRest;
	var method = _baseRest_js_1.default(function (path, args) {
	    return function (object) {
	        return _baseInvoke_js_1.default(object, path, args);
	    };
	});
	exports.default = method;
	});

	var methodOf_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseInvoke_js_1 = _baseInvoke;
	var _baseRest_js_1 = _baseRest;
	var methodOf = _baseRest_js_1.default(function (object, args) {
	    return function (path) {
	        return _baseInvoke_js_1.default(object, path, args);
	    };
	});
	exports.default = methodOf;
	});

	var min_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseExtremum_js_1 = _baseExtremum;
	var _baseLt_js_1 = _baseLt;
	var identity_js_1 = identity_1;
	function min(array) {
	    return (array && array.length)
	        ? _baseExtremum_js_1.default(array, identity_js_1.default, _baseLt_js_1.default)
	        : undefined;
	}
	exports.default = min;
	});

	var minBy_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseExtremum_js_1 = _baseExtremum;
	var _baseIteratee_js_1 = _baseIteratee;
	var _baseLt_js_1 = _baseLt;
	function minBy(array, iteratee) {
	    return (array && array.length)
	        ? _baseExtremum_js_1.default(array, _baseIteratee_js_1.default(iteratee, 2), _baseLt_js_1.default)
	        : undefined;
	}
	exports.default = minBy;
	});

	var mixin_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _arrayEach_js_1 = _arrayEach;
	var _arrayPush_js_1 = _arrayPush;
	var _baseFunctions_js_1 = _baseFunctions;
	var _copyArray_js_1 = _copyArray;
	var isFunction_js_1 = isFunction_1;
	var isObject_js_1 = isObject_1;
	var keys_js_1 = keys_1;
	function mixin(object, source, options) {
	    var props = keys_js_1.default(source), methodNames = _baseFunctions_js_1.default(source, props);
	    var chain = !(isObject_js_1.default(options) && 'chain' in options) || !!options.chain, isFunc = isFunction_js_1.default(object);
	    _arrayEach_js_1.default(methodNames, function (methodName) {
	        var func = source[methodName];
	        object[methodName] = func;
	        if (isFunc) {
	            object.prototype[methodName] = function () {
	                var chainAll = this.__chain__;
	                if (chain || chainAll) {
	                    var result = object(this.__wrapped__), actions = result.__actions__ = _copyArray_js_1.default(this.__actions__);
	                    actions.push({ 'func': func, 'args': arguments, 'thisArg': object });
	                    result.__chain__ = chainAll;
	                    return result;
	                }
	                return func.apply(object, _arrayPush_js_1.default([this.value()], arguments));
	            };
	        }
	    });
	    return object;
	}
	exports.default = mixin;
	});

	var multiply_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _createMathOperation_js_1 = _createMathOperation;
	var multiply = _createMathOperation_js_1.default(function (multiplier, multiplicand) {
	    return multiplier * multiplicand;
	}, 1);
	exports.default = multiply;
	});

	var negate_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var FUNC_ERROR_TEXT = 'Expected a function';
	function negate(predicate) {
	    if (typeof predicate != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	    }
	    return function () {
	        var args = arguments;
	        switch (args.length) {
	            case 0: return !predicate.call(this);
	            case 1: return !predicate.call(this, args[0]);
	            case 2: return !predicate.call(this, args[0], args[1]);
	            case 3: return !predicate.call(this, args[0], args[1], args[2]);
	        }
	        return !predicate.apply(this, args);
	    };
	}
	exports.default = negate;
	});

	var _iteratorToArray = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	function iteratorToArray(iterator) {
	    var data, result = [];
	    while (!(data = iterator.next()).done) {
	        result.push(data.value);
	    }
	    return result;
	}
	exports.default = iteratorToArray;
	});

	var toArray_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _Symbol_js_1 = _Symbol;
	var _copyArray_js_1 = _copyArray;
	var _getTag_js_1 = _getTag;
	var isArrayLike_js_1 = isArrayLike_1;
	var isString_js_1 = isString_1;
	var _iteratorToArray_js_1 = _iteratorToArray;
	var _mapToArray_js_1 = _mapToArray;
	var _setToArray_js_1 = _setToArray;
	var _stringToArray_js_1 = _stringToArray;
	var values_js_1 = values_1;
	var mapTag = '[object Map]', setTag = '[object Set]';
	var symIterator = _Symbol_js_1.default ? _Symbol_js_1.default.iterator : undefined;
	function toArray(value) {
	    if (!value) {
	        return [];
	    }
	    if (isArrayLike_js_1.default(value)) {
	        return isString_js_1.default(value) ? _stringToArray_js_1.default(value) : _copyArray_js_1.default(value);
	    }
	    if (symIterator && value[symIterator]) {
	        return _iteratorToArray_js_1.default(value[symIterator]());
	    }
	    var tag = _getTag_js_1.default(value), func = tag == mapTag ? _mapToArray_js_1.default : (tag == setTag ? _setToArray_js_1.default : values_js_1.default);
	    return func(value);
	}
	exports.default = toArray;
	});

	var next = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var toArray_js_1 = toArray_1;
	function wrapperNext() {
	    if (this.__values__ === undefined) {
	        this.__values__ = toArray_js_1.default(this.value());
	    }
	    var done = this.__index__ >= this.__values__.length, value = done ? undefined : this.__values__[this.__index__++];
	    return { 'done': done, 'value': value };
	}
	exports.default = wrapperNext;
	});

	var _baseNth = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _isIndex_js_1 = _isIndex;
	function baseNth(array, n) {
	    var length = array.length;
	    if (!length) {
	        return;
	    }
	    n += n < 0 ? length : 0;
	    return _isIndex_js_1.default(n, length) ? array[n] : undefined;
	}
	exports.default = baseNth;
	});

	var nth_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseNth_js_1 = _baseNth;
	var toInteger_js_1 = toInteger_1;
	function nth(array, n) {
	    return (array && array.length) ? _baseNth_js_1.default(array, toInteger_js_1.default(n)) : undefined;
	}
	exports.default = nth;
	});

	var nthArg_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseNth_js_1 = _baseNth;
	var _baseRest_js_1 = _baseRest;
	var toInteger_js_1 = toInteger_1;
	function nthArg(n) {
	    n = toInteger_js_1.default(n);
	    return _baseRest_js_1.default(function (args) {
	        return _baseNth_js_1.default(args, n);
	    });
	}
	exports.default = nthArg;
	});

	var _baseUnset = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _castPath_js_1 = _castPath;
	var last_js_1 = last_1;
	var _parent_js_1 = _parent;
	var _toKey_js_1 = _toKey;
	function baseUnset(object, path) {
	    path = _castPath_js_1.default(path, object);
	    object = _parent_js_1.default(object, path);
	    return object == null || delete object[_toKey_js_1.default(last_js_1.default(path))];
	}
	exports.default = baseUnset;
	});

	var _customOmitClone = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var isPlainObject_js_1 = isPlainObject_1;
	function customOmitClone(value) {
	    return isPlainObject_js_1.default(value) ? undefined : value;
	}
	exports.default = customOmitClone;
	});

	var omit_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _arrayMap_js_1 = _arrayMap;
	var _baseClone_js_1 = _baseClone;
	var _baseUnset_js_1 = _baseUnset;
	var _castPath_js_1 = _castPath;
	var _copyObject_js_1 = _copyObject;
	var _customOmitClone_js_1 = _customOmitClone;
	var _flatRest_js_1 = _flatRest;
	var _getAllKeysIn_js_1 = _getAllKeysIn;
	var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
	var omit = _flatRest_js_1.default(function (object, paths) {
	    var result = {};
	    if (object == null) {
	        return result;
	    }
	    var isDeep = false;
	    paths = _arrayMap_js_1.default(paths, function (path) {
	        path = _castPath_js_1.default(path, object);
	        isDeep || (isDeep = path.length > 1);
	        return path;
	    });
	    _copyObject_js_1.default(object, _getAllKeysIn_js_1.default(object), result);
	    if (isDeep) {
	        result = _baseClone_js_1.default(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, _customOmitClone_js_1.default);
	    }
	    var length = paths.length;
	    while (length--) {
	        _baseUnset_js_1.default(result, paths[length]);
	    }
	    return result;
	});
	exports.default = omit;
	});

	var _baseSet = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _assignValue_js_1 = _assignValue;
	var _castPath_js_1 = _castPath;
	var _isIndex_js_1 = _isIndex;
	var isObject_js_1 = isObject_1;
	var _toKey_js_1 = _toKey;
	function baseSet(object, path, value, customizer) {
	    if (!isObject_js_1.default(object)) {
	        return object;
	    }
	    path = _castPath_js_1.default(path, object);
	    var index = -1, length = path.length, lastIndex = length - 1, nested = object;
	    while (nested != null && ++index < length) {
	        var key = _toKey_js_1.default(path[index]), newValue = value;
	        if (index != lastIndex) {
	            var objValue = nested[key];
	            newValue = customizer ? customizer(objValue, key, nested) : undefined;
	            if (newValue === undefined) {
	                newValue = isObject_js_1.default(objValue)
	                    ? objValue
	                    : (_isIndex_js_1.default(path[index + 1]) ? [] : {});
	            }
	        }
	        _assignValue_js_1.default(nested, key, newValue);
	        nested = nested[key];
	    }
	    return object;
	}
	exports.default = baseSet;
	});

	var _basePickBy = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseGet_js_1 = _baseGet;
	var _baseSet_js_1 = _baseSet;
	var _castPath_js_1 = _castPath;
	function basePickBy(object, paths, predicate) {
	    var index = -1, length = paths.length, result = {};
	    while (++index < length) {
	        var path = paths[index], value = _baseGet_js_1.default(object, path);
	        if (predicate(value, path)) {
	            _baseSet_js_1.default(result, _castPath_js_1.default(path, object), value);
	        }
	    }
	    return result;
	}
	exports.default = basePickBy;
	});

	var pickBy_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _arrayMap_js_1 = _arrayMap;
	var _baseIteratee_js_1 = _baseIteratee;
	var _basePickBy_js_1 = _basePickBy;
	var _getAllKeysIn_js_1 = _getAllKeysIn;
	function pickBy(object, predicate) {
	    if (object == null) {
	        return {};
	    }
	    var props = _arrayMap_js_1.default(_getAllKeysIn_js_1.default(object), function (prop) {
	        return [prop];
	    });
	    predicate = _baseIteratee_js_1.default(predicate);
	    return _basePickBy_js_1.default(object, props, function (value, path) {
	        return predicate(value, path[0]);
	    });
	}
	exports.default = pickBy;
	});

	var omitBy_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseIteratee_js_1 = _baseIteratee;
	var negate_js_1 = negate_1;
	var pickBy_js_1 = pickBy_1;
	function omitBy(object, predicate) {
	    return pickBy_js_1.default(object, negate_js_1.default(_baseIteratee_js_1.default(predicate)));
	}
	exports.default = omitBy;
	});

	var once_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var before_js_1 = before_1;
	function once(func) {
	    return before_js_1.default(2, func);
	}
	exports.default = once;
	});

	var _baseSortBy = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	function baseSortBy(array, comparer) {
	    var length = array.length;
	    array.sort(comparer);
	    while (length--) {
	        array[length] = array[length].value;
	    }
	    return array;
	}
	exports.default = baseSortBy;
	});

	var _compareAscending = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var isSymbol_js_1 = isSymbol_1;
	function compareAscending(value, other) {
	    if (value !== other) {
	        var valIsDefined = value !== undefined, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol_js_1.default(value);
	        var othIsDefined = other !== undefined, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol_js_1.default(other);
	        if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||
	            (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||
	            (valIsNull && othIsDefined && othIsReflexive) ||
	            (!valIsDefined && othIsReflexive) ||
	            !valIsReflexive) {
	            return 1;
	        }
	        if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||
	            (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||
	            (othIsNull && valIsDefined && valIsReflexive) ||
	            (!othIsDefined && valIsReflexive) ||
	            !othIsReflexive) {
	            return -1;
	        }
	    }
	    return 0;
	}
	exports.default = compareAscending;
	});

	var _compareMultiple = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _compareAscending_js_1 = _compareAscending;
	function compareMultiple(object, other, orders) {
	    var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
	    while (++index < length) {
	        var result = _compareAscending_js_1.default(objCriteria[index], othCriteria[index]);
	        if (result) {
	            if (index >= ordersLength) {
	                return result;
	            }
	            var order = orders[index];
	            return result * (order == 'desc' ? -1 : 1);
	        }
	    }
	    return object.index - other.index;
	}
	exports.default = compareMultiple;
	});

	var _baseOrderBy = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _arrayMap_js_1 = _arrayMap;
	var _baseIteratee_js_1 = _baseIteratee;
	var _baseMap_js_1 = _baseMap;
	var _baseSortBy_js_1 = _baseSortBy;
	var _baseUnary_js_1 = _baseUnary;
	var _compareMultiple_js_1 = _compareMultiple;
	var identity_js_1 = identity_1;
	function baseOrderBy(collection, iteratees, orders) {
	    var index = -1;
	    iteratees = _arrayMap_js_1.default(iteratees.length ? iteratees : [identity_js_1.default], _baseUnary_js_1.default(_baseIteratee_js_1.default));
	    var result = _baseMap_js_1.default(collection, function (value, key, collection) {
	        var criteria = _arrayMap_js_1.default(iteratees, function (iteratee) {
	            return iteratee(value);
	        });
	        return { 'criteria': criteria, 'index': ++index, 'value': value };
	    });
	    return _baseSortBy_js_1.default(result, function (object, other) {
	        return _compareMultiple_js_1.default(object, other, orders);
	    });
	}
	exports.default = baseOrderBy;
	});

	var orderBy_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseOrderBy_js_1 = _baseOrderBy;
	var isArray_js_1 = isArray_1;
	function orderBy(collection, iteratees, orders, guard) {
	    if (collection == null) {
	        return [];
	    }
	    if (!isArray_js_1.default(iteratees)) {
	        iteratees = iteratees == null ? [] : [iteratees];
	    }
	    orders = guard ? undefined : orders;
	    if (!isArray_js_1.default(orders)) {
	        orders = orders == null ? [] : [orders];
	    }
	    return _baseOrderBy_js_1.default(collection, iteratees, orders);
	}
	exports.default = orderBy;
	});

	var _createOver = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _apply_js_1 = _apply;
	var _arrayMap_js_1 = _arrayMap;
	var _baseIteratee_js_1 = _baseIteratee;
	var _baseRest_js_1 = _baseRest;
	var _baseUnary_js_1 = _baseUnary;
	var _flatRest_js_1 = _flatRest;
	function createOver(arrayFunc) {
	    return _flatRest_js_1.default(function (iteratees) {
	        iteratees = _arrayMap_js_1.default(iteratees, _baseUnary_js_1.default(_baseIteratee_js_1.default));
	        return _baseRest_js_1.default(function (args) {
	            var thisArg = this;
	            return arrayFunc(iteratees, function (iteratee) {
	                return _apply_js_1.default(iteratee, thisArg, args);
	            });
	        });
	    });
	}
	exports.default = createOver;
	});

	var over_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _arrayMap_js_1 = _arrayMap;
	var _createOver_js_1 = _createOver;
	var over = _createOver_js_1.default(_arrayMap_js_1.default);
	exports.default = over;
	});

	var _castRest = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseRest_js_1 = _baseRest;
	var castRest = _baseRest_js_1.default;
	exports.default = castRest;
	});

	var overArgs_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _apply_js_1 = _apply;
	var _arrayMap_js_1 = _arrayMap;
	var _baseFlatten_js_1 = _baseFlatten;
	var _baseIteratee_js_1 = _baseIteratee;
	var _baseRest_js_1 = _baseRest;
	var _baseUnary_js_1 = _baseUnary;
	var _castRest_js_1 = _castRest;
	var isArray_js_1 = isArray_1;
	var nativeMin = Math.min;
	var overArgs = _castRest_js_1.default(function (func, transforms) {
	    transforms = (transforms.length == 1 && isArray_js_1.default(transforms[0]))
	        ? _arrayMap_js_1.default(transforms[0], _baseUnary_js_1.default(_baseIteratee_js_1.default))
	        : _arrayMap_js_1.default(_baseFlatten_js_1.default(transforms, 1), _baseUnary_js_1.default(_baseIteratee_js_1.default));
	    var funcsLength = transforms.length;
	    return _baseRest_js_1.default(function (args) {
	        var index = -1, length = nativeMin(args.length, funcsLength);
	        while (++index < length) {
	            args[index] = transforms[index].call(this, args[index]);
	        }
	        return _apply_js_1.default(func, this, args);
	    });
	});
	exports.default = overArgs;
	});

	var overEvery_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _arrayEvery_js_1 = _arrayEvery;
	var _createOver_js_1 = _createOver;
	var overEvery = _createOver_js_1.default(_arrayEvery_js_1.default);
	exports.default = overEvery;
	});

	var overSome_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _arraySome_js_1 = _arraySome;
	var _createOver_js_1 = _createOver;
	var overSome = _createOver_js_1.default(_arraySome_js_1.default);
	exports.default = overSome;
	});

	var _baseRepeat = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var MAX_SAFE_INTEGER = 9007199254740991;
	var nativeFloor = Math.floor;
	function baseRepeat(string, n) {
	    var result = '';
	    if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
	        return result;
	    }
	    do {
	        if (n % 2) {
	            result += string;
	        }
	        n = nativeFloor(n / 2);
	        if (n) {
	            string += string;
	        }
	    } while (n);
	    return result;
	}
	exports.default = baseRepeat;
	});

	var _asciiSize = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseProperty_js_1 = _baseProperty;
	var asciiSize = _baseProperty_js_1.default('length');
	exports.default = asciiSize;
	});

	var _unicodeSize = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var rsAstralRange = '\\ud800-\\udfff', rsComboMarksRange = '\\u0300-\\u036f', reComboHalfMarksRange = '\\ufe20-\\ufe2f', rsComboSymbolsRange = '\\u20d0-\\u20ff', rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsVarRange = '\\ufe0e\\ufe0f';
	var rsAstral = '[' + rsAstralRange + ']', rsCombo = '[' + rsComboRange + ']', rsFitz = '\\ud83c[\\udffb-\\udfff]', rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')', rsNonAstral = '[^' + rsAstralRange + ']', rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}', rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]', rsZWJ = '\\u200d';
	var reOptMod = rsModifier + '?', rsOptVar = '[' + rsVarRange + ']?', rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*', rsSeq = rsOptVar + reOptMod + rsOptJoin, rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';
	var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');
	function unicodeSize(string) {
	    var result = reUnicode.lastIndex = 0;
	    while (reUnicode.test(string)) {
	        ++result;
	    }
	    return result;
	}
	exports.default = unicodeSize;
	});

	var _stringSize = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _asciiSize_js_1 = _asciiSize;
	var _hasUnicode_js_1 = _hasUnicode;
	var _unicodeSize_js_1 = _unicodeSize;
	function stringSize(string) {
	    return _hasUnicode_js_1.default(string)
	        ? _unicodeSize_js_1.default(string)
	        : _asciiSize_js_1.default(string);
	}
	exports.default = stringSize;
	});

	var _createPadding = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseRepeat_js_1 = _baseRepeat;
	var _baseToString_js_1 = _baseToString;
	var _castSlice_js_1 = _castSlice;
	var _hasUnicode_js_1 = _hasUnicode;
	var _stringSize_js_1 = _stringSize;
	var _stringToArray_js_1 = _stringToArray;
	var nativeCeil = Math.ceil;
	function createPadding(length, chars) {
	    chars = chars === undefined ? ' ' : _baseToString_js_1.default(chars);
	    var charsLength = chars.length;
	    if (charsLength < 2) {
	        return charsLength ? _baseRepeat_js_1.default(chars, length) : chars;
	    }
	    var result = _baseRepeat_js_1.default(chars, nativeCeil(length / _stringSize_js_1.default(chars)));
	    return _hasUnicode_js_1.default(chars)
	        ? _castSlice_js_1.default(_stringToArray_js_1.default(result), 0, length).join('')
	        : result.slice(0, length);
	}
	exports.default = createPadding;
	});

	var pad_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _createPadding_js_1 = _createPadding;
	var _stringSize_js_1 = _stringSize;
	var toInteger_js_1 = toInteger_1;
	var toString_js_1 = toString_1;
	var nativeCeil = Math.ceil, nativeFloor = Math.floor;
	function pad(string, length, chars) {
	    string = toString_js_1.default(string);
	    length = toInteger_js_1.default(length);
	    var strLength = length ? _stringSize_js_1.default(string) : 0;
	    if (!length || strLength >= length) {
	        return string;
	    }
	    var mid = (length - strLength) / 2;
	    return (_createPadding_js_1.default(nativeFloor(mid), chars) +
	        string +
	        _createPadding_js_1.default(nativeCeil(mid), chars));
	}
	exports.default = pad;
	});

	var padEnd_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _createPadding_js_1 = _createPadding;
	var _stringSize_js_1 = _stringSize;
	var toInteger_js_1 = toInteger_1;
	var toString_js_1 = toString_1;
	function padEnd(string, length, chars) {
	    string = toString_js_1.default(string);
	    length = toInteger_js_1.default(length);
	    var strLength = length ? _stringSize_js_1.default(string) : 0;
	    return (length && strLength < length)
	        ? (string + _createPadding_js_1.default(length - strLength, chars))
	        : string;
	}
	exports.default = padEnd;
	});

	var padStart_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _createPadding_js_1 = _createPadding;
	var _stringSize_js_1 = _stringSize;
	var toInteger_js_1 = toInteger_1;
	var toString_js_1 = toString_1;
	function padStart(string, length, chars) {
	    string = toString_js_1.default(string);
	    length = toInteger_js_1.default(length);
	    var strLength = length ? _stringSize_js_1.default(string) : 0;
	    return (length && strLength < length)
	        ? (_createPadding_js_1.default(length - strLength, chars) + string)
	        : string;
	}
	exports.default = padStart;
	});

	var _parseInt = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _root_js_1 = _root;
	var toString_js_1 = toString_1;
	var reTrimStart = /^\s+/;
	var nativeParseInt = _root_js_1.default.parseInt;
	function parseInt(string, radix, guard) {
	    if (guard || radix == null) {
	        radix = 0;
	    }
	    else if (radix) {
	        radix = +radix;
	    }
	    return nativeParseInt(toString_js_1.default(string).replace(reTrimStart, ''), radix || 0);
	}
	exports.default = parseInt;
	});

	var partial_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseRest_js_1 = _baseRest;
	var _createWrap_js_1 = _createWrap;
	var _getHolder_js_1 = _getHolder;
	var _replaceHolders_js_1 = _replaceHolders;
	var WRAP_PARTIAL_FLAG = 32;
	var partial = _baseRest_js_1.default(function (func, partials) {
	    var holders = _replaceHolders_js_1.default(partials, _getHolder_js_1.default(partial));
	    return _createWrap_js_1.default(func, WRAP_PARTIAL_FLAG, undefined, partials, holders);
	});
	partial.placeholder = {};
	exports.default = partial;
	});

	var partialRight_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseRest_js_1 = _baseRest;
	var _createWrap_js_1 = _createWrap;
	var _getHolder_js_1 = _getHolder;
	var _replaceHolders_js_1 = _replaceHolders;
	var WRAP_PARTIAL_RIGHT_FLAG = 64;
	var partialRight = _baseRest_js_1.default(function (func, partials) {
	    var holders = _replaceHolders_js_1.default(partials, _getHolder_js_1.default(partialRight));
	    return _createWrap_js_1.default(func, WRAP_PARTIAL_RIGHT_FLAG, undefined, partials, holders);
	});
	partialRight.placeholder = {};
	exports.default = partialRight;
	});

	var partition_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _createAggregator_js_1 = _createAggregator;
	var partition = _createAggregator_js_1.default(function (result, value, key) {
	    result[key ? 0 : 1].push(value);
	}, function () { return [[], []]; });
	exports.default = partition;
	});

	var _basePick = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _basePickBy_js_1 = _basePickBy;
	var hasIn_js_1 = hasIn_1;
	function basePick(object, paths) {
	    return _basePickBy_js_1.default(object, paths, function (value, path) {
	        return hasIn_js_1.default(object, path);
	    });
	}
	exports.default = basePick;
	});

	var pick_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _basePick_js_1 = _basePick;
	var _flatRest_js_1 = _flatRest;
	var pick = _flatRest_js_1.default(function (object, paths) {
	    return object == null ? {} : _basePick_js_1.default(object, paths);
	});
	exports.default = pick;
	});

	var plant = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseLodash_js_1 = _baseLodash;
	var _wrapperClone_js_1 = _wrapperClone;
	function wrapperPlant(value) {
	    var result, parent = this;
	    while (parent instanceof _baseLodash_js_1.default) {
	        var clone = _wrapperClone_js_1.default(parent);
	        clone.__index__ = 0;
	        clone.__values__ = undefined;
	        if (result) {
	            previous.__wrapped__ = clone;
	        }
	        else {
	            result = clone;
	        }
	        var previous = clone;
	        parent = parent.__wrapped__;
	    }
	    previous.__wrapped__ = value;
	    return result;
	}
	exports.default = wrapperPlant;
	});

	var propertyOf_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseGet_js_1 = _baseGet;
	function propertyOf(object) {
	    return function (path) {
	        return object == null ? undefined : _baseGet_js_1.default(object, path);
	    };
	}
	exports.default = propertyOf;
	});

	var _baseIndexOfWith = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	function baseIndexOfWith(array, value, fromIndex, comparator) {
	    var index = fromIndex - 1, length = array.length;
	    while (++index < length) {
	        if (comparator(array[index], value)) {
	            return index;
	        }
	    }
	    return -1;
	}
	exports.default = baseIndexOfWith;
	});

	var _basePullAll = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _arrayMap_js_1 = _arrayMap;
	var _baseIndexOf_js_1 = _baseIndexOf;
	var _baseIndexOfWith_js_1 = _baseIndexOfWith;
	var _baseUnary_js_1 = _baseUnary;
	var _copyArray_js_1 = _copyArray;
	var arrayProto = Array.prototype;
	var splice = arrayProto.splice;
	function basePullAll(array, values, iteratee, comparator) {
	    var indexOf = comparator ? _baseIndexOfWith_js_1.default : _baseIndexOf_js_1.default, index = -1, length = values.length, seen = array;
	    if (array === values) {
	        values = _copyArray_js_1.default(values);
	    }
	    if (iteratee) {
	        seen = _arrayMap_js_1.default(array, _baseUnary_js_1.default(iteratee));
	    }
	    while (++index < length) {
	        var fromIndex = 0, value = values[index], computed = iteratee ? iteratee(value) : value;
	        while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
	            if (seen !== array) {
	                splice.call(seen, fromIndex, 1);
	            }
	            splice.call(array, fromIndex, 1);
	        }
	    }
	    return array;
	}
	exports.default = basePullAll;
	});

	var pullAll_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _basePullAll_js_1 = _basePullAll;
	function pullAll(array, values) {
	    return (array && array.length && values && values.length)
	        ? _basePullAll_js_1.default(array, values)
	        : array;
	}
	exports.default = pullAll;
	});

	var pull_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseRest_js_1 = _baseRest;
	var pullAll_js_1 = pullAll_1;
	var pull = _baseRest_js_1.default(pullAll_js_1.default);
	exports.default = pull;
	});

	var pullAllBy_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseIteratee_js_1 = _baseIteratee;
	var _basePullAll_js_1 = _basePullAll;
	function pullAllBy(array, values, iteratee) {
	    return (array && array.length && values && values.length)
	        ? _basePullAll_js_1.default(array, values, _baseIteratee_js_1.default(iteratee, 2))
	        : array;
	}
	exports.default = pullAllBy;
	});

	var pullAllWith_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _basePullAll_js_1 = _basePullAll;
	function pullAllWith(array, values, comparator) {
	    return (array && array.length && values && values.length)
	        ? _basePullAll_js_1.default(array, values, undefined, comparator)
	        : array;
	}
	exports.default = pullAllWith;
	});

	var _basePullAt = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseUnset_js_1 = _baseUnset;
	var _isIndex_js_1 = _isIndex;
	var arrayProto = Array.prototype;
	var splice = arrayProto.splice;
	function basePullAt(array, indexes) {
	    var length = array ? indexes.length : 0, lastIndex = length - 1;
	    while (length--) {
	        var index = indexes[length];
	        if (length == lastIndex || index !== previous) {
	            var previous = index;
	            if (_isIndex_js_1.default(index)) {
	                splice.call(array, index, 1);
	            }
	            else {
	                _baseUnset_js_1.default(array, index);
	            }
	        }
	    }
	    return array;
	}
	exports.default = basePullAt;
	});

	var pullAt_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _arrayMap_js_1 = _arrayMap;
	var _baseAt_js_1 = _baseAt;
	var _basePullAt_js_1 = _basePullAt;
	var _compareAscending_js_1 = _compareAscending;
	var _flatRest_js_1 = _flatRest;
	var _isIndex_js_1 = _isIndex;
	var pullAt = _flatRest_js_1.default(function (array, indexes) {
	    var length = array == null ? 0 : array.length, result = _baseAt_js_1.default(array, indexes);
	    _basePullAt_js_1.default(array, _arrayMap_js_1.default(indexes, function (index) {
	        return _isIndex_js_1.default(index, length) ? +index : index;
	    }).sort(_compareAscending_js_1.default));
	    return result;
	});
	exports.default = pullAt;
	});

	var _baseRandom = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var nativeFloor = Math.floor, nativeRandom = Math.random;
	function baseRandom(lower, upper) {
	    return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
	}
	exports.default = baseRandom;
	});

	var random_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseRandom_js_1 = _baseRandom;
	var _isIterateeCall_js_1 = _isIterateeCall;
	var toFinite_js_1 = toFinite_1;
	var freeParseFloat = parseFloat;
	var nativeMin = Math.min, nativeRandom = Math.random;
	function random(lower, upper, floating) {
	    if (floating && typeof floating != 'boolean' && _isIterateeCall_js_1.default(lower, upper, floating)) {
	        upper = floating = undefined;
	    }
	    if (floating === undefined) {
	        if (typeof upper == 'boolean') {
	            floating = upper;
	            upper = undefined;
	        }
	        else if (typeof lower == 'boolean') {
	            floating = lower;
	            lower = undefined;
	        }
	    }
	    if (lower === undefined && upper === undefined) {
	        lower = 0;
	        upper = 1;
	    }
	    else {
	        lower = toFinite_js_1.default(lower);
	        if (upper === undefined) {
	            upper = lower;
	            lower = 0;
	        }
	        else {
	            upper = toFinite_js_1.default(upper);
	        }
	    }
	    if (lower > upper) {
	        var temp = lower;
	        lower = upper;
	        upper = temp;
	    }
	    if (floating || lower % 1 || upper % 1) {
	        var rand = nativeRandom();
	        return nativeMin(lower + (rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1)))), upper);
	    }
	    return _baseRandom_js_1.default(lower, upper);
	}
	exports.default = random;
	});

	var _baseRange = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var nativeCeil = Math.ceil, nativeMax = Math.max;
	function baseRange(start, end, step, fromRight) {
	    var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result = Array(length);
	    while (length--) {
	        result[fromRight ? length : ++index] = start;
	        start += step;
	    }
	    return result;
	}
	exports.default = baseRange;
	});

	var _createRange = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseRange_js_1 = _baseRange;
	var _isIterateeCall_js_1 = _isIterateeCall;
	var toFinite_js_1 = toFinite_1;
	function createRange(fromRight) {
	    return function (start, end, step) {
	        if (step && typeof step != 'number' && _isIterateeCall_js_1.default(start, end, step)) {
	            end = step = undefined;
	        }
	        start = toFinite_js_1.default(start);
	        if (end === undefined) {
	            end = start;
	            start = 0;
	        }
	        else {
	            end = toFinite_js_1.default(end);
	        }
	        step = step === undefined ? (start < end ? 1 : -1) : toFinite_js_1.default(step);
	        return _baseRange_js_1.default(start, end, step, fromRight);
	    };
	}
	exports.default = createRange;
	});

	var range_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _createRange_js_1 = _createRange;
	var range = _createRange_js_1.default();
	exports.default = range;
	});

	var rangeRight_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _createRange_js_1 = _createRange;
	var rangeRight = _createRange_js_1.default(true);
	exports.default = rangeRight;
	});

	var rearg_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _createWrap_js_1 = _createWrap;
	var _flatRest_js_1 = _flatRest;
	var WRAP_REARG_FLAG = 256;
	var rearg = _flatRest_js_1.default(function (func, indexes) {
	    return _createWrap_js_1.default(func, WRAP_REARG_FLAG, undefined, undefined, undefined, indexes);
	});
	exports.default = rearg;
	});

	var _baseReduce = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
	    eachFunc(collection, function (value, index, collection) {
	        accumulator = initAccum
	            ? (initAccum = false, value)
	            : iteratee(accumulator, value, index, collection);
	    });
	    return accumulator;
	}
	exports.default = baseReduce;
	});

	var reduce_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _arrayReduce_js_1 = _arrayReduce;
	var _baseEach_js_1 = _baseEach;
	var _baseIteratee_js_1 = _baseIteratee;
	var _baseReduce_js_1 = _baseReduce;
	var isArray_js_1 = isArray_1;
	function reduce(collection, iteratee, accumulator) {
	    var func = isArray_js_1.default(collection) ? _arrayReduce_js_1.default : _baseReduce_js_1.default, initAccum = arguments.length < 3;
	    return func(collection, _baseIteratee_js_1.default(iteratee, 4), accumulator, initAccum, _baseEach_js_1.default);
	}
	exports.default = reduce;
	});

	var _arrayReduceRight = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	function arrayReduceRight(array, iteratee, accumulator, initAccum) {
	    var length = array == null ? 0 : array.length;
	    if (initAccum && length) {
	        accumulator = array[--length];
	    }
	    while (length--) {
	        accumulator = iteratee(accumulator, array[length], length, array);
	    }
	    return accumulator;
	}
	exports.default = arrayReduceRight;
	});

	var reduceRight_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _arrayReduceRight_js_1 = _arrayReduceRight;
	var _baseEachRight_js_1 = _baseEachRight;
	var _baseIteratee_js_1 = _baseIteratee;
	var _baseReduce_js_1 = _baseReduce;
	var isArray_js_1 = isArray_1;
	function reduceRight(collection, iteratee, accumulator) {
	    var func = isArray_js_1.default(collection) ? _arrayReduceRight_js_1.default : _baseReduce_js_1.default, initAccum = arguments.length < 3;
	    return func(collection, _baseIteratee_js_1.default(iteratee, 4), accumulator, initAccum, _baseEachRight_js_1.default);
	}
	exports.default = reduceRight;
	});

	var reject_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _arrayFilter_js_1 = _arrayFilter;
	var _baseFilter_js_1 = _baseFilter;
	var _baseIteratee_js_1 = _baseIteratee;
	var isArray_js_1 = isArray_1;
	var negate_js_1 = negate_1;
	function reject(collection, predicate) {
	    var func = isArray_js_1.default(collection) ? _arrayFilter_js_1.default : _baseFilter_js_1.default;
	    return func(collection, negate_js_1.default(_baseIteratee_js_1.default(predicate, 3)));
	}
	exports.default = reject;
	});

	var remove_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseIteratee_js_1 = _baseIteratee;
	var _basePullAt_js_1 = _basePullAt;
	function remove(array, predicate) {
	    var result = [];
	    if (!(array && array.length)) {
	        return result;
	    }
	    var index = -1, indexes = [], length = array.length;
	    predicate = _baseIteratee_js_1.default(predicate, 3);
	    while (++index < length) {
	        var value = array[index];
	        if (predicate(value, index, array)) {
	            result.push(value);
	            indexes.push(index);
	        }
	    }
	    _basePullAt_js_1.default(array, indexes);
	    return result;
	}
	exports.default = remove;
	});

	var repeat_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseRepeat_js_1 = _baseRepeat;
	var _isIterateeCall_js_1 = _isIterateeCall;
	var toInteger_js_1 = toInteger_1;
	var toString_js_1 = toString_1;
	function repeat(string, n, guard) {
	    if ((guard ? _isIterateeCall_js_1.default(string, n, guard) : n === undefined)) {
	        n = 1;
	    }
	    else {
	        n = toInteger_js_1.default(n);
	    }
	    return _baseRepeat_js_1.default(toString_js_1.default(string), n);
	}
	exports.default = repeat;
	});

	var replace_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var toString_js_1 = toString_1;
	function replace() {
	    var args = arguments, string = toString_js_1.default(args[0]);
	    return args.length < 3 ? string : string.replace(args[1], args[2]);
	}
	exports.default = replace;
	});

	var rest_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseRest_js_1 = _baseRest;
	var toInteger_js_1 = toInteger_1;
	var FUNC_ERROR_TEXT = 'Expected a function';
	function rest(func, start) {
	    if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	    }
	    start = start === undefined ? start : toInteger_js_1.default(start);
	    return _baseRest_js_1.default(func, start);
	}
	exports.default = rest;
	});

	var result_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _castPath_js_1 = _castPath;
	var isFunction_js_1 = isFunction_1;
	var _toKey_js_1 = _toKey;
	function result(object, path, defaultValue) {
	    path = _castPath_js_1.default(path, object);
	    var index = -1, length = path.length;
	    if (!length) {
	        length = 1;
	        object = undefined;
	    }
	    while (++index < length) {
	        var value = object == null ? undefined : object[_toKey_js_1.default(path[index])];
	        if (value === undefined) {
	            index = length;
	            value = defaultValue;
	        }
	        object = isFunction_js_1.default(value) ? value.call(object) : value;
	    }
	    return object;
	}
	exports.default = result;
	});

	var reverse_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var arrayProto = Array.prototype;
	var nativeReverse = arrayProto.reverse;
	function reverse(array) {
	    return array == null ? array : nativeReverse.call(array);
	}
	exports.default = reverse;
	});

	var round_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _createRound_js_1 = _createRound;
	var round = _createRound_js_1.default('round');
	exports.default = round;
	});

	var _arraySample = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseRandom_js_1 = _baseRandom;
	function arraySample(array) {
	    var length = array.length;
	    return length ? array[_baseRandom_js_1.default(0, length - 1)] : undefined;
	}
	exports.default = arraySample;
	});

	var _baseSample = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _arraySample_js_1 = _arraySample;
	var values_js_1 = values_1;
	function baseSample(collection) {
	    return _arraySample_js_1.default(values_js_1.default(collection));
	}
	exports.default = baseSample;
	});

	var sample_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _arraySample_js_1 = _arraySample;
	var _baseSample_js_1 = _baseSample;
	var isArray_js_1 = isArray_1;
	function sample(collection) {
	    var func = isArray_js_1.default(collection) ? _arraySample_js_1.default : _baseSample_js_1.default;
	    return func(collection);
	}
	exports.default = sample;
	});

	var _shuffleSelf = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseRandom_js_1 = _baseRandom;
	function shuffleSelf(array, size) {
	    var index = -1, length = array.length, lastIndex = length - 1;
	    size = size === undefined ? length : size;
	    while (++index < size) {
	        var rand = _baseRandom_js_1.default(index, lastIndex), value = array[rand];
	        array[rand] = array[index];
	        array[index] = value;
	    }
	    array.length = size;
	    return array;
	}
	exports.default = shuffleSelf;
	});

	var _arraySampleSize = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseClamp_js_1 = _baseClamp;
	var _copyArray_js_1 = _copyArray;
	var _shuffleSelf_js_1 = _shuffleSelf;
	function arraySampleSize(array, n) {
	    return _shuffleSelf_js_1.default(_copyArray_js_1.default(array), _baseClamp_js_1.default(n, 0, array.length));
	}
	exports.default = arraySampleSize;
	});

	var _baseSampleSize = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseClamp_js_1 = _baseClamp;
	var _shuffleSelf_js_1 = _shuffleSelf;
	var values_js_1 = values_1;
	function baseSampleSize(collection, n) {
	    var array = values_js_1.default(collection);
	    return _shuffleSelf_js_1.default(array, _baseClamp_js_1.default(n, 0, array.length));
	}
	exports.default = baseSampleSize;
	});

	var sampleSize_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _arraySampleSize_js_1 = _arraySampleSize;
	var _baseSampleSize_js_1 = _baseSampleSize;
	var isArray_js_1 = isArray_1;
	var _isIterateeCall_js_1 = _isIterateeCall;
	var toInteger_js_1 = toInteger_1;
	function sampleSize(collection, n, guard) {
	    if ((guard ? _isIterateeCall_js_1.default(collection, n, guard) : n === undefined)) {
	        n = 1;
	    }
	    else {
	        n = toInteger_js_1.default(n);
	    }
	    var func = isArray_js_1.default(collection) ? _arraySampleSize_js_1.default : _baseSampleSize_js_1.default;
	    return func(collection, n);
	}
	exports.default = sampleSize;
	});

	var set_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseSet_js_1 = _baseSet;
	function set(object, path, value) {
	    return object == null ? object : _baseSet_js_1.default(object, path, value);
	}
	exports.default = set;
	});

	var setWith_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseSet_js_1 = _baseSet;
	function setWith(object, path, value, customizer) {
	    customizer = typeof customizer == 'function' ? customizer : undefined;
	    return object == null ? object : _baseSet_js_1.default(object, path, value, customizer);
	}
	exports.default = setWith;
	});

	var _arrayShuffle = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _copyArray_js_1 = _copyArray;
	var _shuffleSelf_js_1 = _shuffleSelf;
	function arrayShuffle(array) {
	    return _shuffleSelf_js_1.default(_copyArray_js_1.default(array));
	}
	exports.default = arrayShuffle;
	});

	var _baseShuffle = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _shuffleSelf_js_1 = _shuffleSelf;
	var values_js_1 = values_1;
	function baseShuffle(collection) {
	    return _shuffleSelf_js_1.default(values_js_1.default(collection));
	}
	exports.default = baseShuffle;
	});

	var shuffle_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _arrayShuffle_js_1 = _arrayShuffle;
	var _baseShuffle_js_1 = _baseShuffle;
	var isArray_js_1 = isArray_1;
	function shuffle(collection) {
	    var func = isArray_js_1.default(collection) ? _arrayShuffle_js_1.default : _baseShuffle_js_1.default;
	    return func(collection);
	}
	exports.default = shuffle;
	});

	var size_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseKeys_js_1 = _baseKeys;
	var _getTag_js_1 = _getTag;
	var isArrayLike_js_1 = isArrayLike_1;
	var isString_js_1 = isString_1;
	var _stringSize_js_1 = _stringSize;
	var mapTag = '[object Map]', setTag = '[object Set]';
	function size(collection) {
	    if (collection == null) {
	        return 0;
	    }
	    if (isArrayLike_js_1.default(collection)) {
	        return isString_js_1.default(collection) ? _stringSize_js_1.default(collection) : collection.length;
	    }
	    var tag = _getTag_js_1.default(collection);
	    if (tag == mapTag || tag == setTag) {
	        return collection.size;
	    }
	    return _baseKeys_js_1.default(collection).length;
	}
	exports.default = size;
	});

	var slice_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseSlice_js_1 = _baseSlice;
	var _isIterateeCall_js_1 = _isIterateeCall;
	var toInteger_js_1 = toInteger_1;
	function slice(array, start, end) {
	    var length = array == null ? 0 : array.length;
	    if (!length) {
	        return [];
	    }
	    if (end && typeof end != 'number' && _isIterateeCall_js_1.default(array, start, end)) {
	        start = 0;
	        end = length;
	    }
	    else {
	        start = start == null ? 0 : toInteger_js_1.default(start);
	        end = end === undefined ? length : toInteger_js_1.default(end);
	    }
	    return _baseSlice_js_1.default(array, start, end);
	}
	exports.default = slice;
	});

	var snakeCase_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _createCompounder_js_1 = _createCompounder;
	var snakeCase = _createCompounder_js_1.default(function (result, word, index) {
	    return result + (index ? '_' : '') + word.toLowerCase();
	});
	exports.default = snakeCase;
	});

	var _baseSome = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseEach_js_1 = _baseEach;
	function baseSome(collection, predicate) {
	    var result;
	    _baseEach_js_1.default(collection, function (value, index, collection) {
	        result = predicate(value, index, collection);
	        return !result;
	    });
	    return !!result;
	}
	exports.default = baseSome;
	});

	var some_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _arraySome_js_1 = _arraySome;
	var _baseIteratee_js_1 = _baseIteratee;
	var _baseSome_js_1 = _baseSome;
	var isArray_js_1 = isArray_1;
	var _isIterateeCall_js_1 = _isIterateeCall;
	function some(collection, predicate, guard) {
	    var func = isArray_js_1.default(collection) ? _arraySome_js_1.default : _baseSome_js_1.default;
	    if (guard && _isIterateeCall_js_1.default(collection, predicate, guard)) {
	        predicate = undefined;
	    }
	    return func(collection, _baseIteratee_js_1.default(predicate, 3));
	}
	exports.default = some;
	});

	var sortBy_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseFlatten_js_1 = _baseFlatten;
	var _baseOrderBy_js_1 = _baseOrderBy;
	var _baseRest_js_1 = _baseRest;
	var _isIterateeCall_js_1 = _isIterateeCall;
	var sortBy = _baseRest_js_1.default(function (collection, iteratees) {
	    if (collection == null) {
	        return [];
	    }
	    var length = iteratees.length;
	    if (length > 1 && _isIterateeCall_js_1.default(collection, iteratees[0], iteratees[1])) {
	        iteratees = [];
	    }
	    else if (length > 2 && _isIterateeCall_js_1.default(iteratees[0], iteratees[1], iteratees[2])) {
	        iteratees = [iteratees[0]];
	    }
	    return _baseOrderBy_js_1.default(collection, _baseFlatten_js_1.default(iteratees, 1), []);
	});
	exports.default = sortBy;
	});

	var _baseSortedIndexBy = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var isSymbol_js_1 = isSymbol_1;
	var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1;
	var nativeFloor = Math.floor, nativeMin = Math.min;
	function baseSortedIndexBy(array, value, iteratee, retHighest) {
	    value = iteratee(value);
	    var low = 0, high = array == null ? 0 : array.length, valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol_js_1.default(value), valIsUndefined = value === undefined;
	    while (low < high) {
	        var mid = nativeFloor((low + high) / 2), computed = iteratee(array[mid]), othIsDefined = computed !== undefined, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol_js_1.default(computed);
	        if (valIsNaN) {
	            var setLow = retHighest || othIsReflexive;
	        }
	        else if (valIsUndefined) {
	            setLow = othIsReflexive && (retHighest || othIsDefined);
	        }
	        else if (valIsNull) {
	            setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
	        }
	        else if (valIsSymbol) {
	            setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
	        }
	        else if (othIsNull || othIsSymbol) {
	            setLow = false;
	        }
	        else {
	            setLow = retHighest ? (computed <= value) : (computed < value);
	        }
	        if (setLow) {
	            low = mid + 1;
	        }
	        else {
	            high = mid;
	        }
	    }
	    return nativeMin(high, MAX_ARRAY_INDEX);
	}
	exports.default = baseSortedIndexBy;
	});

	var _baseSortedIndex = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseSortedIndexBy_js_1 = _baseSortedIndexBy;
	var identity_js_1 = identity_1;
	var isSymbol_js_1 = isSymbol_1;
	var MAX_ARRAY_LENGTH = 4294967295, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
	function baseSortedIndex(array, value, retHighest) {
	    var low = 0, high = array == null ? low : array.length;
	    if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
	        while (low < high) {
	            var mid = (low + high) >>> 1, computed = array[mid];
	            if (computed !== null && !isSymbol_js_1.default(computed) &&
	                (retHighest ? (computed <= value) : (computed < value))) {
	                low = mid + 1;
	            }
	            else {
	                high = mid;
	            }
	        }
	        return high;
	    }
	    return _baseSortedIndexBy_js_1.default(array, value, identity_js_1.default, retHighest);
	}
	exports.default = baseSortedIndex;
	});

	var sortedIndex_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseSortedIndex_js_1 = _baseSortedIndex;
	function sortedIndex(array, value) {
	    return _baseSortedIndex_js_1.default(array, value);
	}
	exports.default = sortedIndex;
	});

	var sortedIndexBy_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseIteratee_js_1 = _baseIteratee;
	var _baseSortedIndexBy_js_1 = _baseSortedIndexBy;
	function sortedIndexBy(array, value, iteratee) {
	    return _baseSortedIndexBy_js_1.default(array, value, _baseIteratee_js_1.default(iteratee, 2));
	}
	exports.default = sortedIndexBy;
	});

	var sortedIndexOf_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseSortedIndex_js_1 = _baseSortedIndex;
	var eq_js_1 = eq_1;
	function sortedIndexOf(array, value) {
	    var length = array == null ? 0 : array.length;
	    if (length) {
	        var index = _baseSortedIndex_js_1.default(array, value);
	        if (index < length && eq_js_1.default(array[index], value)) {
	            return index;
	        }
	    }
	    return -1;
	}
	exports.default = sortedIndexOf;
	});

	var sortedLastIndex_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseSortedIndex_js_1 = _baseSortedIndex;
	function sortedLastIndex(array, value) {
	    return _baseSortedIndex_js_1.default(array, value, true);
	}
	exports.default = sortedLastIndex;
	});

	var sortedLastIndexBy_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseIteratee_js_1 = _baseIteratee;
	var _baseSortedIndexBy_js_1 = _baseSortedIndexBy;
	function sortedLastIndexBy(array, value, iteratee) {
	    return _baseSortedIndexBy_js_1.default(array, value, _baseIteratee_js_1.default(iteratee, 2), true);
	}
	exports.default = sortedLastIndexBy;
	});

	var sortedLastIndexOf_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseSortedIndex_js_1 = _baseSortedIndex;
	var eq_js_1 = eq_1;
	function sortedLastIndexOf(array, value) {
	    var length = array == null ? 0 : array.length;
	    if (length) {
	        var index = _baseSortedIndex_js_1.default(array, value, true) - 1;
	        if (eq_js_1.default(array[index], value)) {
	            return index;
	        }
	    }
	    return -1;
	}
	exports.default = sortedLastIndexOf;
	});

	var _baseSortedUniq = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var eq_js_1 = eq_1;
	function baseSortedUniq(array, iteratee) {
	    var index = -1, length = array.length, resIndex = 0, result = [];
	    while (++index < length) {
	        var value = array[index], computed = iteratee ? iteratee(value) : value;
	        if (!index || !eq_js_1.default(computed, seen)) {
	            var seen = computed;
	            result[resIndex++] = value === 0 ? 0 : value;
	        }
	    }
	    return result;
	}
	exports.default = baseSortedUniq;
	});

	var sortedUniq_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseSortedUniq_js_1 = _baseSortedUniq;
	function sortedUniq(array) {
	    return (array && array.length)
	        ? _baseSortedUniq_js_1.default(array)
	        : [];
	}
	exports.default = sortedUniq;
	});

	var sortedUniqBy_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseIteratee_js_1 = _baseIteratee;
	var _baseSortedUniq_js_1 = _baseSortedUniq;
	function sortedUniqBy(array, iteratee) {
	    return (array && array.length)
	        ? _baseSortedUniq_js_1.default(array, _baseIteratee_js_1.default(iteratee, 2))
	        : [];
	}
	exports.default = sortedUniqBy;
	});

	var split_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseToString_js_1 = _baseToString;
	var _castSlice_js_1 = _castSlice;
	var _hasUnicode_js_1 = _hasUnicode;
	var _isIterateeCall_js_1 = _isIterateeCall;
	var isRegExp_js_1 = isRegExp_1;
	var _stringToArray_js_1 = _stringToArray;
	var toString_js_1 = toString_1;
	var MAX_ARRAY_LENGTH = 4294967295;
	function split(string, separator, limit) {
	    if (limit && typeof limit != 'number' && _isIterateeCall_js_1.default(string, separator, limit)) {
	        separator = limit = undefined;
	    }
	    limit = limit === undefined ? MAX_ARRAY_LENGTH : limit >>> 0;
	    if (!limit) {
	        return [];
	    }
	    string = toString_js_1.default(string);
	    if (string && (typeof separator == 'string' ||
	        (separator != null && !isRegExp_js_1.default(separator)))) {
	        separator = _baseToString_js_1.default(separator);
	        if (!separator && _hasUnicode_js_1.default(string)) {
	            return _castSlice_js_1.default(_stringToArray_js_1.default(string), 0, limit);
	        }
	    }
	    return string.split(separator, limit);
	}
	exports.default = split;
	});

	var spread_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _apply_js_1 = _apply;
	var _arrayPush_js_1 = _arrayPush;
	var _baseRest_js_1 = _baseRest;
	var _castSlice_js_1 = _castSlice;
	var toInteger_js_1 = toInteger_1;
	var FUNC_ERROR_TEXT = 'Expected a function';
	var nativeMax = Math.max;
	function spread(func, start) {
	    if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	    }
	    start = start == null ? 0 : nativeMax(toInteger_js_1.default(start), 0);
	    return _baseRest_js_1.default(function (args) {
	        var array = args[start], otherArgs = _castSlice_js_1.default(args, 0, start);
	        if (array) {
	            _arrayPush_js_1.default(otherArgs, array);
	        }
	        return _apply_js_1.default(func, this, otherArgs);
	    });
	}
	exports.default = spread;
	});

	var startCase_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _createCompounder_js_1 = _createCompounder;
	var upperFirst_js_1 = upperFirst_1;
	var startCase = _createCompounder_js_1.default(function (result, word, index) {
	    return result + (index ? ' ' : '') + upperFirst_js_1.default(word);
	});
	exports.default = startCase;
	});

	var startsWith_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseClamp_js_1 = _baseClamp;
	var _baseToString_js_1 = _baseToString;
	var toInteger_js_1 = toInteger_1;
	var toString_js_1 = toString_1;
	function startsWith(string, target, position) {
	    string = toString_js_1.default(string);
	    position = position == null
	        ? 0
	        : _baseClamp_js_1.default(toInteger_js_1.default(position), 0, string.length);
	    target = _baseToString_js_1.default(target);
	    return string.slice(position, position + target.length) == target;
	}
	exports.default = startsWith;
	});

	var stubObject_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	function stubObject() {
	    return {};
	}
	exports.default = stubObject;
	});

	var stubString_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	function stubString() {
	    return '';
	}
	exports.default = stubString;
	});

	var stubTrue_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	function stubTrue() {
	    return true;
	}
	exports.default = stubTrue;
	});

	var subtract_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _createMathOperation_js_1 = _createMathOperation;
	var subtract = _createMathOperation_js_1.default(function (minuend, subtrahend) {
	    return minuend - subtrahend;
	}, 0);
	exports.default = subtract;
	});

	var sum_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseSum_js_1 = _baseSum;
	var identity_js_1 = identity_1;
	function sum(array) {
	    return (array && array.length)
	        ? _baseSum_js_1.default(array, identity_js_1.default)
	        : 0;
	}
	exports.default = sum;
	});

	var sumBy_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseIteratee_js_1 = _baseIteratee;
	var _baseSum_js_1 = _baseSum;
	function sumBy(array, iteratee) {
	    return (array && array.length)
	        ? _baseSum_js_1.default(array, _baseIteratee_js_1.default(iteratee, 2))
	        : 0;
	}
	exports.default = sumBy;
	});

	var tail_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseSlice_js_1 = _baseSlice;
	function tail(array) {
	    var length = array == null ? 0 : array.length;
	    return length ? _baseSlice_js_1.default(array, 1, length) : [];
	}
	exports.default = tail;
	});

	var take_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseSlice_js_1 = _baseSlice;
	var toInteger_js_1 = toInteger_1;
	function take(array, n, guard) {
	    if (!(array && array.length)) {
	        return [];
	    }
	    n = (guard || n === undefined) ? 1 : toInteger_js_1.default(n);
	    return _baseSlice_js_1.default(array, 0, n < 0 ? 0 : n);
	}
	exports.default = take;
	});

	var takeRight_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseSlice_js_1 = _baseSlice;
	var toInteger_js_1 = toInteger_1;
	function takeRight(array, n, guard) {
	    var length = array == null ? 0 : array.length;
	    if (!length) {
	        return [];
	    }
	    n = (guard || n === undefined) ? 1 : toInteger_js_1.default(n);
	    n = length - n;
	    return _baseSlice_js_1.default(array, n < 0 ? 0 : n, length);
	}
	exports.default = takeRight;
	});

	var takeRightWhile_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseIteratee_js_1 = _baseIteratee;
	var _baseWhile_js_1 = _baseWhile;
	function takeRightWhile(array, predicate) {
	    return (array && array.length)
	        ? _baseWhile_js_1.default(array, _baseIteratee_js_1.default(predicate, 3), false, true)
	        : [];
	}
	exports.default = takeRightWhile;
	});

	var takeWhile_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseIteratee_js_1 = _baseIteratee;
	var _baseWhile_js_1 = _baseWhile;
	function takeWhile(array, predicate) {
	    return (array && array.length)
	        ? _baseWhile_js_1.default(array, _baseIteratee_js_1.default(predicate, 3))
	        : [];
	}
	exports.default = takeWhile;
	});

	var tap_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	function tap(value, interceptor) {
	    interceptor(value);
	    return value;
	}
	exports.default = tap;
	});

	var _escapeStringChar = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var stringEscapes = {
	    '\\': '\\',
	    "'": "'",
	    '\n': 'n',
	    '\r': 'r',
	    '\u2028': 'u2028',
	    '\u2029': 'u2029'
	};
	function escapeStringChar(chr) {
	    return '\\' + stringEscapes[chr];
	}
	exports.default = escapeStringChar;
	});

	var _reInterpolate = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var reInterpolate = /<%=([\s\S]+?)%>/g;
	exports.default = reInterpolate;
	});

	var _reEscape = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var reEscape = /<%-([\s\S]+?)%>/g;
	exports.default = reEscape;
	});

	var _reEvaluate = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var reEvaluate = /<%([\s\S]+?)%>/g;
	exports.default = reEvaluate;
	});

	var templateSettings_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var escape_js_1 = _escape;
	var _reEscape_js_1 = _reEscape;
	var _reEvaluate_js_1 = _reEvaluate;
	var _reInterpolate_js_1 = _reInterpolate;
	var templateSettings = {
	    'escape': _reEscape_js_1.default,
	    'evaluate': _reEvaluate_js_1.default,
	    'interpolate': _reInterpolate_js_1.default,
	    'variable': '',
	    'imports': {
	        '_': { 'escape': escape_js_1.default }
	    }
	};
	exports.default = templateSettings;
	});

	var template_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var assignInWith_js_1 = assignInWith_1;
	var attempt_js_1 = attempt_1;
	var _baseValues_js_1 = _baseValues;
	var _customDefaultsAssignIn_js_1 = _customDefaultsAssignIn;
	var _escapeStringChar_js_1 = _escapeStringChar;
	var isError_js_1 = isError_1;
	var _isIterateeCall_js_1 = _isIterateeCall;
	var keys_js_1 = keys_1;
	var _reInterpolate_js_1 = _reInterpolate;
	var templateSettings_js_1 = templateSettings_1;
	var toString_js_1 = toString_1;
	var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
	var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
	var reNoMatch = /($^)/;
	var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
	function template(string, options, guard) {
	    var settings = templateSettings_js_1.default.imports._.templateSettings || templateSettings_js_1.default;
	    if (guard && _isIterateeCall_js_1.default(string, options, guard)) {
	        options = undefined;
	    }
	    string = toString_js_1.default(string);
	    options = assignInWith_js_1.default({}, options, settings, _customDefaultsAssignIn_js_1.default);
	    var imports = assignInWith_js_1.default({}, options.imports, settings.imports, _customDefaultsAssignIn_js_1.default), importsKeys = keys_js_1.default(imports), importsValues = _baseValues_js_1.default(imports, importsKeys);
	    var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
	    var reDelimiters = RegExp((options.escape || reNoMatch).source + '|' +
	        interpolate.source + '|' +
	        (interpolate === _reInterpolate_js_1.default ? reEsTemplate : reNoMatch).source + '|' +
	        (options.evaluate || reNoMatch).source + '|$', 'g');
	    var sourceURL = 'sourceURL' in options ? '//# sourceURL=' + options.sourceURL + '\n' : '';
	    string.replace(reDelimiters, function (match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
	        interpolateValue || (interpolateValue = esTemplateValue);
	        source += string.slice(index, offset).replace(reUnescapedString, _escapeStringChar_js_1.default);
	        if (escapeValue) {
	            isEscaping = true;
	            source += "' +\n__e(" + escapeValue + ") +\n'";
	        }
	        if (evaluateValue) {
	            isEvaluating = true;
	            source += "';\n" + evaluateValue + ";\n__p += '";
	        }
	        if (interpolateValue) {
	            source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
	        }
	        index = offset + match.length;
	        return match;
	    });
	    source += "';\n";
	    var variable = options.variable;
	    if (!variable) {
	        source = 'with (obj) {\n' + source + '\n}\n';
	    }
	    source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
	        .replace(reEmptyStringMiddle, '$1')
	        .replace(reEmptyStringTrailing, '$1;');
	    source = 'function(' + (variable || 'obj') + ') {\n' +
	        (variable
	            ? ''
	            : 'obj || (obj = {});\n') +
	        "var __t, __p = ''" +
	        (isEscaping
	            ? ', __e = _.escape'
	            : '') +
	        (isEvaluating
	            ? ', __j = Array.prototype.join;\n' +
	                "function print() { __p += __j.call(arguments, '') }\n"
	            : ';\n') +
	        source +
	        'return __p\n}';
	    var result = attempt_js_1.default(function () {
	        return Function(importsKeys, sourceURL + 'return ' + source)
	            .apply(undefined, importsValues);
	    });
	    result.source = source;
	    if (isError_js_1.default(result)) {
	        throw result;
	    }
	    return result;
	}
	exports.default = template;
	});

	var throttle_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var debounce_js_1 = debounce_1;
	var isObject_js_1 = isObject_1;
	var FUNC_ERROR_TEXT = 'Expected a function';
	function throttle(func, wait, options) {
	    var leading = true, trailing = true;
	    if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	    }
	    if (isObject_js_1.default(options)) {
	        leading = 'leading' in options ? !!options.leading : leading;
	        trailing = 'trailing' in options ? !!options.trailing : trailing;
	    }
	    return debounce_js_1.default(func, wait, {
	        'leading': leading,
	        'maxWait': wait,
	        'trailing': trailing
	    });
	}
	exports.default = throttle;
	});

	var thru_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	function thru(value, interceptor) {
	    return interceptor(value);
	}
	exports.default = thru;
	});

	var times_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseTimes_js_1 = _baseTimes;
	var _castFunction_js_1 = _castFunction;
	var toInteger_js_1 = toInteger_1;
	var MAX_SAFE_INTEGER = 9007199254740991;
	var MAX_ARRAY_LENGTH = 4294967295;
	var nativeMin = Math.min;
	function times(n, iteratee) {
	    n = toInteger_js_1.default(n);
	    if (n < 1 || n > MAX_SAFE_INTEGER) {
	        return [];
	    }
	    var index = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH);
	    iteratee = _castFunction_js_1.default(iteratee);
	    n -= MAX_ARRAY_LENGTH;
	    var result = _baseTimes_js_1.default(length, iteratee);
	    while (++index < n) {
	        iteratee(index);
	    }
	    return result;
	}
	exports.default = times;
	});

	var toIterator = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	function wrapperToIterator() {
	    return this;
	}
	exports.default = wrapperToIterator;
	});

	var _baseWrapperValue = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _LazyWrapper_js_1 = _LazyWrapper;
	var _arrayPush_js_1 = _arrayPush;
	var _arrayReduce_js_1 = _arrayReduce;
	function baseWrapperValue(value, actions) {
	    var result = value;
	    if (result instanceof _LazyWrapper_js_1.default) {
	        result = result.value();
	    }
	    return _arrayReduce_js_1.default(actions, function (result, action) {
	        return action.func.apply(action.thisArg, _arrayPush_js_1.default([result], action.args));
	    }, result);
	}
	exports.default = baseWrapperValue;
	});

	var wrapperValue_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseWrapperValue_js_1 = _baseWrapperValue;
	function wrapperValue() {
	    return _baseWrapperValue_js_1.default(this.__wrapped__, this.__actions__);
	}
	exports.default = wrapperValue;
	});

	var toJSON = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var wrapperValue_js_1 = wrapperValue_1;
	exports.default = wrapperValue_js_1.default;
	});

	var toLower_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var toString_js_1 = toString_1;
	function toLower(value) {
	    return toString_js_1.default(value).toLowerCase();
	}
	exports.default = toLower;
	});

	var toPath_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _arrayMap_js_1 = _arrayMap;
	var _copyArray_js_1 = _copyArray;
	var isArray_js_1 = isArray_1;
	var isSymbol_js_1 = isSymbol_1;
	var _stringToPath_js_1 = _stringToPath;
	var _toKey_js_1 = _toKey;
	var toString_js_1 = toString_1;
	function toPath(value) {
	    if (isArray_js_1.default(value)) {
	        return _arrayMap_js_1.default(value, _toKey_js_1.default);
	    }
	    return isSymbol_js_1.default(value) ? [value] : _copyArray_js_1.default(_stringToPath_js_1.default(toString_js_1.default(value)));
	}
	exports.default = toPath;
	});

	var toSafeInteger_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseClamp_js_1 = _baseClamp;
	var toInteger_js_1 = toInteger_1;
	var MAX_SAFE_INTEGER = 9007199254740991;
	function toSafeInteger(value) {
	    return value
	        ? _baseClamp_js_1.default(toInteger_js_1.default(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER)
	        : (value === 0 ? value : 0);
	}
	exports.default = toSafeInteger;
	});

	var toUpper_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var toString_js_1 = toString_1;
	function toUpper(value) {
	    return toString_js_1.default(value).toUpperCase();
	}
	exports.default = toUpper;
	});

	var transform_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _arrayEach_js_1 = _arrayEach;
	var _baseCreate_js_1 = _baseCreate;
	var _baseForOwn_js_1 = _baseForOwn;
	var _baseIteratee_js_1 = _baseIteratee;
	var _getPrototype_js_1 = _getPrototype;
	var isArray_js_1 = isArray_1;
	var isBuffer_js_1 = isBuffer_1;
	var isFunction_js_1 = isFunction_1;
	var isObject_js_1 = isObject_1;
	var isTypedArray_js_1 = isTypedArray_1;
	function transform(object, iteratee, accumulator) {
	    var isArr = isArray_js_1.default(object), isArrLike = isArr || isBuffer_js_1.default(object) || isTypedArray_js_1.default(object);
	    iteratee = _baseIteratee_js_1.default(iteratee, 4);
	    if (accumulator == null) {
	        var Ctor = object && object.constructor;
	        if (isArrLike) {
	            accumulator = isArr ? new Ctor : [];
	        }
	        else if (isObject_js_1.default(object)) {
	            accumulator = isFunction_js_1.default(Ctor) ? _baseCreate_js_1.default(_getPrototype_js_1.default(object)) : {};
	        }
	        else {
	            accumulator = {};
	        }
	    }
	    (isArrLike ? _arrayEach_js_1.default : _baseForOwn_js_1.default)(object, function (value, index, object) {
	        return iteratee(accumulator, value, index, object);
	    });
	    return accumulator;
	}
	exports.default = transform;
	});

	var _charsEndIndex = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseIndexOf_js_1 = _baseIndexOf;
	function charsEndIndex(strSymbols, chrSymbols) {
	    var index = strSymbols.length;
	    while (index-- && _baseIndexOf_js_1.default(chrSymbols, strSymbols[index], 0) > -1) { }
	    return index;
	}
	exports.default = charsEndIndex;
	});

	var _charsStartIndex = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseIndexOf_js_1 = _baseIndexOf;
	function charsStartIndex(strSymbols, chrSymbols) {
	    var index = -1, length = strSymbols.length;
	    while (++index < length && _baseIndexOf_js_1.default(chrSymbols, strSymbols[index], 0) > -1) { }
	    return index;
	}
	exports.default = charsStartIndex;
	});

	var trim_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseToString_js_1 = _baseToString;
	var _castSlice_js_1 = _castSlice;
	var _charsEndIndex_js_1 = _charsEndIndex;
	var _charsStartIndex_js_1 = _charsStartIndex;
	var _stringToArray_js_1 = _stringToArray;
	var toString_js_1 = toString_1;
	var reTrim = /^\s+|\s+$/g;
	function trim(string, chars, guard) {
	    string = toString_js_1.default(string);
	    if (string && (guard || chars === undefined)) {
	        return string.replace(reTrim, '');
	    }
	    if (!string || !(chars = _baseToString_js_1.default(chars))) {
	        return string;
	    }
	    var strSymbols = _stringToArray_js_1.default(string), chrSymbols = _stringToArray_js_1.default(chars), start = _charsStartIndex_js_1.default(strSymbols, chrSymbols), end = _charsEndIndex_js_1.default(strSymbols, chrSymbols) + 1;
	    return _castSlice_js_1.default(strSymbols, start, end).join('');
	}
	exports.default = trim;
	});

	var trimEnd_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseToString_js_1 = _baseToString;
	var _castSlice_js_1 = _castSlice;
	var _charsEndIndex_js_1 = _charsEndIndex;
	var _stringToArray_js_1 = _stringToArray;
	var toString_js_1 = toString_1;
	var reTrimEnd = /\s+$/;
	function trimEnd(string, chars, guard) {
	    string = toString_js_1.default(string);
	    if (string && (guard || chars === undefined)) {
	        return string.replace(reTrimEnd, '');
	    }
	    if (!string || !(chars = _baseToString_js_1.default(chars))) {
	        return string;
	    }
	    var strSymbols = _stringToArray_js_1.default(string), end = _charsEndIndex_js_1.default(strSymbols, _stringToArray_js_1.default(chars)) + 1;
	    return _castSlice_js_1.default(strSymbols, 0, end).join('');
	}
	exports.default = trimEnd;
	});

	var trimStart_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseToString_js_1 = _baseToString;
	var _castSlice_js_1 = _castSlice;
	var _charsStartIndex_js_1 = _charsStartIndex;
	var _stringToArray_js_1 = _stringToArray;
	var toString_js_1 = toString_1;
	var reTrimStart = /^\s+/;
	function trimStart(string, chars, guard) {
	    string = toString_js_1.default(string);
	    if (string && (guard || chars === undefined)) {
	        return string.replace(reTrimStart, '');
	    }
	    if (!string || !(chars = _baseToString_js_1.default(chars))) {
	        return string;
	    }
	    var strSymbols = _stringToArray_js_1.default(string), start = _charsStartIndex_js_1.default(strSymbols, _stringToArray_js_1.default(chars));
	    return _castSlice_js_1.default(strSymbols, start).join('');
	}
	exports.default = trimStart;
	});

	var truncate_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseToString_js_1 = _baseToString;
	var _castSlice_js_1 = _castSlice;
	var _hasUnicode_js_1 = _hasUnicode;
	var isObject_js_1 = isObject_1;
	var isRegExp_js_1 = isRegExp_1;
	var _stringSize_js_1 = _stringSize;
	var _stringToArray_js_1 = _stringToArray;
	var toInteger_js_1 = toInteger_1;
	var toString_js_1 = toString_1;
	var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = '...';
	var reFlags = /\w*$/;
	function truncate(string, options) {
	    var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
	    if (isObject_js_1.default(options)) {
	        var separator = 'separator' in options ? options.separator : separator;
	        length = 'length' in options ? toInteger_js_1.default(options.length) : length;
	        omission = 'omission' in options ? _baseToString_js_1.default(options.omission) : omission;
	    }
	    string = toString_js_1.default(string);
	    var strLength = string.length;
	    if (_hasUnicode_js_1.default(string)) {
	        var strSymbols = _stringToArray_js_1.default(string);
	        strLength = strSymbols.length;
	    }
	    if (length >= strLength) {
	        return string;
	    }
	    var end = length - _stringSize_js_1.default(omission);
	    if (end < 1) {
	        return omission;
	    }
	    var result = strSymbols
	        ? _castSlice_js_1.default(strSymbols, 0, end).join('')
	        : string.slice(0, end);
	    if (separator === undefined) {
	        return result + omission;
	    }
	    if (strSymbols) {
	        end += (result.length - end);
	    }
	    if (isRegExp_js_1.default(separator)) {
	        if (string.slice(end).search(separator)) {
	            var match, substring = result;
	            if (!separator.global) {
	                separator = RegExp(separator.source, toString_js_1.default(reFlags.exec(separator)) + 'g');
	            }
	            separator.lastIndex = 0;
	            while ((match = separator.exec(substring))) {
	                var newEnd = match.index;
	            }
	            result = result.slice(0, newEnd === undefined ? end : newEnd);
	        }
	    }
	    else if (string.indexOf(_baseToString_js_1.default(separator), end) != end) {
	        var index = result.lastIndexOf(separator);
	        if (index > -1) {
	            result = result.slice(0, index);
	        }
	    }
	    return result + omission;
	}
	exports.default = truncate;
	});

	var unary_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var ary_js_1 = ary_1;
	function unary(func) {
	    return ary_js_1.default(func, 1);
	}
	exports.default = unary;
	});

	var _unescapeHtmlChar = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _basePropertyOf_js_1 = _basePropertyOf;
	var htmlUnescapes = {
	    '&amp;': '&',
	    '&lt;': '<',
	    '&gt;': '>',
	    '&quot;': '"',
	    '&#39;': "'"
	};
	var unescapeHtmlChar = _basePropertyOf_js_1.default(htmlUnescapes);
	exports.default = unescapeHtmlChar;
	});

	var _unescape = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var toString_js_1 = toString_1;
	var _unescapeHtmlChar_js_1 = _unescapeHtmlChar;
	var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reHasEscapedHtml = RegExp(reEscapedHtml.source);
	function unescape(string) {
	    string = toString_js_1.default(string);
	    return (string && reHasEscapedHtml.test(string))
	        ? string.replace(reEscapedHtml, _unescapeHtmlChar_js_1.default)
	        : string;
	}
	exports.default = unescape;
	});

	var _createSet = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _Set_js_1 = _Set;
	var noop_js_1 = noop_1;
	var _setToArray_js_1 = _setToArray;
	var INFINITY = 1 / 0;
	var createSet = !(_Set_js_1.default && (1 / _setToArray_js_1.default(new _Set_js_1.default([, -0]))[1]) == INFINITY) ? noop_js_1.default : function (values) {
	    return new _Set_js_1.default(values);
	};
	exports.default = createSet;
	});

	var _baseUniq = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _SetCache_js_1 = _SetCache;
	var _arrayIncludes_js_1 = _arrayIncludes;
	var _arrayIncludesWith_js_1 = _arrayIncludesWith;
	var _cacheHas_js_1 = _cacheHas;
	var _createSet_js_1 = _createSet;
	var _setToArray_js_1 = _setToArray;
	var LARGE_ARRAY_SIZE = 200;
	function baseUniq(array, iteratee, comparator) {
	    var index = -1, includes = _arrayIncludes_js_1.default, length = array.length, isCommon = true, result = [], seen = result;
	    if (comparator) {
	        isCommon = false;
	        includes = _arrayIncludesWith_js_1.default;
	    }
	    else if (length >= LARGE_ARRAY_SIZE) {
	        var set = iteratee ? null : _createSet_js_1.default(array);
	        if (set) {
	            return _setToArray_js_1.default(set);
	        }
	        isCommon = false;
	        includes = _cacheHas_js_1.default;
	        seen = new _SetCache_js_1.default;
	    }
	    else {
	        seen = iteratee ? [] : result;
	    }
	    outer: while (++index < length) {
	        var value = array[index], computed = iteratee ? iteratee(value) : value;
	        value = (comparator || value !== 0) ? value : 0;
	        if (isCommon && computed === computed) {
	            var seenIndex = seen.length;
	            while (seenIndex--) {
	                if (seen[seenIndex] === computed) {
	                    continue outer;
	                }
	            }
	            if (iteratee) {
	                seen.push(computed);
	            }
	            result.push(value);
	        }
	        else if (!includes(seen, computed, comparator)) {
	            if (seen !== result) {
	                seen.push(computed);
	            }
	            result.push(value);
	        }
	    }
	    return result;
	}
	exports.default = baseUniq;
	});

	var union_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseFlatten_js_1 = _baseFlatten;
	var _baseRest_js_1 = _baseRest;
	var _baseUniq_js_1 = _baseUniq;
	var isArrayLikeObject_js_1 = isArrayLikeObject_1;
	var union = _baseRest_js_1.default(function (arrays) {
	    return _baseUniq_js_1.default(_baseFlatten_js_1.default(arrays, 1, isArrayLikeObject_js_1.default, true));
	});
	exports.default = union;
	});

	var unionBy_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseFlatten_js_1 = _baseFlatten;
	var _baseIteratee_js_1 = _baseIteratee;
	var _baseRest_js_1 = _baseRest;
	var _baseUniq_js_1 = _baseUniq;
	var isArrayLikeObject_js_1 = isArrayLikeObject_1;
	var last_js_1 = last_1;
	var unionBy = _baseRest_js_1.default(function (arrays) {
	    var iteratee = last_js_1.default(arrays);
	    if (isArrayLikeObject_js_1.default(iteratee)) {
	        iteratee = undefined;
	    }
	    return _baseUniq_js_1.default(_baseFlatten_js_1.default(arrays, 1, isArrayLikeObject_js_1.default, true), _baseIteratee_js_1.default(iteratee, 2));
	});
	exports.default = unionBy;
	});

	var unionWith_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseFlatten_js_1 = _baseFlatten;
	var _baseRest_js_1 = _baseRest;
	var _baseUniq_js_1 = _baseUniq;
	var isArrayLikeObject_js_1 = isArrayLikeObject_1;
	var last_js_1 = last_1;
	var unionWith = _baseRest_js_1.default(function (arrays) {
	    var comparator = last_js_1.default(arrays);
	    comparator = typeof comparator == 'function' ? comparator : undefined;
	    return _baseUniq_js_1.default(_baseFlatten_js_1.default(arrays, 1, isArrayLikeObject_js_1.default, true), undefined, comparator);
	});
	exports.default = unionWith;
	});

	var uniq_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseUniq_js_1 = _baseUniq;
	function uniq(array) {
	    return (array && array.length) ? _baseUniq_js_1.default(array) : [];
	}
	exports.default = uniq;
	});

	var uniqBy_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseIteratee_js_1 = _baseIteratee;
	var _baseUniq_js_1 = _baseUniq;
	function uniqBy(array, iteratee) {
	    return (array && array.length) ? _baseUniq_js_1.default(array, _baseIteratee_js_1.default(iteratee, 2)) : [];
	}
	exports.default = uniqBy;
	});

	var uniqWith_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseUniq_js_1 = _baseUniq;
	function uniqWith(array, comparator) {
	    comparator = typeof comparator == 'function' ? comparator : undefined;
	    return (array && array.length) ? _baseUniq_js_1.default(array, undefined, comparator) : [];
	}
	exports.default = uniqWith;
	});

	var uniqueId_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var toString_js_1 = toString_1;
	var idCounter = 0;
	function uniqueId(prefix) {
	    var id = ++idCounter;
	    return toString_js_1.default(prefix) + id;
	}
	exports.default = uniqueId;
	});

	var unset_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseUnset_js_1 = _baseUnset;
	function unset(object, path) {
	    return object == null ? true : _baseUnset_js_1.default(object, path);
	}
	exports.default = unset;
	});

	var unzip_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _arrayFilter_js_1 = _arrayFilter;
	var _arrayMap_js_1 = _arrayMap;
	var _baseProperty_js_1 = _baseProperty;
	var _baseTimes_js_1 = _baseTimes;
	var isArrayLikeObject_js_1 = isArrayLikeObject_1;
	var nativeMax = Math.max;
	function unzip(array) {
	    if (!(array && array.length)) {
	        return [];
	    }
	    var length = 0;
	    array = _arrayFilter_js_1.default(array, function (group) {
	        if (isArrayLikeObject_js_1.default(group)) {
	            length = nativeMax(group.length, length);
	            return true;
	        }
	    });
	    return _baseTimes_js_1.default(length, function (index) {
	        return _arrayMap_js_1.default(array, _baseProperty_js_1.default(index));
	    });
	}
	exports.default = unzip;
	});

	var unzipWith_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _apply_js_1 = _apply;
	var _arrayMap_js_1 = _arrayMap;
	var unzip_js_1 = unzip_1;
	function unzipWith(array, iteratee) {
	    if (!(array && array.length)) {
	        return [];
	    }
	    var result = unzip_js_1.default(array);
	    if (iteratee == null) {
	        return result;
	    }
	    return _arrayMap_js_1.default(result, function (group) {
	        return _apply_js_1.default(iteratee, undefined, group);
	    });
	}
	exports.default = unzipWith;
	});

	var _baseUpdate = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseGet_js_1 = _baseGet;
	var _baseSet_js_1 = _baseSet;
	function baseUpdate(object, path, updater, customizer) {
	    return _baseSet_js_1.default(object, path, updater(_baseGet_js_1.default(object, path)), customizer);
	}
	exports.default = baseUpdate;
	});

	var update_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseUpdate_js_1 = _baseUpdate;
	var _castFunction_js_1 = _castFunction;
	function update(object, path, updater) {
	    return object == null ? object : _baseUpdate_js_1.default(object, path, _castFunction_js_1.default(updater));
	}
	exports.default = update;
	});

	var updateWith_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseUpdate_js_1 = _baseUpdate;
	var _castFunction_js_1 = _castFunction;
	function updateWith(object, path, updater, customizer) {
	    customizer = typeof customizer == 'function' ? customizer : undefined;
	    return object == null ? object : _baseUpdate_js_1.default(object, path, _castFunction_js_1.default(updater), customizer);
	}
	exports.default = updateWith;
	});

	var upperCase_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _createCompounder_js_1 = _createCompounder;
	var upperCase = _createCompounder_js_1.default(function (result, word, index) {
	    return result + (index ? ' ' : '') + word.toUpperCase();
	});
	exports.default = upperCase;
	});

	var value = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var wrapperValue_js_1 = wrapperValue_1;
	exports.default = wrapperValue_js_1.default;
	});

	var valueOf_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var wrapperValue_js_1 = wrapperValue_1;
	exports.default = wrapperValue_js_1.default;
	});

	var valuesIn_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseValues_js_1 = _baseValues;
	var keysIn_js_1 = keysIn_1;
	function valuesIn(object) {
	    return object == null ? [] : _baseValues_js_1.default(object, keysIn_js_1.default(object));
	}
	exports.default = valuesIn;
	});

	var without_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseDifference_js_1 = _baseDifference;
	var _baseRest_js_1 = _baseRest;
	var isArrayLikeObject_js_1 = isArrayLikeObject_1;
	var without = _baseRest_js_1.default(function (array, values) {
	    return isArrayLikeObject_js_1.default(array)
	        ? _baseDifference_js_1.default(array, values)
	        : [];
	});
	exports.default = without;
	});

	var wrap_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _castFunction_js_1 = _castFunction;
	var partial_js_1 = partial_1;
	function wrap(value, wrapper) {
	    return partial_js_1.default(_castFunction_js_1.default(wrapper), value);
	}
	exports.default = wrap;
	});

	var wrapperAt_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _LazyWrapper_js_1 = _LazyWrapper;
	var _LodashWrapper_js_1 = _LodashWrapper;
	var _baseAt_js_1 = _baseAt;
	var _flatRest_js_1 = _flatRest;
	var _isIndex_js_1 = _isIndex;
	var thru_js_1 = thru_1;
	var wrapperAt = _flatRest_js_1.default(function (paths) {
	    var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function (object) { return _baseAt_js_1.default(object, paths); };
	    if (length > 1 || this.__actions__.length ||
	        !(value instanceof _LazyWrapper_js_1.default) || !_isIndex_js_1.default(start)) {
	        return this.thru(interceptor);
	    }
	    value = value.slice(start, +start + (length ? 1 : 0));
	    value.__actions__.push({
	        'func': thru_js_1.default,
	        'args': [interceptor],
	        'thisArg': undefined
	    });
	    return new _LodashWrapper_js_1.default(value, this.__chain__).thru(function (array) {
	        if (length && !array.length) {
	            array.push(undefined);
	        }
	        return array;
	    });
	});
	exports.default = wrapperAt;
	});

	var wrapperChain_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var chain_js_1 = chain_1;
	function wrapperChain() {
	    return chain_js_1.default(this);
	}
	exports.default = wrapperChain;
	});

	var wrapperReverse_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _LazyWrapper_js_1 = _LazyWrapper;
	var _LodashWrapper_js_1 = _LodashWrapper;
	var reverse_js_1 = reverse_1;
	var thru_js_1 = thru_1;
	function wrapperReverse() {
	    var value = this.__wrapped__;
	    if (value instanceof _LazyWrapper_js_1.default) {
	        var wrapped = value;
	        if (this.__actions__.length) {
	            wrapped = new _LazyWrapper_js_1.default(this);
	        }
	        wrapped = wrapped.reverse();
	        wrapped.__actions__.push({
	            'func': thru_js_1.default,
	            'args': [reverse_js_1.default],
	            'thisArg': undefined
	        });
	        return new _LodashWrapper_js_1.default(wrapped, this.__chain__);
	    }
	    return this.thru(reverse_js_1.default);
	}
	exports.default = wrapperReverse;
	});

	var _baseXor = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseDifference_js_1 = _baseDifference;
	var _baseFlatten_js_1 = _baseFlatten;
	var _baseUniq_js_1 = _baseUniq;
	function baseXor(arrays, iteratee, comparator) {
	    var length = arrays.length;
	    if (length < 2) {
	        return length ? _baseUniq_js_1.default(arrays[0]) : [];
	    }
	    var index = -1, result = Array(length);
	    while (++index < length) {
	        var array = arrays[index], othIndex = -1;
	        while (++othIndex < length) {
	            if (othIndex != index) {
	                result[index] = _baseDifference_js_1.default(result[index] || array, arrays[othIndex], iteratee, comparator);
	            }
	        }
	    }
	    return _baseUniq_js_1.default(_baseFlatten_js_1.default(result, 1), iteratee, comparator);
	}
	exports.default = baseXor;
	});

	var xor_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _arrayFilter_js_1 = _arrayFilter;
	var _baseRest_js_1 = _baseRest;
	var _baseXor_js_1 = _baseXor;
	var isArrayLikeObject_js_1 = isArrayLikeObject_1;
	var xor = _baseRest_js_1.default(function (arrays) {
	    return _baseXor_js_1.default(_arrayFilter_js_1.default(arrays, isArrayLikeObject_js_1.default));
	});
	exports.default = xor;
	});

	var xorBy_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _arrayFilter_js_1 = _arrayFilter;
	var _baseIteratee_js_1 = _baseIteratee;
	var _baseRest_js_1 = _baseRest;
	var _baseXor_js_1 = _baseXor;
	var isArrayLikeObject_js_1 = isArrayLikeObject_1;
	var last_js_1 = last_1;
	var xorBy = _baseRest_js_1.default(function (arrays) {
	    var iteratee = last_js_1.default(arrays);
	    if (isArrayLikeObject_js_1.default(iteratee)) {
	        iteratee = undefined;
	    }
	    return _baseXor_js_1.default(_arrayFilter_js_1.default(arrays, isArrayLikeObject_js_1.default), _baseIteratee_js_1.default(iteratee, 2));
	});
	exports.default = xorBy;
	});

	var xorWith_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _arrayFilter_js_1 = _arrayFilter;
	var _baseRest_js_1 = _baseRest;
	var _baseXor_js_1 = _baseXor;
	var isArrayLikeObject_js_1 = isArrayLikeObject_1;
	var last_js_1 = last_1;
	var xorWith = _baseRest_js_1.default(function (arrays) {
	    var comparator = last_js_1.default(arrays);
	    comparator = typeof comparator == 'function' ? comparator : undefined;
	    return _baseXor_js_1.default(_arrayFilter_js_1.default(arrays, isArrayLikeObject_js_1.default), undefined, comparator);
	});
	exports.default = xorWith;
	});

	var zip_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseRest_js_1 = _baseRest;
	var unzip_js_1 = unzip_1;
	var zip = _baseRest_js_1.default(unzip_js_1.default);
	exports.default = zip;
	});

	var _baseZipObject = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	function baseZipObject(props, values, assignFunc) {
	    var index = -1, length = props.length, valsLength = values.length, result = {};
	    while (++index < length) {
	        var value = index < valsLength ? values[index] : undefined;
	        assignFunc(result, props[index], value);
	    }
	    return result;
	}
	exports.default = baseZipObject;
	});

	var zipObject_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _assignValue_js_1 = _assignValue;
	var _baseZipObject_js_1 = _baseZipObject;
	function zipObject(props, values) {
	    return _baseZipObject_js_1.default(props || [], values || [], _assignValue_js_1.default);
	}
	exports.default = zipObject;
	});

	var zipObjectDeep_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseSet_js_1 = _baseSet;
	var _baseZipObject_js_1 = _baseZipObject;
	function zipObjectDeep(props, values) {
	    return _baseZipObject_js_1.default(props || [], values || [], _baseSet_js_1.default);
	}
	exports.default = zipObjectDeep;
	});

	var zipWith_1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseRest_js_1 = _baseRest;
	var unzipWith_js_1 = unzipWith_1;
	var zipWith = _baseRest_js_1.default(function (arrays) {
	    var length = arrays.length, iteratee = length > 1 ? arrays[length - 1] : undefined;
	    iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined;
	    return unzipWith_js_1.default(arrays, iteratee);
	});
	exports.default = zipWith;
	});

	var array_default = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var chunk_js_1 = chunk_1;
	var compact_js_1 = compact_1;
	var concat_js_1 = concat_1;
	var difference_js_1 = difference_1;
	var differenceBy_js_1 = differenceBy_1;
	var differenceWith_js_1 = differenceWith_1;
	var drop_js_1 = drop_1;
	var dropRight_js_1 = dropRight_1;
	var dropRightWhile_js_1 = dropRightWhile_1;
	var dropWhile_js_1 = dropWhile_1;
	var fill_js_1 = fill_1;
	var findIndex_js_1 = findIndex_1;
	var findLastIndex_js_1 = findLastIndex_1;
	var first_js_1 = first;
	var flatten_js_1 = flatten_1;
	var flattenDeep_js_1 = flattenDeep_1;
	var flattenDepth_js_1 = flattenDepth_1;
	var fromPairs_js_1 = fromPairs_1;
	var head_js_1 = head_1;
	var indexOf_js_1 = indexOf_1;
	var initial_js_1 = initial_1;
	var intersection_js_1 = intersection_1;
	var intersectionBy_js_1 = intersectionBy_1;
	var intersectionWith_js_1 = intersectionWith_1;
	var join_js_1 = join_1;
	var last_js_1 = last_1;
	var lastIndexOf_js_1 = lastIndexOf_1;
	var nth_js_1 = nth_1;
	var pull_js_1 = pull_1;
	var pullAll_js_1 = pullAll_1;
	var pullAllBy_js_1 = pullAllBy_1;
	var pullAllWith_js_1 = pullAllWith_1;
	var pullAt_js_1 = pullAt_1;
	var remove_js_1 = remove_1;
	var reverse_js_1 = reverse_1;
	var slice_js_1 = slice_1;
	var sortedIndex_js_1 = sortedIndex_1;
	var sortedIndexBy_js_1 = sortedIndexBy_1;
	var sortedIndexOf_js_1 = sortedIndexOf_1;
	var sortedLastIndex_js_1 = sortedLastIndex_1;
	var sortedLastIndexBy_js_1 = sortedLastIndexBy_1;
	var sortedLastIndexOf_js_1 = sortedLastIndexOf_1;
	var sortedUniq_js_1 = sortedUniq_1;
	var sortedUniqBy_js_1 = sortedUniqBy_1;
	var tail_js_1 = tail_1;
	var take_js_1 = take_1;
	var takeRight_js_1 = takeRight_1;
	var takeRightWhile_js_1 = takeRightWhile_1;
	var takeWhile_js_1 = takeWhile_1;
	var union_js_1 = union_1;
	var unionBy_js_1 = unionBy_1;
	var unionWith_js_1 = unionWith_1;
	var uniq_js_1 = uniq_1;
	var uniqBy_js_1 = uniqBy_1;
	var uniqWith_js_1 = uniqWith_1;
	var unzip_js_1 = unzip_1;
	var unzipWith_js_1 = unzipWith_1;
	var without_js_1 = without_1;
	var xor_js_1 = xor_1;
	var xorBy_js_1 = xorBy_1;
	var xorWith_js_1 = xorWith_1;
	var zip_js_1 = zip_1;
	var zipObject_js_1 = zipObject_1;
	var zipObjectDeep_js_1 = zipObjectDeep_1;
	var zipWith_js_1 = zipWith_1;
	exports.default = {
	    chunk: chunk_js_1.default, compact: compact_js_1.default, concat: concat_js_1.default, difference: difference_js_1.default, differenceBy: differenceBy_js_1.default,
	    differenceWith: differenceWith_js_1.default, drop: drop_js_1.default, dropRight: dropRight_js_1.default, dropRightWhile: dropRightWhile_js_1.default, dropWhile: dropWhile_js_1.default,
	    fill: fill_js_1.default, findIndex: findIndex_js_1.default, findLastIndex: findLastIndex_js_1.default, first: first_js_1.default, flatten: flatten_js_1.default,
	    flattenDeep: flattenDeep_js_1.default, flattenDepth: flattenDepth_js_1.default, fromPairs: fromPairs_js_1.default, head: head_js_1.default, indexOf: indexOf_js_1.default,
	    initial: initial_js_1.default, intersection: intersection_js_1.default, intersectionBy: intersectionBy_js_1.default, intersectionWith: intersectionWith_js_1.default, join: join_js_1.default,
	    last: last_js_1.default, lastIndexOf: lastIndexOf_js_1.default, nth: nth_js_1.default, pull: pull_js_1.default, pullAll: pullAll_js_1.default,
	    pullAllBy: pullAllBy_js_1.default, pullAllWith: pullAllWith_js_1.default, pullAt: pullAt_js_1.default, remove: remove_js_1.default, reverse: reverse_js_1.default,
	    slice: slice_js_1.default, sortedIndex: sortedIndex_js_1.default, sortedIndexBy: sortedIndexBy_js_1.default, sortedIndexOf: sortedIndexOf_js_1.default, sortedLastIndex: sortedLastIndex_js_1.default,
	    sortedLastIndexBy: sortedLastIndexBy_js_1.default, sortedLastIndexOf: sortedLastIndexOf_js_1.default, sortedUniq: sortedUniq_js_1.default, sortedUniqBy: sortedUniqBy_js_1.default, tail: tail_js_1.default,
	    take: take_js_1.default, takeRight: takeRight_js_1.default, takeRightWhile: takeRightWhile_js_1.default, takeWhile: takeWhile_js_1.default, union: union_js_1.default,
	    unionBy: unionBy_js_1.default, unionWith: unionWith_js_1.default, uniq: uniq_js_1.default, uniqBy: uniqBy_js_1.default, uniqWith: uniqWith_js_1.default,
	    unzip: unzip_js_1.default, unzipWith: unzipWith_js_1.default, without: without_js_1.default, xor: xor_js_1.default, xorBy: xorBy_js_1.default,
	    xorWith: xorWith_js_1.default, zip: zip_js_1.default, zipObject: zipObject_js_1.default, zipObjectDeep: zipObjectDeep_js_1.default, zipWith: zipWith_js_1.default
	};
	});

	var array = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var chunk_js_1 = chunk_1;
	exports.chunk = chunk_js_1.default;
	var compact_js_1 = compact_1;
	exports.compact = compact_js_1.default;
	var concat_js_1 = concat_1;
	exports.concat = concat_js_1.default;
	var difference_js_1 = difference_1;
	exports.difference = difference_js_1.default;
	var differenceBy_js_1 = differenceBy_1;
	exports.differenceBy = differenceBy_js_1.default;
	var differenceWith_js_1 = differenceWith_1;
	exports.differenceWith = differenceWith_js_1.default;
	var drop_js_1 = drop_1;
	exports.drop = drop_js_1.default;
	var dropRight_js_1 = dropRight_1;
	exports.dropRight = dropRight_js_1.default;
	var dropRightWhile_js_1 = dropRightWhile_1;
	exports.dropRightWhile = dropRightWhile_js_1.default;
	var dropWhile_js_1 = dropWhile_1;
	exports.dropWhile = dropWhile_js_1.default;
	var fill_js_1 = fill_1;
	exports.fill = fill_js_1.default;
	var findIndex_js_1 = findIndex_1;
	exports.findIndex = findIndex_js_1.default;
	var findLastIndex_js_1 = findLastIndex_1;
	exports.findLastIndex = findLastIndex_js_1.default;
	var first_js_1 = first;
	exports.first = first_js_1.default;
	var flatten_js_1 = flatten_1;
	exports.flatten = flatten_js_1.default;
	var flattenDeep_js_1 = flattenDeep_1;
	exports.flattenDeep = flattenDeep_js_1.default;
	var flattenDepth_js_1 = flattenDepth_1;
	exports.flattenDepth = flattenDepth_js_1.default;
	var fromPairs_js_1 = fromPairs_1;
	exports.fromPairs = fromPairs_js_1.default;
	var head_js_1 = head_1;
	exports.head = head_js_1.default;
	var indexOf_js_1 = indexOf_1;
	exports.indexOf = indexOf_js_1.default;
	var initial_js_1 = initial_1;
	exports.initial = initial_js_1.default;
	var intersection_js_1 = intersection_1;
	exports.intersection = intersection_js_1.default;
	var intersectionBy_js_1 = intersectionBy_1;
	exports.intersectionBy = intersectionBy_js_1.default;
	var intersectionWith_js_1 = intersectionWith_1;
	exports.intersectionWith = intersectionWith_js_1.default;
	var join_js_1 = join_1;
	exports.join = join_js_1.default;
	var last_js_1 = last_1;
	exports.last = last_js_1.default;
	var lastIndexOf_js_1 = lastIndexOf_1;
	exports.lastIndexOf = lastIndexOf_js_1.default;
	var nth_js_1 = nth_1;
	exports.nth = nth_js_1.default;
	var pull_js_1 = pull_1;
	exports.pull = pull_js_1.default;
	var pullAll_js_1 = pullAll_1;
	exports.pullAll = pullAll_js_1.default;
	var pullAllBy_js_1 = pullAllBy_1;
	exports.pullAllBy = pullAllBy_js_1.default;
	var pullAllWith_js_1 = pullAllWith_1;
	exports.pullAllWith = pullAllWith_js_1.default;
	var pullAt_js_1 = pullAt_1;
	exports.pullAt = pullAt_js_1.default;
	var remove_js_1 = remove_1;
	exports.remove = remove_js_1.default;
	var reverse_js_1 = reverse_1;
	exports.reverse = reverse_js_1.default;
	var slice_js_1 = slice_1;
	exports.slice = slice_js_1.default;
	var sortedIndex_js_1 = sortedIndex_1;
	exports.sortedIndex = sortedIndex_js_1.default;
	var sortedIndexBy_js_1 = sortedIndexBy_1;
	exports.sortedIndexBy = sortedIndexBy_js_1.default;
	var sortedIndexOf_js_1 = sortedIndexOf_1;
	exports.sortedIndexOf = sortedIndexOf_js_1.default;
	var sortedLastIndex_js_1 = sortedLastIndex_1;
	exports.sortedLastIndex = sortedLastIndex_js_1.default;
	var sortedLastIndexBy_js_1 = sortedLastIndexBy_1;
	exports.sortedLastIndexBy = sortedLastIndexBy_js_1.default;
	var sortedLastIndexOf_js_1 = sortedLastIndexOf_1;
	exports.sortedLastIndexOf = sortedLastIndexOf_js_1.default;
	var sortedUniq_js_1 = sortedUniq_1;
	exports.sortedUniq = sortedUniq_js_1.default;
	var sortedUniqBy_js_1 = sortedUniqBy_1;
	exports.sortedUniqBy = sortedUniqBy_js_1.default;
	var tail_js_1 = tail_1;
	exports.tail = tail_js_1.default;
	var take_js_1 = take_1;
	exports.take = take_js_1.default;
	var takeRight_js_1 = takeRight_1;
	exports.takeRight = takeRight_js_1.default;
	var takeRightWhile_js_1 = takeRightWhile_1;
	exports.takeRightWhile = takeRightWhile_js_1.default;
	var takeWhile_js_1 = takeWhile_1;
	exports.takeWhile = takeWhile_js_1.default;
	var union_js_1 = union_1;
	exports.union = union_js_1.default;
	var unionBy_js_1 = unionBy_1;
	exports.unionBy = unionBy_js_1.default;
	var unionWith_js_1 = unionWith_1;
	exports.unionWith = unionWith_js_1.default;
	var uniq_js_1 = uniq_1;
	exports.uniq = uniq_js_1.default;
	var uniqBy_js_1 = uniqBy_1;
	exports.uniqBy = uniqBy_js_1.default;
	var uniqWith_js_1 = uniqWith_1;
	exports.uniqWith = uniqWith_js_1.default;
	var unzip_js_1 = unzip_1;
	exports.unzip = unzip_js_1.default;
	var unzipWith_js_1 = unzipWith_1;
	exports.unzipWith = unzipWith_js_1.default;
	var without_js_1 = without_1;
	exports.without = without_js_1.default;
	var xor_js_1 = xor_1;
	exports.xor = xor_js_1.default;
	var xorBy_js_1 = xorBy_1;
	exports.xorBy = xorBy_js_1.default;
	var xorWith_js_1 = xorWith_1;
	exports.xorWith = xorWith_js_1.default;
	var zip_js_1 = zip_1;
	exports.zip = zip_js_1.default;
	var zipObject_js_1 = zipObject_1;
	exports.zipObject = zipObject_js_1.default;
	var zipObjectDeep_js_1 = zipObjectDeep_1;
	exports.zipObjectDeep = zipObjectDeep_js_1.default;
	var zipWith_js_1 = zipWith_1;
	exports.zipWith = zipWith_js_1.default;
	var array_default_js_1 = array_default;
	exports.default = array_default_js_1.default;
	});

	var collection_default = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var countBy_js_1 = countBy_1;
	var each_js_1 = each;
	var eachRight_js_1 = eachRight;
	var every_js_1 = every_1;
	var filter_js_1 = filter_1;
	var find_js_1 = find_1;
	var findLast_js_1 = findLast_1;
	var flatMap_js_1 = flatMap_1;
	var flatMapDeep_js_1 = flatMapDeep_1;
	var flatMapDepth_js_1 = flatMapDepth_1;
	var forEach_js_1 = forEach_1;
	var forEachRight_js_1 = forEachRight_1;
	var groupBy_js_1 = groupBy_1;
	var includes_js_1 = includes_1;
	var invokeMap_js_1 = invokeMap_1;
	var keyBy_js_1 = keyBy_1;
	var map_js_1 = map_1;
	var orderBy_js_1 = orderBy_1;
	var partition_js_1 = partition_1;
	var reduce_js_1 = reduce_1;
	var reduceRight_js_1 = reduceRight_1;
	var reject_js_1 = reject_1;
	var sample_js_1 = sample_1;
	var sampleSize_js_1 = sampleSize_1;
	var shuffle_js_1 = shuffle_1;
	var size_js_1 = size_1;
	var some_js_1 = some_1;
	var sortBy_js_1 = sortBy_1;
	exports.default = {
	    countBy: countBy_js_1.default, each: each_js_1.default, eachRight: eachRight_js_1.default, every: every_js_1.default, filter: filter_js_1.default,
	    find: find_js_1.default, findLast: findLast_js_1.default, flatMap: flatMap_js_1.default, flatMapDeep: flatMapDeep_js_1.default, flatMapDepth: flatMapDepth_js_1.default,
	    forEach: forEach_js_1.default, forEachRight: forEachRight_js_1.default, groupBy: groupBy_js_1.default, includes: includes_js_1.default, invokeMap: invokeMap_js_1.default,
	    keyBy: keyBy_js_1.default, map: map_js_1.default, orderBy: orderBy_js_1.default, partition: partition_js_1.default, reduce: reduce_js_1.default,
	    reduceRight: reduceRight_js_1.default, reject: reject_js_1.default, sample: sample_js_1.default, sampleSize: sampleSize_js_1.default, shuffle: shuffle_js_1.default,
	    size: size_js_1.default, some: some_js_1.default, sortBy: sortBy_js_1.default
	};
	});

	var collection = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var countBy_js_1 = countBy_1;
	exports.countBy = countBy_js_1.default;
	var each_js_1 = each;
	exports.each = each_js_1.default;
	var eachRight_js_1 = eachRight;
	exports.eachRight = eachRight_js_1.default;
	var every_js_1 = every_1;
	exports.every = every_js_1.default;
	var filter_js_1 = filter_1;
	exports.filter = filter_js_1.default;
	var find_js_1 = find_1;
	exports.find = find_js_1.default;
	var findLast_js_1 = findLast_1;
	exports.findLast = findLast_js_1.default;
	var flatMap_js_1 = flatMap_1;
	exports.flatMap = flatMap_js_1.default;
	var flatMapDeep_js_1 = flatMapDeep_1;
	exports.flatMapDeep = flatMapDeep_js_1.default;
	var flatMapDepth_js_1 = flatMapDepth_1;
	exports.flatMapDepth = flatMapDepth_js_1.default;
	var forEach_js_1 = forEach_1;
	exports.forEach = forEach_js_1.default;
	var forEachRight_js_1 = forEachRight_1;
	exports.forEachRight = forEachRight_js_1.default;
	var groupBy_js_1 = groupBy_1;
	exports.groupBy = groupBy_js_1.default;
	var includes_js_1 = includes_1;
	exports.includes = includes_js_1.default;
	var invokeMap_js_1 = invokeMap_1;
	exports.invokeMap = invokeMap_js_1.default;
	var keyBy_js_1 = keyBy_1;
	exports.keyBy = keyBy_js_1.default;
	var map_js_1 = map_1;
	exports.map = map_js_1.default;
	var orderBy_js_1 = orderBy_1;
	exports.orderBy = orderBy_js_1.default;
	var partition_js_1 = partition_1;
	exports.partition = partition_js_1.default;
	var reduce_js_1 = reduce_1;
	exports.reduce = reduce_js_1.default;
	var reduceRight_js_1 = reduceRight_1;
	exports.reduceRight = reduceRight_js_1.default;
	var reject_js_1 = reject_1;
	exports.reject = reject_js_1.default;
	var sample_js_1 = sample_1;
	exports.sample = sample_js_1.default;
	var sampleSize_js_1 = sampleSize_1;
	exports.sampleSize = sampleSize_js_1.default;
	var shuffle_js_1 = shuffle_1;
	exports.shuffle = shuffle_js_1.default;
	var size_js_1 = size_1;
	exports.size = size_js_1.default;
	var some_js_1 = some_1;
	exports.some = some_js_1.default;
	var sortBy_js_1 = sortBy_1;
	exports.sortBy = sortBy_js_1.default;
	var collection_default_js_1 = collection_default;
	exports.default = collection_default_js_1.default;
	});

	var date_default = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var now_js_1 = now_1;
	exports.default = {
	    now: now_js_1.default
	};
	});

	var date = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var now_js_1 = now_1;
	exports.now = now_js_1.default;
	var date_default_js_1 = date_default;
	exports.default = date_default_js_1.default;
	});

	var function_default = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var after_js_1 = after_1;
	var ary_js_1 = ary_1;
	var before_js_1 = before_1;
	var bind_js_1 = bind_1;
	var bindKey_js_1 = bindKey_1;
	var curry_js_1 = curry_1;
	var curryRight_js_1 = curryRight_1;
	var debounce_js_1 = debounce_1;
	var defer_js_1 = defer_1;
	var delay_js_1 = delay_1;
	var flip_js_1 = flip_1;
	var memoize_js_1 = memoize_1;
	var negate_js_1 = negate_1;
	var once_js_1 = once_1;
	var overArgs_js_1 = overArgs_1;
	var partial_js_1 = partial_1;
	var partialRight_js_1 = partialRight_1;
	var rearg_js_1 = rearg_1;
	var rest_js_1 = rest_1;
	var spread_js_1 = spread_1;
	var throttle_js_1 = throttle_1;
	var unary_js_1 = unary_1;
	var wrap_js_1 = wrap_1;
	exports.default = {
	    after: after_js_1.default, ary: ary_js_1.default, before: before_js_1.default, bind: bind_js_1.default, bindKey: bindKey_js_1.default,
	    curry: curry_js_1.default, curryRight: curryRight_js_1.default, debounce: debounce_js_1.default, defer: defer_js_1.default, delay: delay_js_1.default,
	    flip: flip_js_1.default, memoize: memoize_js_1.default, negate: negate_js_1.default, once: once_js_1.default, overArgs: overArgs_js_1.default,
	    partial: partial_js_1.default, partialRight: partialRight_js_1.default, rearg: rearg_js_1.default, rest: rest_js_1.default, spread: spread_js_1.default,
	    throttle: throttle_js_1.default, unary: unary_js_1.default, wrap: wrap_js_1.default
	};
	});

	var _function = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var after_js_1 = after_1;
	exports.after = after_js_1.default;
	var ary_js_1 = ary_1;
	exports.ary = ary_js_1.default;
	var before_js_1 = before_1;
	exports.before = before_js_1.default;
	var bind_js_1 = bind_1;
	exports.bind = bind_js_1.default;
	var bindKey_js_1 = bindKey_1;
	exports.bindKey = bindKey_js_1.default;
	var curry_js_1 = curry_1;
	exports.curry = curry_js_1.default;
	var curryRight_js_1 = curryRight_1;
	exports.curryRight = curryRight_js_1.default;
	var debounce_js_1 = debounce_1;
	exports.debounce = debounce_js_1.default;
	var defer_js_1 = defer_1;
	exports.defer = defer_js_1.default;
	var delay_js_1 = delay_1;
	exports.delay = delay_js_1.default;
	var flip_js_1 = flip_1;
	exports.flip = flip_js_1.default;
	var memoize_js_1 = memoize_1;
	exports.memoize = memoize_js_1.default;
	var negate_js_1 = negate_1;
	exports.negate = negate_js_1.default;
	var once_js_1 = once_1;
	exports.once = once_js_1.default;
	var overArgs_js_1 = overArgs_1;
	exports.overArgs = overArgs_js_1.default;
	var partial_js_1 = partial_1;
	exports.partial = partial_js_1.default;
	var partialRight_js_1 = partialRight_1;
	exports.partialRight = partialRight_js_1.default;
	var rearg_js_1 = rearg_1;
	exports.rearg = rearg_js_1.default;
	var rest_js_1 = rest_1;
	exports.rest = rest_js_1.default;
	var spread_js_1 = spread_1;
	exports.spread = spread_js_1.default;
	var throttle_js_1 = throttle_1;
	exports.throttle = throttle_js_1.default;
	var unary_js_1 = unary_1;
	exports.unary = unary_js_1.default;
	var wrap_js_1 = wrap_1;
	exports.wrap = wrap_js_1.default;
	var function_default_js_1 = function_default;
	exports.default = function_default_js_1.default;
	});

	var lang_default = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var castArray_js_1 = castArray_1;
	var clone_js_1 = clone_1;
	var cloneDeep_js_1 = cloneDeep_1;
	var cloneDeepWith_js_1 = cloneDeepWith_1;
	var cloneWith_js_1 = cloneWith_1;
	var conformsTo_js_1 = conformsTo_1;
	var eq_js_1 = eq_1;
	var gt_js_1 = gt_1;
	var gte_js_1 = gte_1;
	var isArguments_js_1 = isArguments_1;
	var isArray_js_1 = isArray_1;
	var isArrayBuffer_js_1 = isArrayBuffer_1;
	var isArrayLike_js_1 = isArrayLike_1;
	var isArrayLikeObject_js_1 = isArrayLikeObject_1;
	var isBoolean_js_1 = isBoolean_1;
	var isBuffer_js_1 = isBuffer_1;
	var isDate_js_1 = isDate_1;
	var isElement_js_1 = isElement_1;
	var isEmpty_js_1 = isEmpty_1;
	var isEqual_js_1 = isEqual_1;
	var isEqualWith_js_1 = isEqualWith_1;
	var isError_js_1 = isError_1;
	var isFinite_js_1 = _isFinite;
	var isFunction_js_1 = isFunction_1;
	var isInteger_js_1 = isInteger_1;
	var isLength_js_1 = isLength_1;
	var isMap_js_1 = isMap_1;
	var isMatch_js_1 = isMatch_1;
	var isMatchWith_js_1 = isMatchWith_1;
	var isNaN_js_1 = _isNaN;
	var isNative_js_1 = isNative_1;
	var isNil_js_1 = isNil_1;
	var isNull_js_1 = isNull_1;
	var isNumber_js_1 = isNumber_1;
	var isObject_js_1 = isObject_1;
	var isObjectLike_js_1 = isObjectLike_1;
	var isPlainObject_js_1 = isPlainObject_1;
	var isRegExp_js_1 = isRegExp_1;
	var isSafeInteger_js_1 = isSafeInteger_1;
	var isSet_js_1 = isSet_1;
	var isString_js_1 = isString_1;
	var isSymbol_js_1 = isSymbol_1;
	var isTypedArray_js_1 = isTypedArray_1;
	var isUndefined_js_1 = isUndefined_1;
	var isWeakMap_js_1 = isWeakMap_1;
	var isWeakSet_js_1 = isWeakSet_1;
	var lt_js_1 = lt_1;
	var lte_js_1 = lte_1;
	var toArray_js_1 = toArray_1;
	var toFinite_js_1 = toFinite_1;
	var toInteger_js_1 = toInteger_1;
	var toLength_js_1 = toLength_1;
	var toNumber_js_1 = toNumber_1;
	var toPlainObject_js_1 = toPlainObject_1;
	var toSafeInteger_js_1 = toSafeInteger_1;
	var toString_js_1 = toString_1;
	exports.default = {
	    castArray: castArray_js_1.default, clone: clone_js_1.default, cloneDeep: cloneDeep_js_1.default, cloneDeepWith: cloneDeepWith_js_1.default, cloneWith: cloneWith_js_1.default,
	    conformsTo: conformsTo_js_1.default, eq: eq_js_1.default, gt: gt_js_1.default, gte: gte_js_1.default, isArguments: isArguments_js_1.default,
	    isArray: isArray_js_1.default, isArrayBuffer: isArrayBuffer_js_1.default, isArrayLike: isArrayLike_js_1.default, isArrayLikeObject: isArrayLikeObject_js_1.default, isBoolean: isBoolean_js_1.default,
	    isBuffer: isBuffer_js_1.default, isDate: isDate_js_1.default, isElement: isElement_js_1.default, isEmpty: isEmpty_js_1.default, isEqual: isEqual_js_1.default,
	    isEqualWith: isEqualWith_js_1.default, isError: isError_js_1.default, isFinite: isFinite_js_1.default, isFunction: isFunction_js_1.default, isInteger: isInteger_js_1.default,
	    isLength: isLength_js_1.default, isMap: isMap_js_1.default, isMatch: isMatch_js_1.default, isMatchWith: isMatchWith_js_1.default, isNaN: isNaN_js_1.default,
	    isNative: isNative_js_1.default, isNil: isNil_js_1.default, isNull: isNull_js_1.default, isNumber: isNumber_js_1.default, isObject: isObject_js_1.default,
	    isObjectLike: isObjectLike_js_1.default, isPlainObject: isPlainObject_js_1.default, isRegExp: isRegExp_js_1.default, isSafeInteger: isSafeInteger_js_1.default, isSet: isSet_js_1.default,
	    isString: isString_js_1.default, isSymbol: isSymbol_js_1.default, isTypedArray: isTypedArray_js_1.default, isUndefined: isUndefined_js_1.default, isWeakMap: isWeakMap_js_1.default,
	    isWeakSet: isWeakSet_js_1.default, lt: lt_js_1.default, lte: lte_js_1.default, toArray: toArray_js_1.default, toFinite: toFinite_js_1.default,
	    toInteger: toInteger_js_1.default, toLength: toLength_js_1.default, toNumber: toNumber_js_1.default, toPlainObject: toPlainObject_js_1.default, toSafeInteger: toSafeInteger_js_1.default,
	    toString: toString_js_1.default
	};
	});

	var lang = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var castArray_js_1 = castArray_1;
	exports.castArray = castArray_js_1.default;
	var clone_js_1 = clone_1;
	exports.clone = clone_js_1.default;
	var cloneDeep_js_1 = cloneDeep_1;
	exports.cloneDeep = cloneDeep_js_1.default;
	var cloneDeepWith_js_1 = cloneDeepWith_1;
	exports.cloneDeepWith = cloneDeepWith_js_1.default;
	var cloneWith_js_1 = cloneWith_1;
	exports.cloneWith = cloneWith_js_1.default;
	var conformsTo_js_1 = conformsTo_1;
	exports.conformsTo = conformsTo_js_1.default;
	var eq_js_1 = eq_1;
	exports.eq = eq_js_1.default;
	var gt_js_1 = gt_1;
	exports.gt = gt_js_1.default;
	var gte_js_1 = gte_1;
	exports.gte = gte_js_1.default;
	var isArguments_js_1 = isArguments_1;
	exports.isArguments = isArguments_js_1.default;
	var isArray_js_1 = isArray_1;
	exports.isArray = isArray_js_1.default;
	var isArrayBuffer_js_1 = isArrayBuffer_1;
	exports.isArrayBuffer = isArrayBuffer_js_1.default;
	var isArrayLike_js_1 = isArrayLike_1;
	exports.isArrayLike = isArrayLike_js_1.default;
	var isArrayLikeObject_js_1 = isArrayLikeObject_1;
	exports.isArrayLikeObject = isArrayLikeObject_js_1.default;
	var isBoolean_js_1 = isBoolean_1;
	exports.isBoolean = isBoolean_js_1.default;
	var isBuffer_js_1 = isBuffer_1;
	exports.isBuffer = isBuffer_js_1.default;
	var isDate_js_1 = isDate_1;
	exports.isDate = isDate_js_1.default;
	var isElement_js_1 = isElement_1;
	exports.isElement = isElement_js_1.default;
	var isEmpty_js_1 = isEmpty_1;
	exports.isEmpty = isEmpty_js_1.default;
	var isEqual_js_1 = isEqual_1;
	exports.isEqual = isEqual_js_1.default;
	var isEqualWith_js_1 = isEqualWith_1;
	exports.isEqualWith = isEqualWith_js_1.default;
	var isError_js_1 = isError_1;
	exports.isError = isError_js_1.default;
	var isFinite_js_1 = _isFinite;
	exports.isFinite = isFinite_js_1.default;
	var isFunction_js_1 = isFunction_1;
	exports.isFunction = isFunction_js_1.default;
	var isInteger_js_1 = isInteger_1;
	exports.isInteger = isInteger_js_1.default;
	var isLength_js_1 = isLength_1;
	exports.isLength = isLength_js_1.default;
	var isMap_js_1 = isMap_1;
	exports.isMap = isMap_js_1.default;
	var isMatch_js_1 = isMatch_1;
	exports.isMatch = isMatch_js_1.default;
	var isMatchWith_js_1 = isMatchWith_1;
	exports.isMatchWith = isMatchWith_js_1.default;
	var isNaN_js_1 = _isNaN;
	exports.isNaN = isNaN_js_1.default;
	var isNative_js_1 = isNative_1;
	exports.isNative = isNative_js_1.default;
	var isNil_js_1 = isNil_1;
	exports.isNil = isNil_js_1.default;
	var isNull_js_1 = isNull_1;
	exports.isNull = isNull_js_1.default;
	var isNumber_js_1 = isNumber_1;
	exports.isNumber = isNumber_js_1.default;
	var isObject_js_1 = isObject_1;
	exports.isObject = isObject_js_1.default;
	var isObjectLike_js_1 = isObjectLike_1;
	exports.isObjectLike = isObjectLike_js_1.default;
	var isPlainObject_js_1 = isPlainObject_1;
	exports.isPlainObject = isPlainObject_js_1.default;
	var isRegExp_js_1 = isRegExp_1;
	exports.isRegExp = isRegExp_js_1.default;
	var isSafeInteger_js_1 = isSafeInteger_1;
	exports.isSafeInteger = isSafeInteger_js_1.default;
	var isSet_js_1 = isSet_1;
	exports.isSet = isSet_js_1.default;
	var isString_js_1 = isString_1;
	exports.isString = isString_js_1.default;
	var isSymbol_js_1 = isSymbol_1;
	exports.isSymbol = isSymbol_js_1.default;
	var isTypedArray_js_1 = isTypedArray_1;
	exports.isTypedArray = isTypedArray_js_1.default;
	var isUndefined_js_1 = isUndefined_1;
	exports.isUndefined = isUndefined_js_1.default;
	var isWeakMap_js_1 = isWeakMap_1;
	exports.isWeakMap = isWeakMap_js_1.default;
	var isWeakSet_js_1 = isWeakSet_1;
	exports.isWeakSet = isWeakSet_js_1.default;
	var lt_js_1 = lt_1;
	exports.lt = lt_js_1.default;
	var lte_js_1 = lte_1;
	exports.lte = lte_js_1.default;
	var toArray_js_1 = toArray_1;
	exports.toArray = toArray_js_1.default;
	var toFinite_js_1 = toFinite_1;
	exports.toFinite = toFinite_js_1.default;
	var toInteger_js_1 = toInteger_1;
	exports.toInteger = toInteger_js_1.default;
	var toLength_js_1 = toLength_1;
	exports.toLength = toLength_js_1.default;
	var toNumber_js_1 = toNumber_1;
	exports.toNumber = toNumber_js_1.default;
	var toPlainObject_js_1 = toPlainObject_1;
	exports.toPlainObject = toPlainObject_js_1.default;
	var toSafeInteger_js_1 = toSafeInteger_1;
	exports.toSafeInteger = toSafeInteger_js_1.default;
	var toString_js_1 = toString_1;
	exports.toString = toString_js_1.default;
	var lang_default_js_1 = lang_default;
	exports.default = lang_default_js_1.default;
	});

	var math_default = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var add_js_1 = add_1;
	var ceil_js_1 = ceil_1;
	var divide_js_1 = divide_1;
	var floor_js_1 = floor_1;
	var max_js_1 = max_1;
	var maxBy_js_1 = maxBy_1;
	var mean_js_1 = mean_1;
	var meanBy_js_1 = meanBy_1;
	var min_js_1 = min_1;
	var minBy_js_1 = minBy_1;
	var multiply_js_1 = multiply_1;
	var round_js_1 = round_1;
	var subtract_js_1 = subtract_1;
	var sum_js_1 = sum_1;
	var sumBy_js_1 = sumBy_1;
	exports.default = {
	    add: add_js_1.default, ceil: ceil_js_1.default, divide: divide_js_1.default, floor: floor_js_1.default, max: max_js_1.default,
	    maxBy: maxBy_js_1.default, mean: mean_js_1.default, meanBy: meanBy_js_1.default, min: min_js_1.default, minBy: minBy_js_1.default,
	    multiply: multiply_js_1.default, round: round_js_1.default, subtract: subtract_js_1.default, sum: sum_js_1.default, sumBy: sumBy_js_1.default
	};
	});

	var math = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var add_js_1 = add_1;
	exports.add = add_js_1.default;
	var ceil_js_1 = ceil_1;
	exports.ceil = ceil_js_1.default;
	var divide_js_1 = divide_1;
	exports.divide = divide_js_1.default;
	var floor_js_1 = floor_1;
	exports.floor = floor_js_1.default;
	var max_js_1 = max_1;
	exports.max = max_js_1.default;
	var maxBy_js_1 = maxBy_1;
	exports.maxBy = maxBy_js_1.default;
	var mean_js_1 = mean_1;
	exports.mean = mean_js_1.default;
	var meanBy_js_1 = meanBy_1;
	exports.meanBy = meanBy_js_1.default;
	var min_js_1 = min_1;
	exports.min = min_js_1.default;
	var minBy_js_1 = minBy_1;
	exports.minBy = minBy_js_1.default;
	var multiply_js_1 = multiply_1;
	exports.multiply = multiply_js_1.default;
	var round_js_1 = round_1;
	exports.round = round_js_1.default;
	var subtract_js_1 = subtract_1;
	exports.subtract = subtract_js_1.default;
	var sum_js_1 = sum_1;
	exports.sum = sum_js_1.default;
	var sumBy_js_1 = sumBy_1;
	exports.sumBy = sumBy_js_1.default;
	var math_default_js_1 = math_default;
	exports.default = math_default_js_1.default;
	});

	var number_default = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var clamp_js_1 = clamp_1;
	var inRange_js_1 = inRange_1;
	var random_js_1 = random_1;
	exports.default = {
	    clamp: clamp_js_1.default, inRange: inRange_js_1.default, random: random_js_1.default
	};
	});

	var number = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var clamp_js_1 = clamp_1;
	exports.clamp = clamp_js_1.default;
	var inRange_js_1 = inRange_1;
	exports.inRange = inRange_js_1.default;
	var random_js_1 = random_1;
	exports.random = random_js_1.default;
	var number_default_js_1 = number_default;
	exports.default = number_default_js_1.default;
	});

	var object_default = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var assign_js_1 = assign_1;
	var assignIn_js_1 = assignIn_1;
	var assignInWith_js_1 = assignInWith_1;
	var assignWith_js_1 = assignWith_1;
	var at_js_1 = at_1;
	var create_js_1 = create_1;
	var defaults_js_1 = defaults_1;
	var defaultsDeep_js_1 = defaultsDeep_1;
	var entries_js_1 = entries;
	var entriesIn_js_1 = entriesIn;
	var extend_js_1 = extend;
	var extendWith_js_1 = extendWith;
	var findKey_js_1 = findKey_1;
	var findLastKey_js_1 = findLastKey_1;
	var forIn_js_1 = forIn_1;
	var forInRight_js_1 = forInRight_1;
	var forOwn_js_1 = forOwn_1;
	var forOwnRight_js_1 = forOwnRight_1;
	var functions_js_1 = functions_1;
	var functionsIn_js_1 = functionsIn_1;
	var get_js_1 = get_1;
	var has_js_1 = has_1;
	var hasIn_js_1 = hasIn_1;
	var invert_js_1 = invert_1;
	var invertBy_js_1 = invertBy_1;
	var invoke_js_1 = invoke_1;
	var keys_js_1 = keys_1;
	var keysIn_js_1 = keysIn_1;
	var mapKeys_js_1 = mapKeys_1;
	var mapValues_js_1 = mapValues_1;
	var merge_js_1 = merge_1;
	var mergeWith_js_1 = mergeWith_1;
	var omit_js_1 = omit_1;
	var omitBy_js_1 = omitBy_1;
	var pick_js_1 = pick_1;
	var pickBy_js_1 = pickBy_1;
	var result_js_1 = result_1;
	var set_js_1 = set_1;
	var setWith_js_1 = setWith_1;
	var toPairs_js_1 = toPairs_1;
	var toPairsIn_js_1 = toPairsIn_1;
	var transform_js_1 = transform_1;
	var unset_js_1 = unset_1;
	var update_js_1 = update_1;
	var updateWith_js_1 = updateWith_1;
	var values_js_1 = values_1;
	var valuesIn_js_1 = valuesIn_1;
	exports.default = {
	    assign: assign_js_1.default, assignIn: assignIn_js_1.default, assignInWith: assignInWith_js_1.default, assignWith: assignWith_js_1.default, at: at_js_1.default,
	    create: create_js_1.default, defaults: defaults_js_1.default, defaultsDeep: defaultsDeep_js_1.default, entries: entries_js_1.default, entriesIn: entriesIn_js_1.default,
	    extend: extend_js_1.default, extendWith: extendWith_js_1.default, findKey: findKey_js_1.default, findLastKey: findLastKey_js_1.default, forIn: forIn_js_1.default,
	    forInRight: forInRight_js_1.default, forOwn: forOwn_js_1.default, forOwnRight: forOwnRight_js_1.default, functions: functions_js_1.default, functionsIn: functionsIn_js_1.default,
	    get: get_js_1.default, has: has_js_1.default, hasIn: hasIn_js_1.default, invert: invert_js_1.default, invertBy: invertBy_js_1.default,
	    invoke: invoke_js_1.default, keys: keys_js_1.default, keysIn: keysIn_js_1.default, mapKeys: mapKeys_js_1.default, mapValues: mapValues_js_1.default,
	    merge: merge_js_1.default, mergeWith: mergeWith_js_1.default, omit: omit_js_1.default, omitBy: omitBy_js_1.default, pick: pick_js_1.default,
	    pickBy: pickBy_js_1.default, result: result_js_1.default, set: set_js_1.default, setWith: setWith_js_1.default, toPairs: toPairs_js_1.default,
	    toPairsIn: toPairsIn_js_1.default, transform: transform_js_1.default, unset: unset_js_1.default, update: update_js_1.default, updateWith: updateWith_js_1.default,
	    values: values_js_1.default, valuesIn: valuesIn_js_1.default
	};
	});

	var object = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var assign_js_1 = assign_1;
	exports.assign = assign_js_1.default;
	var assignIn_js_1 = assignIn_1;
	exports.assignIn = assignIn_js_1.default;
	var assignInWith_js_1 = assignInWith_1;
	exports.assignInWith = assignInWith_js_1.default;
	var assignWith_js_1 = assignWith_1;
	exports.assignWith = assignWith_js_1.default;
	var at_js_1 = at_1;
	exports.at = at_js_1.default;
	var create_js_1 = create_1;
	exports.create = create_js_1.default;
	var defaults_js_1 = defaults_1;
	exports.defaults = defaults_js_1.default;
	var defaultsDeep_js_1 = defaultsDeep_1;
	exports.defaultsDeep = defaultsDeep_js_1.default;
	var entries_js_1 = entries;
	exports.entries = entries_js_1.default;
	var entriesIn_js_1 = entriesIn;
	exports.entriesIn = entriesIn_js_1.default;
	var extend_js_1 = extend;
	exports.extend = extend_js_1.default;
	var extendWith_js_1 = extendWith;
	exports.extendWith = extendWith_js_1.default;
	var findKey_js_1 = findKey_1;
	exports.findKey = findKey_js_1.default;
	var findLastKey_js_1 = findLastKey_1;
	exports.findLastKey = findLastKey_js_1.default;
	var forIn_js_1 = forIn_1;
	exports.forIn = forIn_js_1.default;
	var forInRight_js_1 = forInRight_1;
	exports.forInRight = forInRight_js_1.default;
	var forOwn_js_1 = forOwn_1;
	exports.forOwn = forOwn_js_1.default;
	var forOwnRight_js_1 = forOwnRight_1;
	exports.forOwnRight = forOwnRight_js_1.default;
	var functions_js_1 = functions_1;
	exports.functions = functions_js_1.default;
	var functionsIn_js_1 = functionsIn_1;
	exports.functionsIn = functionsIn_js_1.default;
	var get_js_1 = get_1;
	exports.get = get_js_1.default;
	var has_js_1 = has_1;
	exports.has = has_js_1.default;
	var hasIn_js_1 = hasIn_1;
	exports.hasIn = hasIn_js_1.default;
	var invert_js_1 = invert_1;
	exports.invert = invert_js_1.default;
	var invertBy_js_1 = invertBy_1;
	exports.invertBy = invertBy_js_1.default;
	var invoke_js_1 = invoke_1;
	exports.invoke = invoke_js_1.default;
	var keys_js_1 = keys_1;
	exports.keys = keys_js_1.default;
	var keysIn_js_1 = keysIn_1;
	exports.keysIn = keysIn_js_1.default;
	var mapKeys_js_1 = mapKeys_1;
	exports.mapKeys = mapKeys_js_1.default;
	var mapValues_js_1 = mapValues_1;
	exports.mapValues = mapValues_js_1.default;
	var merge_js_1 = merge_1;
	exports.merge = merge_js_1.default;
	var mergeWith_js_1 = mergeWith_1;
	exports.mergeWith = mergeWith_js_1.default;
	var omit_js_1 = omit_1;
	exports.omit = omit_js_1.default;
	var omitBy_js_1 = omitBy_1;
	exports.omitBy = omitBy_js_1.default;
	var pick_js_1 = pick_1;
	exports.pick = pick_js_1.default;
	var pickBy_js_1 = pickBy_1;
	exports.pickBy = pickBy_js_1.default;
	var result_js_1 = result_1;
	exports.result = result_js_1.default;
	var set_js_1 = set_1;
	exports.set = set_js_1.default;
	var setWith_js_1 = setWith_1;
	exports.setWith = setWith_js_1.default;
	var toPairs_js_1 = toPairs_1;
	exports.toPairs = toPairs_js_1.default;
	var toPairsIn_js_1 = toPairsIn_1;
	exports.toPairsIn = toPairsIn_js_1.default;
	var transform_js_1 = transform_1;
	exports.transform = transform_js_1.default;
	var unset_js_1 = unset_1;
	exports.unset = unset_js_1.default;
	var update_js_1 = update_1;
	exports.update = update_js_1.default;
	var updateWith_js_1 = updateWith_1;
	exports.updateWith = updateWith_js_1.default;
	var values_js_1 = values_1;
	exports.values = values_js_1.default;
	var valuesIn_js_1 = valuesIn_1;
	exports.valuesIn = valuesIn_js_1.default;
	var object_default_js_1 = object_default;
	exports.default = object_default_js_1.default;
	});

	var seq_default = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var wrapperAt_js_1 = wrapperAt_1;
	var chain_js_1 = chain_1;
	var commit_js_1 = commit;
	var wrapperLodash_js_1 = wrapperLodash;
	var next_js_1 = next;
	var plant_js_1 = plant;
	var wrapperReverse_js_1 = wrapperReverse_1;
	var tap_js_1 = tap_1;
	var thru_js_1 = thru_1;
	var toIterator_js_1 = toIterator;
	var toJSON_js_1 = toJSON;
	var wrapperValue_js_1 = wrapperValue_1;
	var valueOf_js_1 = valueOf_1;
	var wrapperChain_js_1 = wrapperChain_1;
	exports.default = {
	    at: wrapperAt_js_1.default, chain: chain_js_1.default, commit: commit_js_1.default, lodash: wrapperLodash_js_1.default, next: next_js_1.default,
	    plant: plant_js_1.default, reverse: wrapperReverse_js_1.default, tap: tap_js_1.default, thru: thru_js_1.default, toIterator: toIterator_js_1.default,
	    toJSON: toJSON_js_1.default, value: wrapperValue_js_1.default, valueOf: valueOf_js_1.default, wrapperChain: wrapperChain_js_1.default
	};
	});

	var seq = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var wrapperAt_js_1 = wrapperAt_1;
	exports.at = wrapperAt_js_1.default;
	var chain_js_1 = chain_1;
	exports.chain = chain_js_1.default;
	var commit_js_1 = commit;
	exports.commit = commit_js_1.default;
	var wrapperLodash_js_1 = wrapperLodash;
	exports.lodash = wrapperLodash_js_1.default;
	var next_js_1 = next;
	exports.next = next_js_1.default;
	var plant_js_1 = plant;
	exports.plant = plant_js_1.default;
	var wrapperReverse_js_1 = wrapperReverse_1;
	exports.reverse = wrapperReverse_js_1.default;
	var tap_js_1 = tap_1;
	exports.tap = tap_js_1.default;
	var thru_js_1 = thru_1;
	exports.thru = thru_js_1.default;
	var toIterator_js_1 = toIterator;
	exports.toIterator = toIterator_js_1.default;
	var toJSON_js_1 = toJSON;
	exports.toJSON = toJSON_js_1.default;
	var wrapperValue_js_1 = wrapperValue_1;
	exports.value = wrapperValue_js_1.default;
	var valueOf_js_1 = valueOf_1;
	exports.valueOf = valueOf_js_1.default;
	var wrapperChain_js_1 = wrapperChain_1;
	exports.wrapperChain = wrapperChain_js_1.default;
	var seq_default_js_1 = seq_default;
	exports.default = seq_default_js_1.default;
	});

	var string_default = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var camelCase_js_1 = camelCase_1;
	var capitalize_js_1 = capitalize_1;
	var deburr_js_1 = deburr_1;
	var endsWith_js_1 = endsWith_1;
	var escape_js_1 = _escape;
	var escapeRegExp_js_1 = escapeRegExp_1;
	var kebabCase_js_1 = kebabCase_1;
	var lowerCase_js_1 = lowerCase_1;
	var lowerFirst_js_1 = lowerFirst_1;
	var pad_js_1 = pad_1;
	var padEnd_js_1 = padEnd_1;
	var padStart_js_1 = padStart_1;
	var parseInt_js_1 = _parseInt;
	var repeat_js_1 = repeat_1;
	var replace_js_1 = replace_1;
	var snakeCase_js_1 = snakeCase_1;
	var split_js_1 = split_1;
	var startCase_js_1 = startCase_1;
	var startsWith_js_1 = startsWith_1;
	var template_js_1 = template_1;
	var templateSettings_js_1 = templateSettings_1;
	var toLower_js_1 = toLower_1;
	var toUpper_js_1 = toUpper_1;
	var trim_js_1 = trim_1;
	var trimEnd_js_1 = trimEnd_1;
	var trimStart_js_1 = trimStart_1;
	var truncate_js_1 = truncate_1;
	var unescape_js_1 = _unescape;
	var upperCase_js_1 = upperCase_1;
	var upperFirst_js_1 = upperFirst_1;
	var words_js_1 = words_1;
	exports.default = {
	    camelCase: camelCase_js_1.default, capitalize: capitalize_js_1.default, deburr: deburr_js_1.default, endsWith: endsWith_js_1.default, escape: escape_js_1.default,
	    escapeRegExp: escapeRegExp_js_1.default, kebabCase: kebabCase_js_1.default, lowerCase: lowerCase_js_1.default, lowerFirst: lowerFirst_js_1.default, pad: pad_js_1.default,
	    padEnd: padEnd_js_1.default, padStart: padStart_js_1.default, parseInt: parseInt_js_1.default, repeat: repeat_js_1.default, replace: replace_js_1.default,
	    snakeCase: snakeCase_js_1.default, split: split_js_1.default, startCase: startCase_js_1.default, startsWith: startsWith_js_1.default, template: template_js_1.default,
	    templateSettings: templateSettings_js_1.default, toLower: toLower_js_1.default, toUpper: toUpper_js_1.default, trim: trim_js_1.default, trimEnd: trimEnd_js_1.default,
	    trimStart: trimStart_js_1.default, truncate: truncate_js_1.default, unescape: unescape_js_1.default, upperCase: upperCase_js_1.default, upperFirst: upperFirst_js_1.default,
	    words: words_js_1.default
	};
	});

	var string = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var camelCase_js_1 = camelCase_1;
	exports.camelCase = camelCase_js_1.default;
	var capitalize_js_1 = capitalize_1;
	exports.capitalize = capitalize_js_1.default;
	var deburr_js_1 = deburr_1;
	exports.deburr = deburr_js_1.default;
	var endsWith_js_1 = endsWith_1;
	exports.endsWith = endsWith_js_1.default;
	var escape_js_1 = _escape;
	exports.escape = escape_js_1.default;
	var escapeRegExp_js_1 = escapeRegExp_1;
	exports.escapeRegExp = escapeRegExp_js_1.default;
	var kebabCase_js_1 = kebabCase_1;
	exports.kebabCase = kebabCase_js_1.default;
	var lowerCase_js_1 = lowerCase_1;
	exports.lowerCase = lowerCase_js_1.default;
	var lowerFirst_js_1 = lowerFirst_1;
	exports.lowerFirst = lowerFirst_js_1.default;
	var pad_js_1 = pad_1;
	exports.pad = pad_js_1.default;
	var padEnd_js_1 = padEnd_1;
	exports.padEnd = padEnd_js_1.default;
	var padStart_js_1 = padStart_1;
	exports.padStart = padStart_js_1.default;
	var parseInt_js_1 = _parseInt;
	exports.parseInt = parseInt_js_1.default;
	var repeat_js_1 = repeat_1;
	exports.repeat = repeat_js_1.default;
	var replace_js_1 = replace_1;
	exports.replace = replace_js_1.default;
	var snakeCase_js_1 = snakeCase_1;
	exports.snakeCase = snakeCase_js_1.default;
	var split_js_1 = split_1;
	exports.split = split_js_1.default;
	var startCase_js_1 = startCase_1;
	exports.startCase = startCase_js_1.default;
	var startsWith_js_1 = startsWith_1;
	exports.startsWith = startsWith_js_1.default;
	var template_js_1 = template_1;
	exports.template = template_js_1.default;
	var templateSettings_js_1 = templateSettings_1;
	exports.templateSettings = templateSettings_js_1.default;
	var toLower_js_1 = toLower_1;
	exports.toLower = toLower_js_1.default;
	var toUpper_js_1 = toUpper_1;
	exports.toUpper = toUpper_js_1.default;
	var trim_js_1 = trim_1;
	exports.trim = trim_js_1.default;
	var trimEnd_js_1 = trimEnd_1;
	exports.trimEnd = trimEnd_js_1.default;
	var trimStart_js_1 = trimStart_1;
	exports.trimStart = trimStart_js_1.default;
	var truncate_js_1 = truncate_1;
	exports.truncate = truncate_js_1.default;
	var unescape_js_1 = _unescape;
	exports.unescape = unescape_js_1.default;
	var upperCase_js_1 = upperCase_1;
	exports.upperCase = upperCase_js_1.default;
	var upperFirst_js_1 = upperFirst_1;
	exports.upperFirst = upperFirst_js_1.default;
	var words_js_1 = words_1;
	exports.words = words_js_1.default;
	var string_default_js_1 = string_default;
	exports.default = string_default_js_1.default;
	});

	var util_default = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var attempt_js_1 = attempt_1;
	var bindAll_js_1 = bindAll_1;
	var cond_js_1 = cond_1;
	var conforms_js_1 = conforms_1;
	var constant_js_1 = constant_1;
	var defaultTo_js_1 = defaultTo_1;
	var flow_js_1 = flow_1;
	var flowRight_js_1 = flowRight_1;
	var identity_js_1 = identity_1;
	var iteratee_js_1 = iteratee_1;
	var matches_js_1 = matches_1;
	var matchesProperty_js_1 = matchesProperty_1;
	var method_js_1 = method_1;
	var methodOf_js_1 = methodOf_1;
	var mixin_js_1 = mixin_1;
	var noop_js_1 = noop_1;
	var nthArg_js_1 = nthArg_1;
	var over_js_1 = over_1;
	var overEvery_js_1 = overEvery_1;
	var overSome_js_1 = overSome_1;
	var property_js_1 = property_1;
	var propertyOf_js_1 = propertyOf_1;
	var range_js_1 = range_1;
	var rangeRight_js_1 = rangeRight_1;
	var stubArray_js_1 = stubArray_1;
	var stubFalse_js_1 = stubFalse_1;
	var stubObject_js_1 = stubObject_1;
	var stubString_js_1 = stubString_1;
	var stubTrue_js_1 = stubTrue_1;
	var times_js_1 = times_1;
	var toPath_js_1 = toPath_1;
	var uniqueId_js_1 = uniqueId_1;
	exports.default = {
	    attempt: attempt_js_1.default, bindAll: bindAll_js_1.default, cond: cond_js_1.default, conforms: conforms_js_1.default, constant: constant_js_1.default,
	    defaultTo: defaultTo_js_1.default, flow: flow_js_1.default, flowRight: flowRight_js_1.default, identity: identity_js_1.default, iteratee: iteratee_js_1.default,
	    matches: matches_js_1.default, matchesProperty: matchesProperty_js_1.default, method: method_js_1.default, methodOf: methodOf_js_1.default, mixin: mixin_js_1.default,
	    noop: noop_js_1.default, nthArg: nthArg_js_1.default, over: over_js_1.default, overEvery: overEvery_js_1.default, overSome: overSome_js_1.default,
	    property: property_js_1.default, propertyOf: propertyOf_js_1.default, range: range_js_1.default, rangeRight: rangeRight_js_1.default, stubArray: stubArray_js_1.default,
	    stubFalse: stubFalse_js_1.default, stubObject: stubObject_js_1.default, stubString: stubString_js_1.default, stubTrue: stubTrue_js_1.default, times: times_js_1.default,
	    toPath: toPath_js_1.default, uniqueId: uniqueId_js_1.default
	};
	});

	var util = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var attempt_js_1 = attempt_1;
	exports.attempt = attempt_js_1.default;
	var bindAll_js_1 = bindAll_1;
	exports.bindAll = bindAll_js_1.default;
	var cond_js_1 = cond_1;
	exports.cond = cond_js_1.default;
	var conforms_js_1 = conforms_1;
	exports.conforms = conforms_js_1.default;
	var constant_js_1 = constant_1;
	exports.constant = constant_js_1.default;
	var defaultTo_js_1 = defaultTo_1;
	exports.defaultTo = defaultTo_js_1.default;
	var flow_js_1 = flow_1;
	exports.flow = flow_js_1.default;
	var flowRight_js_1 = flowRight_1;
	exports.flowRight = flowRight_js_1.default;
	var identity_js_1 = identity_1;
	exports.identity = identity_js_1.default;
	var iteratee_js_1 = iteratee_1;
	exports.iteratee = iteratee_js_1.default;
	var matches_js_1 = matches_1;
	exports.matches = matches_js_1.default;
	var matchesProperty_js_1 = matchesProperty_1;
	exports.matchesProperty = matchesProperty_js_1.default;
	var method_js_1 = method_1;
	exports.method = method_js_1.default;
	var methodOf_js_1 = methodOf_1;
	exports.methodOf = methodOf_js_1.default;
	var mixin_js_1 = mixin_1;
	exports.mixin = mixin_js_1.default;
	var noop_js_1 = noop_1;
	exports.noop = noop_js_1.default;
	var nthArg_js_1 = nthArg_1;
	exports.nthArg = nthArg_js_1.default;
	var over_js_1 = over_1;
	exports.over = over_js_1.default;
	var overEvery_js_1 = overEvery_1;
	exports.overEvery = overEvery_js_1.default;
	var overSome_js_1 = overSome_1;
	exports.overSome = overSome_js_1.default;
	var property_js_1 = property_1;
	exports.property = property_js_1.default;
	var propertyOf_js_1 = propertyOf_1;
	exports.propertyOf = propertyOf_js_1.default;
	var range_js_1 = range_1;
	exports.range = range_js_1.default;
	var rangeRight_js_1 = rangeRight_1;
	exports.rangeRight = rangeRight_js_1.default;
	var stubArray_js_1 = stubArray_1;
	exports.stubArray = stubArray_js_1.default;
	var stubFalse_js_1 = stubFalse_1;
	exports.stubFalse = stubFalse_js_1.default;
	var stubObject_js_1 = stubObject_1;
	exports.stubObject = stubObject_js_1.default;
	var stubString_js_1 = stubString_1;
	exports.stubString = stubString_js_1.default;
	var stubTrue_js_1 = stubTrue_1;
	exports.stubTrue = stubTrue_js_1.default;
	var times_js_1 = times_1;
	exports.times = times_js_1.default;
	var toPath_js_1 = toPath_1;
	exports.toPath = toPath_js_1.default;
	var uniqueId_js_1 = uniqueId_1;
	exports.uniqueId = uniqueId_js_1.default;
	var util_default_js_1 = util_default;
	exports.default = util_default_js_1.default;
	});

	var _lazyClone = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _LazyWrapper_js_1 = _LazyWrapper;
	var _copyArray_js_1 = _copyArray;
	function lazyClone() {
	    var result = new _LazyWrapper_js_1.default(this.__wrapped__);
	    result.__actions__ = _copyArray_js_1.default(this.__actions__);
	    result.__dir__ = this.__dir__;
	    result.__filtered__ = this.__filtered__;
	    result.__iteratees__ = _copyArray_js_1.default(this.__iteratees__);
	    result.__takeCount__ = this.__takeCount__;
	    result.__views__ = _copyArray_js_1.default(this.__views__);
	    return result;
	}
	exports.default = lazyClone;
	});

	var _lazyReverse = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _LazyWrapper_js_1 = _LazyWrapper;
	function lazyReverse() {
	    if (this.__filtered__) {
	        var result = new _LazyWrapper_js_1.default(this);
	        result.__dir__ = -1;
	        result.__filtered__ = true;
	    }
	    else {
	        result = this.clone();
	        result.__dir__ *= -1;
	    }
	    return result;
	}
	exports.default = lazyReverse;
	});

	var _getView = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var nativeMax = Math.max, nativeMin = Math.min;
	function getView(start, end, transforms) {
	    var index = -1, length = transforms.length;
	    while (++index < length) {
	        var data = transforms[index], size = data.size;
	        switch (data.type) {
	            case 'drop':
	                start += size;
	                break;
	            case 'dropRight':
	                end -= size;
	                break;
	            case 'take':
	                end = nativeMin(end, start + size);
	                break;
	            case 'takeRight':
	                start = nativeMax(start, end - size);
	                break;
	        }
	    }
	    return { 'start': start, 'end': end };
	}
	exports.default = getView;
	});

	var _lazyValue = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var _baseWrapperValue_js_1 = _baseWrapperValue;
	var _getView_js_1 = _getView;
	var isArray_js_1 = isArray_1;
	var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2;
	var nativeMin = Math.min;
	function lazyValue() {
	    var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray_js_1.default(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = _getView_js_1.default(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : (start - 1), iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
	    if (!isArr || (!isRight && arrLength == length && takeCount == length)) {
	        return _baseWrapperValue_js_1.default(array, this.__actions__);
	    }
	    var result = [];
	    outer: while (length-- && resIndex < takeCount) {
	        index += dir;
	        var iterIndex = -1, value = array[index];
	        while (++iterIndex < iterLength) {
	            var data = iteratees[iterIndex], iteratee = data.iteratee, type = data.type, computed = iteratee(value);
	            if (type == LAZY_MAP_FLAG) {
	                value = computed;
	            }
	            else if (!computed) {
	                if (type == LAZY_FILTER_FLAG) {
	                    continue outer;
	                }
	                else {
	                    break outer;
	                }
	            }
	        }
	        result[resIndex++] = value;
	    }
	    return result;
	}
	exports.default = lazyValue;
	});

	var lodash_default = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var array_js_1 = array;
	var collection_js_1 = collection;
	var date_js_1 = date;
	var function_js_1 = _function;
	var lang_js_1 = lang;
	var math_js_1 = math;
	var number_js_1 = number;
	var object_js_1 = object;
	var seq_js_1 = seq;
	var string_js_1 = string;
	var util_js_1 = util;
	var _LazyWrapper_js_1 = _LazyWrapper;
	var _LodashWrapper_js_1 = _LodashWrapper;
	var _Symbol_js_1 = _Symbol;
	var _arrayEach_js_1 = _arrayEach;
	var _arrayPush_js_1 = _arrayPush;
	var _baseForOwn_js_1 = _baseForOwn;
	var _baseFunctions_js_1 = _baseFunctions;
	var _baseInvoke_js_1 = _baseInvoke;
	var _baseIteratee_js_1 = _baseIteratee;
	var _baseRest_js_1 = _baseRest;
	var _createHybrid_js_1 = _createHybrid;
	var identity_js_1 = identity_1;
	var isArray_js_1 = isArray_1;
	var isObject_js_1 = isObject_1;
	var keys_js_1 = keys_1;
	var last_js_1 = last_1;
	var _lazyClone_js_1 = _lazyClone;
	var _lazyReverse_js_1 = _lazyReverse;
	var _lazyValue_js_1 = _lazyValue;
	var mixin_js_1 = mixin_1;
	var negate_js_1 = negate_1;
	var _realNames_js_1 = _realNames;
	var thru_js_1 = thru_1;
	var toInteger_js_1 = toInteger_1;
	var wrapperLodash_js_1 = wrapperLodash;
	var VERSION = '4.17.4';
	var WRAP_BIND_KEY_FLAG = 2;
	var LAZY_FILTER_FLAG = 1, LAZY_WHILE_FLAG = 3;
	var MAX_ARRAY_LENGTH = 4294967295;
	var arrayProto = Array.prototype, objectProto = Object.prototype;
	var hasOwnProperty = objectProto.hasOwnProperty;
	var symIterator = _Symbol_js_1.default ? _Symbol_js_1.default.iterator : undefined;
	var nativeMax = Math.max, nativeMin = Math.min;
	var mixin = (function (func) {
	    return function (object$$1, source, options) {
	        if (options == null) {
	            var isObj = isObject_js_1.default(source), props = isObj && keys_js_1.default(source), methodNames = props && props.length && _baseFunctions_js_1.default(source, props);
	            if (!(methodNames ? methodNames.length : isObj)) {
	                options = source;
	                source = object$$1;
	                object$$1 = this;
	            }
	        }
	        return func(object$$1, source, options);
	    };
	}(mixin_js_1.default));
	wrapperLodash_js_1.default.after = function_js_1.default.after;
	wrapperLodash_js_1.default.ary = function_js_1.default.ary;
	wrapperLodash_js_1.default.assign = object_js_1.default.assign;
	wrapperLodash_js_1.default.assignIn = object_js_1.default.assignIn;
	wrapperLodash_js_1.default.assignInWith = object_js_1.default.assignInWith;
	wrapperLodash_js_1.default.assignWith = object_js_1.default.assignWith;
	wrapperLodash_js_1.default.at = object_js_1.default.at;
	wrapperLodash_js_1.default.before = function_js_1.default.before;
	wrapperLodash_js_1.default.bind = function_js_1.default.bind;
	wrapperLodash_js_1.default.bindAll = util_js_1.default.bindAll;
	wrapperLodash_js_1.default.bindKey = function_js_1.default.bindKey;
	wrapperLodash_js_1.default.castArray = lang_js_1.default.castArray;
	wrapperLodash_js_1.default.chain = seq_js_1.default.chain;
	wrapperLodash_js_1.default.chunk = array_js_1.default.chunk;
	wrapperLodash_js_1.default.compact = array_js_1.default.compact;
	wrapperLodash_js_1.default.concat = array_js_1.default.concat;
	wrapperLodash_js_1.default.cond = util_js_1.default.cond;
	wrapperLodash_js_1.default.conforms = util_js_1.default.conforms;
	wrapperLodash_js_1.default.constant = util_js_1.default.constant;
	wrapperLodash_js_1.default.countBy = collection_js_1.default.countBy;
	wrapperLodash_js_1.default.create = object_js_1.default.create;
	wrapperLodash_js_1.default.curry = function_js_1.default.curry;
	wrapperLodash_js_1.default.curryRight = function_js_1.default.curryRight;
	wrapperLodash_js_1.default.debounce = function_js_1.default.debounce;
	wrapperLodash_js_1.default.defaults = object_js_1.default.defaults;
	wrapperLodash_js_1.default.defaultsDeep = object_js_1.default.defaultsDeep;
	wrapperLodash_js_1.default.defer = function_js_1.default.defer;
	wrapperLodash_js_1.default.delay = function_js_1.default.delay;
	wrapperLodash_js_1.default.difference = array_js_1.default.difference;
	wrapperLodash_js_1.default.differenceBy = array_js_1.default.differenceBy;
	wrapperLodash_js_1.default.differenceWith = array_js_1.default.differenceWith;
	wrapperLodash_js_1.default.drop = array_js_1.default.drop;
	wrapperLodash_js_1.default.dropRight = array_js_1.default.dropRight;
	wrapperLodash_js_1.default.dropRightWhile = array_js_1.default.dropRightWhile;
	wrapperLodash_js_1.default.dropWhile = array_js_1.default.dropWhile;
	wrapperLodash_js_1.default.fill = array_js_1.default.fill;
	wrapperLodash_js_1.default.filter = collection_js_1.default.filter;
	wrapperLodash_js_1.default.flatMap = collection_js_1.default.flatMap;
	wrapperLodash_js_1.default.flatMapDeep = collection_js_1.default.flatMapDeep;
	wrapperLodash_js_1.default.flatMapDepth = collection_js_1.default.flatMapDepth;
	wrapperLodash_js_1.default.flatten = array_js_1.default.flatten;
	wrapperLodash_js_1.default.flattenDeep = array_js_1.default.flattenDeep;
	wrapperLodash_js_1.default.flattenDepth = array_js_1.default.flattenDepth;
	wrapperLodash_js_1.default.flip = function_js_1.default.flip;
	wrapperLodash_js_1.default.flow = util_js_1.default.flow;
	wrapperLodash_js_1.default.flowRight = util_js_1.default.flowRight;
	wrapperLodash_js_1.default.fromPairs = array_js_1.default.fromPairs;
	wrapperLodash_js_1.default.functions = object_js_1.default.functions;
	wrapperLodash_js_1.default.functionsIn = object_js_1.default.functionsIn;
	wrapperLodash_js_1.default.groupBy = collection_js_1.default.groupBy;
	wrapperLodash_js_1.default.initial = array_js_1.default.initial;
	wrapperLodash_js_1.default.intersection = array_js_1.default.intersection;
	wrapperLodash_js_1.default.intersectionBy = array_js_1.default.intersectionBy;
	wrapperLodash_js_1.default.intersectionWith = array_js_1.default.intersectionWith;
	wrapperLodash_js_1.default.invert = object_js_1.default.invert;
	wrapperLodash_js_1.default.invertBy = object_js_1.default.invertBy;
	wrapperLodash_js_1.default.invokeMap = collection_js_1.default.invokeMap;
	wrapperLodash_js_1.default.iteratee = util_js_1.default.iteratee;
	wrapperLodash_js_1.default.keyBy = collection_js_1.default.keyBy;
	wrapperLodash_js_1.default.keys = keys_js_1.default;
	wrapperLodash_js_1.default.keysIn = object_js_1.default.keysIn;
	wrapperLodash_js_1.default.map = collection_js_1.default.map;
	wrapperLodash_js_1.default.mapKeys = object_js_1.default.mapKeys;
	wrapperLodash_js_1.default.mapValues = object_js_1.default.mapValues;
	wrapperLodash_js_1.default.matches = util_js_1.default.matches;
	wrapperLodash_js_1.default.matchesProperty = util_js_1.default.matchesProperty;
	wrapperLodash_js_1.default.memoize = function_js_1.default.memoize;
	wrapperLodash_js_1.default.merge = object_js_1.default.merge;
	wrapperLodash_js_1.default.mergeWith = object_js_1.default.mergeWith;
	wrapperLodash_js_1.default.method = util_js_1.default.method;
	wrapperLodash_js_1.default.methodOf = util_js_1.default.methodOf;
	wrapperLodash_js_1.default.mixin = mixin;
	wrapperLodash_js_1.default.negate = negate_js_1.default;
	wrapperLodash_js_1.default.nthArg = util_js_1.default.nthArg;
	wrapperLodash_js_1.default.omit = object_js_1.default.omit;
	wrapperLodash_js_1.default.omitBy = object_js_1.default.omitBy;
	wrapperLodash_js_1.default.once = function_js_1.default.once;
	wrapperLodash_js_1.default.orderBy = collection_js_1.default.orderBy;
	wrapperLodash_js_1.default.over = util_js_1.default.over;
	wrapperLodash_js_1.default.overArgs = function_js_1.default.overArgs;
	wrapperLodash_js_1.default.overEvery = util_js_1.default.overEvery;
	wrapperLodash_js_1.default.overSome = util_js_1.default.overSome;
	wrapperLodash_js_1.default.partial = function_js_1.default.partial;
	wrapperLodash_js_1.default.partialRight = function_js_1.default.partialRight;
	wrapperLodash_js_1.default.partition = collection_js_1.default.partition;
	wrapperLodash_js_1.default.pick = object_js_1.default.pick;
	wrapperLodash_js_1.default.pickBy = object_js_1.default.pickBy;
	wrapperLodash_js_1.default.property = util_js_1.default.property;
	wrapperLodash_js_1.default.propertyOf = util_js_1.default.propertyOf;
	wrapperLodash_js_1.default.pull = array_js_1.default.pull;
	wrapperLodash_js_1.default.pullAll = array_js_1.default.pullAll;
	wrapperLodash_js_1.default.pullAllBy = array_js_1.default.pullAllBy;
	wrapperLodash_js_1.default.pullAllWith = array_js_1.default.pullAllWith;
	wrapperLodash_js_1.default.pullAt = array_js_1.default.pullAt;
	wrapperLodash_js_1.default.range = util_js_1.default.range;
	wrapperLodash_js_1.default.rangeRight = util_js_1.default.rangeRight;
	wrapperLodash_js_1.default.rearg = function_js_1.default.rearg;
	wrapperLodash_js_1.default.reject = collection_js_1.default.reject;
	wrapperLodash_js_1.default.remove = array_js_1.default.remove;
	wrapperLodash_js_1.default.rest = function_js_1.default.rest;
	wrapperLodash_js_1.default.reverse = array_js_1.default.reverse;
	wrapperLodash_js_1.default.sampleSize = collection_js_1.default.sampleSize;
	wrapperLodash_js_1.default.set = object_js_1.default.set;
	wrapperLodash_js_1.default.setWith = object_js_1.default.setWith;
	wrapperLodash_js_1.default.shuffle = collection_js_1.default.shuffle;
	wrapperLodash_js_1.default.slice = array_js_1.default.slice;
	wrapperLodash_js_1.default.sortBy = collection_js_1.default.sortBy;
	wrapperLodash_js_1.default.sortedUniq = array_js_1.default.sortedUniq;
	wrapperLodash_js_1.default.sortedUniqBy = array_js_1.default.sortedUniqBy;
	wrapperLodash_js_1.default.split = string_js_1.default.split;
	wrapperLodash_js_1.default.spread = function_js_1.default.spread;
	wrapperLodash_js_1.default.tail = array_js_1.default.tail;
	wrapperLodash_js_1.default.take = array_js_1.default.take;
	wrapperLodash_js_1.default.takeRight = array_js_1.default.takeRight;
	wrapperLodash_js_1.default.takeRightWhile = array_js_1.default.takeRightWhile;
	wrapperLodash_js_1.default.takeWhile = array_js_1.default.takeWhile;
	wrapperLodash_js_1.default.tap = seq_js_1.default.tap;
	wrapperLodash_js_1.default.throttle = function_js_1.default.throttle;
	wrapperLodash_js_1.default.thru = thru_js_1.default;
	wrapperLodash_js_1.default.toArray = lang_js_1.default.toArray;
	wrapperLodash_js_1.default.toPairs = object_js_1.default.toPairs;
	wrapperLodash_js_1.default.toPairsIn = object_js_1.default.toPairsIn;
	wrapperLodash_js_1.default.toPath = util_js_1.default.toPath;
	wrapperLodash_js_1.default.toPlainObject = lang_js_1.default.toPlainObject;
	wrapperLodash_js_1.default.transform = object_js_1.default.transform;
	wrapperLodash_js_1.default.unary = function_js_1.default.unary;
	wrapperLodash_js_1.default.union = array_js_1.default.union;
	wrapperLodash_js_1.default.unionBy = array_js_1.default.unionBy;
	wrapperLodash_js_1.default.unionWith = array_js_1.default.unionWith;
	wrapperLodash_js_1.default.uniq = array_js_1.default.uniq;
	wrapperLodash_js_1.default.uniqBy = array_js_1.default.uniqBy;
	wrapperLodash_js_1.default.uniqWith = array_js_1.default.uniqWith;
	wrapperLodash_js_1.default.unset = object_js_1.default.unset;
	wrapperLodash_js_1.default.unzip = array_js_1.default.unzip;
	wrapperLodash_js_1.default.unzipWith = array_js_1.default.unzipWith;
	wrapperLodash_js_1.default.update = object_js_1.default.update;
	wrapperLodash_js_1.default.updateWith = object_js_1.default.updateWith;
	wrapperLodash_js_1.default.values = object_js_1.default.values;
	wrapperLodash_js_1.default.valuesIn = object_js_1.default.valuesIn;
	wrapperLodash_js_1.default.without = array_js_1.default.without;
	wrapperLodash_js_1.default.words = string_js_1.default.words;
	wrapperLodash_js_1.default.wrap = function_js_1.default.wrap;
	wrapperLodash_js_1.default.xor = array_js_1.default.xor;
	wrapperLodash_js_1.default.xorBy = array_js_1.default.xorBy;
	wrapperLodash_js_1.default.xorWith = array_js_1.default.xorWith;
	wrapperLodash_js_1.default.zip = array_js_1.default.zip;
	wrapperLodash_js_1.default.zipObject = array_js_1.default.zipObject;
	wrapperLodash_js_1.default.zipObjectDeep = array_js_1.default.zipObjectDeep;
	wrapperLodash_js_1.default.zipWith = array_js_1.default.zipWith;
	wrapperLodash_js_1.default.entries = object_js_1.default.toPairs;
	wrapperLodash_js_1.default.entriesIn = object_js_1.default.toPairsIn;
	wrapperLodash_js_1.default.extend = object_js_1.default.assignIn;
	wrapperLodash_js_1.default.extendWith = object_js_1.default.assignInWith;
	mixin(wrapperLodash_js_1.default, wrapperLodash_js_1.default);
	wrapperLodash_js_1.default.add = math_js_1.default.add;
	wrapperLodash_js_1.default.attempt = util_js_1.default.attempt;
	wrapperLodash_js_1.default.camelCase = string_js_1.default.camelCase;
	wrapperLodash_js_1.default.capitalize = string_js_1.default.capitalize;
	wrapperLodash_js_1.default.ceil = math_js_1.default.ceil;
	wrapperLodash_js_1.default.clamp = number_js_1.default.clamp;
	wrapperLodash_js_1.default.clone = lang_js_1.default.clone;
	wrapperLodash_js_1.default.cloneDeep = lang_js_1.default.cloneDeep;
	wrapperLodash_js_1.default.cloneDeepWith = lang_js_1.default.cloneDeepWith;
	wrapperLodash_js_1.default.cloneWith = lang_js_1.default.cloneWith;
	wrapperLodash_js_1.default.conformsTo = lang_js_1.default.conformsTo;
	wrapperLodash_js_1.default.deburr = string_js_1.default.deburr;
	wrapperLodash_js_1.default.defaultTo = util_js_1.default.defaultTo;
	wrapperLodash_js_1.default.divide = math_js_1.default.divide;
	wrapperLodash_js_1.default.endsWith = string_js_1.default.endsWith;
	wrapperLodash_js_1.default.eq = lang_js_1.default.eq;
	wrapperLodash_js_1.default.escape = string_js_1.default.escape;
	wrapperLodash_js_1.default.escapeRegExp = string_js_1.default.escapeRegExp;
	wrapperLodash_js_1.default.every = collection_js_1.default.every;
	wrapperLodash_js_1.default.find = collection_js_1.default.find;
	wrapperLodash_js_1.default.findIndex = array_js_1.default.findIndex;
	wrapperLodash_js_1.default.findKey = object_js_1.default.findKey;
	wrapperLodash_js_1.default.findLast = collection_js_1.default.findLast;
	wrapperLodash_js_1.default.findLastIndex = array_js_1.default.findLastIndex;
	wrapperLodash_js_1.default.findLastKey = object_js_1.default.findLastKey;
	wrapperLodash_js_1.default.floor = math_js_1.default.floor;
	wrapperLodash_js_1.default.forEach = collection_js_1.default.forEach;
	wrapperLodash_js_1.default.forEachRight = collection_js_1.default.forEachRight;
	wrapperLodash_js_1.default.forIn = object_js_1.default.forIn;
	wrapperLodash_js_1.default.forInRight = object_js_1.default.forInRight;
	wrapperLodash_js_1.default.forOwn = object_js_1.default.forOwn;
	wrapperLodash_js_1.default.forOwnRight = object_js_1.default.forOwnRight;
	wrapperLodash_js_1.default.get = object_js_1.default.get;
	wrapperLodash_js_1.default.gt = lang_js_1.default.gt;
	wrapperLodash_js_1.default.gte = lang_js_1.default.gte;
	wrapperLodash_js_1.default.has = object_js_1.default.has;
	wrapperLodash_js_1.default.hasIn = object_js_1.default.hasIn;
	wrapperLodash_js_1.default.head = array_js_1.default.head;
	wrapperLodash_js_1.default.identity = identity_js_1.default;
	wrapperLodash_js_1.default.includes = collection_js_1.default.includes;
	wrapperLodash_js_1.default.indexOf = array_js_1.default.indexOf;
	wrapperLodash_js_1.default.inRange = number_js_1.default.inRange;
	wrapperLodash_js_1.default.invoke = object_js_1.default.invoke;
	wrapperLodash_js_1.default.isArguments = lang_js_1.default.isArguments;
	wrapperLodash_js_1.default.isArray = isArray_js_1.default;
	wrapperLodash_js_1.default.isArrayBuffer = lang_js_1.default.isArrayBuffer;
	wrapperLodash_js_1.default.isArrayLike = lang_js_1.default.isArrayLike;
	wrapperLodash_js_1.default.isArrayLikeObject = lang_js_1.default.isArrayLikeObject;
	wrapperLodash_js_1.default.isBoolean = lang_js_1.default.isBoolean;
	wrapperLodash_js_1.default.isBuffer = lang_js_1.default.isBuffer;
	wrapperLodash_js_1.default.isDate = lang_js_1.default.isDate;
	wrapperLodash_js_1.default.isElement = lang_js_1.default.isElement;
	wrapperLodash_js_1.default.isEmpty = lang_js_1.default.isEmpty;
	wrapperLodash_js_1.default.isEqual = lang_js_1.default.isEqual;
	wrapperLodash_js_1.default.isEqualWith = lang_js_1.default.isEqualWith;
	wrapperLodash_js_1.default.isError = lang_js_1.default.isError;
	wrapperLodash_js_1.default.isFinite = lang_js_1.default.isFinite;
	wrapperLodash_js_1.default.isFunction = lang_js_1.default.isFunction;
	wrapperLodash_js_1.default.isInteger = lang_js_1.default.isInteger;
	wrapperLodash_js_1.default.isLength = lang_js_1.default.isLength;
	wrapperLodash_js_1.default.isMap = lang_js_1.default.isMap;
	wrapperLodash_js_1.default.isMatch = lang_js_1.default.isMatch;
	wrapperLodash_js_1.default.isMatchWith = lang_js_1.default.isMatchWith;
	wrapperLodash_js_1.default.isNaN = lang_js_1.default.isNaN;
	wrapperLodash_js_1.default.isNative = lang_js_1.default.isNative;
	wrapperLodash_js_1.default.isNil = lang_js_1.default.isNil;
	wrapperLodash_js_1.default.isNull = lang_js_1.default.isNull;
	wrapperLodash_js_1.default.isNumber = lang_js_1.default.isNumber;
	wrapperLodash_js_1.default.isObject = isObject_js_1.default;
	wrapperLodash_js_1.default.isObjectLike = lang_js_1.default.isObjectLike;
	wrapperLodash_js_1.default.isPlainObject = lang_js_1.default.isPlainObject;
	wrapperLodash_js_1.default.isRegExp = lang_js_1.default.isRegExp;
	wrapperLodash_js_1.default.isSafeInteger = lang_js_1.default.isSafeInteger;
	wrapperLodash_js_1.default.isSet = lang_js_1.default.isSet;
	wrapperLodash_js_1.default.isString = lang_js_1.default.isString;
	wrapperLodash_js_1.default.isSymbol = lang_js_1.default.isSymbol;
	wrapperLodash_js_1.default.isTypedArray = lang_js_1.default.isTypedArray;
	wrapperLodash_js_1.default.isUndefined = lang_js_1.default.isUndefined;
	wrapperLodash_js_1.default.isWeakMap = lang_js_1.default.isWeakMap;
	wrapperLodash_js_1.default.isWeakSet = lang_js_1.default.isWeakSet;
	wrapperLodash_js_1.default.join = array_js_1.default.join;
	wrapperLodash_js_1.default.kebabCase = string_js_1.default.kebabCase;
	wrapperLodash_js_1.default.last = last_js_1.default;
	wrapperLodash_js_1.default.lastIndexOf = array_js_1.default.lastIndexOf;
	wrapperLodash_js_1.default.lowerCase = string_js_1.default.lowerCase;
	wrapperLodash_js_1.default.lowerFirst = string_js_1.default.lowerFirst;
	wrapperLodash_js_1.default.lt = lang_js_1.default.lt;
	wrapperLodash_js_1.default.lte = lang_js_1.default.lte;
	wrapperLodash_js_1.default.max = math_js_1.default.max;
	wrapperLodash_js_1.default.maxBy = math_js_1.default.maxBy;
	wrapperLodash_js_1.default.mean = math_js_1.default.mean;
	wrapperLodash_js_1.default.meanBy = math_js_1.default.meanBy;
	wrapperLodash_js_1.default.min = math_js_1.default.min;
	wrapperLodash_js_1.default.minBy = math_js_1.default.minBy;
	wrapperLodash_js_1.default.stubArray = util_js_1.default.stubArray;
	wrapperLodash_js_1.default.stubFalse = util_js_1.default.stubFalse;
	wrapperLodash_js_1.default.stubObject = util_js_1.default.stubObject;
	wrapperLodash_js_1.default.stubString = util_js_1.default.stubString;
	wrapperLodash_js_1.default.stubTrue = util_js_1.default.stubTrue;
	wrapperLodash_js_1.default.multiply = math_js_1.default.multiply;
	wrapperLodash_js_1.default.nth = array_js_1.default.nth;
	wrapperLodash_js_1.default.noop = util_js_1.default.noop;
	wrapperLodash_js_1.default.now = date_js_1.default.now;
	wrapperLodash_js_1.default.pad = string_js_1.default.pad;
	wrapperLodash_js_1.default.padEnd = string_js_1.default.padEnd;
	wrapperLodash_js_1.default.padStart = string_js_1.default.padStart;
	wrapperLodash_js_1.default.parseInt = string_js_1.default.parseInt;
	wrapperLodash_js_1.default.random = number_js_1.default.random;
	wrapperLodash_js_1.default.reduce = collection_js_1.default.reduce;
	wrapperLodash_js_1.default.reduceRight = collection_js_1.default.reduceRight;
	wrapperLodash_js_1.default.repeat = string_js_1.default.repeat;
	wrapperLodash_js_1.default.replace = string_js_1.default.replace;
	wrapperLodash_js_1.default.result = object_js_1.default.result;
	wrapperLodash_js_1.default.round = math_js_1.default.round;
	wrapperLodash_js_1.default.sample = collection_js_1.default.sample;
	wrapperLodash_js_1.default.size = collection_js_1.default.size;
	wrapperLodash_js_1.default.snakeCase = string_js_1.default.snakeCase;
	wrapperLodash_js_1.default.some = collection_js_1.default.some;
	wrapperLodash_js_1.default.sortedIndex = array_js_1.default.sortedIndex;
	wrapperLodash_js_1.default.sortedIndexBy = array_js_1.default.sortedIndexBy;
	wrapperLodash_js_1.default.sortedIndexOf = array_js_1.default.sortedIndexOf;
	wrapperLodash_js_1.default.sortedLastIndex = array_js_1.default.sortedLastIndex;
	wrapperLodash_js_1.default.sortedLastIndexBy = array_js_1.default.sortedLastIndexBy;
	wrapperLodash_js_1.default.sortedLastIndexOf = array_js_1.default.sortedLastIndexOf;
	wrapperLodash_js_1.default.startCase = string_js_1.default.startCase;
	wrapperLodash_js_1.default.startsWith = string_js_1.default.startsWith;
	wrapperLodash_js_1.default.subtract = math_js_1.default.subtract;
	wrapperLodash_js_1.default.sum = math_js_1.default.sum;
	wrapperLodash_js_1.default.sumBy = math_js_1.default.sumBy;
	wrapperLodash_js_1.default.template = string_js_1.default.template;
	wrapperLodash_js_1.default.times = util_js_1.default.times;
	wrapperLodash_js_1.default.toFinite = lang_js_1.default.toFinite;
	wrapperLodash_js_1.default.toInteger = toInteger_js_1.default;
	wrapperLodash_js_1.default.toLength = lang_js_1.default.toLength;
	wrapperLodash_js_1.default.toLower = string_js_1.default.toLower;
	wrapperLodash_js_1.default.toNumber = lang_js_1.default.toNumber;
	wrapperLodash_js_1.default.toSafeInteger = lang_js_1.default.toSafeInteger;
	wrapperLodash_js_1.default.toString = lang_js_1.default.toString;
	wrapperLodash_js_1.default.toUpper = string_js_1.default.toUpper;
	wrapperLodash_js_1.default.trim = string_js_1.default.trim;
	wrapperLodash_js_1.default.trimEnd = string_js_1.default.trimEnd;
	wrapperLodash_js_1.default.trimStart = string_js_1.default.trimStart;
	wrapperLodash_js_1.default.truncate = string_js_1.default.truncate;
	wrapperLodash_js_1.default.unescape = string_js_1.default.unescape;
	wrapperLodash_js_1.default.uniqueId = util_js_1.default.uniqueId;
	wrapperLodash_js_1.default.upperCase = string_js_1.default.upperCase;
	wrapperLodash_js_1.default.upperFirst = string_js_1.default.upperFirst;
	wrapperLodash_js_1.default.each = collection_js_1.default.forEach;
	wrapperLodash_js_1.default.eachRight = collection_js_1.default.forEachRight;
	wrapperLodash_js_1.default.first = array_js_1.default.head;
	mixin(wrapperLodash_js_1.default, (function () {
	    var source = {};
	    _baseForOwn_js_1.default(wrapperLodash_js_1.default, function (func, methodName) {
	        if (!hasOwnProperty.call(wrapperLodash_js_1.default.prototype, methodName)) {
	            source[methodName] = func;
	        }
	    });
	    return source;
	}()), { 'chain': false });
	wrapperLodash_js_1.default.VERSION = VERSION;
	(wrapperLodash_js_1.default.templateSettings = string_js_1.default.templateSettings).imports._ = wrapperLodash_js_1.default;
	_arrayEach_js_1.default(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function (methodName) {
	    wrapperLodash_js_1.default[methodName].placeholder = wrapperLodash_js_1.default;
	});
	_arrayEach_js_1.default(['drop', 'take'], function (methodName, index) {
	    _LazyWrapper_js_1.default.prototype[methodName] = function (n) {
	        n = n === undefined ? 1 : nativeMax(toInteger_js_1.default(n), 0);
	        var result = (this.__filtered__ && !index)
	            ? new _LazyWrapper_js_1.default(this)
	            : this.clone();
	        if (result.__filtered__) {
	            result.__takeCount__ = nativeMin(n, result.__takeCount__);
	        }
	        else {
	            result.__views__.push({
	                'size': nativeMin(n, MAX_ARRAY_LENGTH),
	                'type': methodName + (result.__dir__ < 0 ? 'Right' : '')
	            });
	        }
	        return result;
	    };
	    _LazyWrapper_js_1.default.prototype[methodName + 'Right'] = function (n) {
	        return this.reverse()[methodName](n).reverse();
	    };
	});
	_arrayEach_js_1.default(['filter', 'map', 'takeWhile'], function (methodName, index) {
	    var type = index + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
	    _LazyWrapper_js_1.default.prototype[methodName] = function (iteratee) {
	        var result = this.clone();
	        result.__iteratees__.push({
	            'iteratee': _baseIteratee_js_1.default(iteratee, 3),
	            'type': type
	        });
	        result.__filtered__ = result.__filtered__ || isFilter;
	        return result;
	    };
	});
	_arrayEach_js_1.default(['head', 'last'], function (methodName, index) {
	    var takeName = 'take' + (index ? 'Right' : '');
	    _LazyWrapper_js_1.default.prototype[methodName] = function () {
	        return this[takeName](1).value()[0];
	    };
	});
	_arrayEach_js_1.default(['initial', 'tail'], function (methodName, index) {
	    var dropName = 'drop' + (index ? '' : 'Right');
	    _LazyWrapper_js_1.default.prototype[methodName] = function () {
	        return this.__filtered__ ? new _LazyWrapper_js_1.default(this) : this[dropName](1);
	    };
	});
	_LazyWrapper_js_1.default.prototype.compact = function () {
	    return this.filter(identity_js_1.default);
	};
	_LazyWrapper_js_1.default.prototype.find = function (predicate) {
	    return this.filter(predicate).head();
	};
	_LazyWrapper_js_1.default.prototype.findLast = function (predicate) {
	    return this.reverse().find(predicate);
	};
	_LazyWrapper_js_1.default.prototype.invokeMap = _baseRest_js_1.default(function (path, args) {
	    if (typeof path == 'function') {
	        return new _LazyWrapper_js_1.default(this);
	    }
	    return this.map(function (value) {
	        return _baseInvoke_js_1.default(value, path, args);
	    });
	});
	_LazyWrapper_js_1.default.prototype.reject = function (predicate) {
	    return this.filter(negate_js_1.default(_baseIteratee_js_1.default(predicate)));
	};
	_LazyWrapper_js_1.default.prototype.slice = function (start, end) {
	    start = toInteger_js_1.default(start);
	    var result = this;
	    if (result.__filtered__ && (start > 0 || end < 0)) {
	        return new _LazyWrapper_js_1.default(result);
	    }
	    if (start < 0) {
	        result = result.takeRight(-start);
	    }
	    else if (start) {
	        result = result.drop(start);
	    }
	    if (end !== undefined) {
	        end = toInteger_js_1.default(end);
	        result = end < 0 ? result.dropRight(-end) : result.take(end - start);
	    }
	    return result;
	};
	_LazyWrapper_js_1.default.prototype.takeRightWhile = function (predicate) {
	    return this.reverse().takeWhile(predicate).reverse();
	};
	_LazyWrapper_js_1.default.prototype.toArray = function () {
	    return this.take(MAX_ARRAY_LENGTH);
	};
	_baseForOwn_js_1.default(_LazyWrapper_js_1.default.prototype, function (func, methodName) {
	    var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = wrapperLodash_js_1.default[isTaker ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
	    if (!lodashFunc) {
	        return;
	    }
	    wrapperLodash_js_1.default.prototype[methodName] = function () {
	        var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof _LazyWrapper_js_1.default, iteratee = args[0], useLazy = isLazy || isArray_js_1.default(value);
	        var interceptor = function (value) {
	            var result = lodashFunc.apply(wrapperLodash_js_1.default, _arrayPush_js_1.default([value], args));
	            return (isTaker && chainAll) ? result[0] : result;
	        };
	        if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
	            isLazy = useLazy = false;
	        }
	        var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
	        if (!retUnwrapped && useLazy) {
	            value = onlyLazy ? value : new _LazyWrapper_js_1.default(this);
	            var result = func.apply(value, args);
	            result.__actions__.push({ 'func': thru_js_1.default, 'args': [interceptor], 'thisArg': undefined });
	            return new _LodashWrapper_js_1.default(result, chainAll);
	        }
	        if (isUnwrapped && onlyLazy) {
	            return func.apply(this, args);
	        }
	        result = this.thru(interceptor);
	        return isUnwrapped ? (isTaker ? result.value()[0] : result.value()) : result;
	    };
	});
	_arrayEach_js_1.default(['pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function (methodName) {
	    var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru', retUnwrapped = /^(?:pop|shift)$/.test(methodName);
	    wrapperLodash_js_1.default.prototype[methodName] = function () {
	        var args = arguments;
	        if (retUnwrapped && !this.__chain__) {
	            var value = this.value();
	            return func.apply(isArray_js_1.default(value) ? value : [], args);
	        }
	        return this[chainName](function (value) {
	            return func.apply(isArray_js_1.default(value) ? value : [], args);
	        });
	    };
	});
	_baseForOwn_js_1.default(_LazyWrapper_js_1.default.prototype, function (func, methodName) {
	    var lodashFunc = wrapperLodash_js_1.default[methodName];
	    if (lodashFunc) {
	        var key = (lodashFunc.name + ''), names = _realNames_js_1.default[key] || (_realNames_js_1.default[key] = []);
	        names.push({ 'name': methodName, 'func': lodashFunc });
	    }
	});
	_realNames_js_1.default[_createHybrid_js_1.default(undefined, WRAP_BIND_KEY_FLAG).name] = [{
	        'name': 'wrapper',
	        'func': undefined
	    }];
	_LazyWrapper_js_1.default.prototype.clone = _lazyClone_js_1.default;
	_LazyWrapper_js_1.default.prototype.reverse = _lazyReverse_js_1.default;
	_LazyWrapper_js_1.default.prototype.value = _lazyValue_js_1.default;
	wrapperLodash_js_1.default.prototype.at = seq_js_1.default.at;
	wrapperLodash_js_1.default.prototype.chain = seq_js_1.default.wrapperChain;
	wrapperLodash_js_1.default.prototype.commit = seq_js_1.default.commit;
	wrapperLodash_js_1.default.prototype.next = seq_js_1.default.next;
	wrapperLodash_js_1.default.prototype.plant = seq_js_1.default.plant;
	wrapperLodash_js_1.default.prototype.reverse = seq_js_1.default.reverse;
	wrapperLodash_js_1.default.prototype.toJSON = wrapperLodash_js_1.default.prototype.valueOf = wrapperLodash_js_1.default.prototype.value = seq_js_1.default.value;
	wrapperLodash_js_1.default.prototype.first = wrapperLodash_js_1.default.prototype.head;
	if (symIterator) {
	    wrapperLodash_js_1.default.prototype[symIterator] = seq_js_1.default.toIterator;
	}
	exports.default = wrapperLodash_js_1.default;
	});

	var lodash$1 = createCommonjsModule(function (module, exports) {
	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var add_js_1 = add_1;
	exports.add = add_js_1.default;
	var after_js_1 = after_1;
	exports.after = after_js_1.default;
	var ary_js_1 = ary_1;
	exports.ary = ary_js_1.default;
	var assign_js_1 = assign_1;
	exports.assign = assign_js_1.default;
	var assignIn_js_1 = assignIn_1;
	exports.assignIn = assignIn_js_1.default;
	var assignInWith_js_1 = assignInWith_1;
	exports.assignInWith = assignInWith_js_1.default;
	var assignWith_js_1 = assignWith_1;
	exports.assignWith = assignWith_js_1.default;
	var at_js_1 = at_1;
	exports.at = at_js_1.default;
	var attempt_js_1 = attempt_1;
	exports.attempt = attempt_js_1.default;
	var before_js_1 = before_1;
	exports.before = before_js_1.default;
	var bind_js_1 = bind_1;
	exports.bind = bind_js_1.default;
	var bindAll_js_1 = bindAll_1;
	exports.bindAll = bindAll_js_1.default;
	var bindKey_js_1 = bindKey_1;
	exports.bindKey = bindKey_js_1.default;
	var camelCase_js_1 = camelCase_1;
	exports.camelCase = camelCase_js_1.default;
	var capitalize_js_1 = capitalize_1;
	exports.capitalize = capitalize_js_1.default;
	var castArray_js_1 = castArray_1;
	exports.castArray = castArray_js_1.default;
	var ceil_js_1 = ceil_1;
	exports.ceil = ceil_js_1.default;
	var chain_js_1 = chain_1;
	exports.chain = chain_js_1.default;
	var chunk_js_1 = chunk_1;
	exports.chunk = chunk_js_1.default;
	var clamp_js_1 = clamp_1;
	exports.clamp = clamp_js_1.default;
	var clone_js_1 = clone_1;
	exports.clone = clone_js_1.default;
	var cloneDeep_js_1 = cloneDeep_1;
	exports.cloneDeep = cloneDeep_js_1.default;
	var cloneDeepWith_js_1 = cloneDeepWith_1;
	exports.cloneDeepWith = cloneDeepWith_js_1.default;
	var cloneWith_js_1 = cloneWith_1;
	exports.cloneWith = cloneWith_js_1.default;
	var commit_js_1 = commit;
	exports.commit = commit_js_1.default;
	var compact_js_1 = compact_1;
	exports.compact = compact_js_1.default;
	var concat_js_1 = concat_1;
	exports.concat = concat_js_1.default;
	var cond_js_1 = cond_1;
	exports.cond = cond_js_1.default;
	var conforms_js_1 = conforms_1;
	exports.conforms = conforms_js_1.default;
	var conformsTo_js_1 = conformsTo_1;
	exports.conformsTo = conformsTo_js_1.default;
	var constant_js_1 = constant_1;
	exports.constant = constant_js_1.default;
	var countBy_js_1 = countBy_1;
	exports.countBy = countBy_js_1.default;
	var create_js_1 = create_1;
	exports.create = create_js_1.default;
	var curry_js_1 = curry_1;
	exports.curry = curry_js_1.default;
	var curryRight_js_1 = curryRight_1;
	exports.curryRight = curryRight_js_1.default;
	var debounce_js_1 = debounce_1;
	exports.debounce = debounce_js_1.default;
	var deburr_js_1 = deburr_1;
	exports.deburr = deburr_js_1.default;
	var defaultTo_js_1 = defaultTo_1;
	exports.defaultTo = defaultTo_js_1.default;
	var defaults_js_1 = defaults_1;
	exports.defaults = defaults_js_1.default;
	var defaultsDeep_js_1 = defaultsDeep_1;
	exports.defaultsDeep = defaultsDeep_js_1.default;
	var defer_js_1 = defer_1;
	exports.defer = defer_js_1.default;
	var delay_js_1 = delay_1;
	exports.delay = delay_js_1.default;
	var difference_js_1 = difference_1;
	exports.difference = difference_js_1.default;
	var differenceBy_js_1 = differenceBy_1;
	exports.differenceBy = differenceBy_js_1.default;
	var differenceWith_js_1 = differenceWith_1;
	exports.differenceWith = differenceWith_js_1.default;
	var divide_js_1 = divide_1;
	exports.divide = divide_js_1.default;
	var drop_js_1 = drop_1;
	exports.drop = drop_js_1.default;
	var dropRight_js_1 = dropRight_1;
	exports.dropRight = dropRight_js_1.default;
	var dropRightWhile_js_1 = dropRightWhile_1;
	exports.dropRightWhile = dropRightWhile_js_1.default;
	var dropWhile_js_1 = dropWhile_1;
	exports.dropWhile = dropWhile_js_1.default;
	var each_js_1 = each;
	exports.each = each_js_1.default;
	var eachRight_js_1 = eachRight;
	exports.eachRight = eachRight_js_1.default;
	var endsWith_js_1 = endsWith_1;
	exports.endsWith = endsWith_js_1.default;
	var entries_js_1 = entries;
	exports.entries = entries_js_1.default;
	var entriesIn_js_1 = entriesIn;
	exports.entriesIn = entriesIn_js_1.default;
	var eq_js_1 = eq_1;
	exports.eq = eq_js_1.default;
	var escape_js_1 = _escape;
	exports.escape = escape_js_1.default;
	var escapeRegExp_js_1 = escapeRegExp_1;
	exports.escapeRegExp = escapeRegExp_js_1.default;
	var every_js_1 = every_1;
	exports.every = every_js_1.default;
	var extend_js_1 = extend;
	exports.extend = extend_js_1.default;
	var extendWith_js_1 = extendWith;
	exports.extendWith = extendWith_js_1.default;
	var fill_js_1 = fill_1;
	exports.fill = fill_js_1.default;
	var filter_js_1 = filter_1;
	exports.filter = filter_js_1.default;
	var find_js_1 = find_1;
	exports.find = find_js_1.default;
	var findIndex_js_1 = findIndex_1;
	exports.findIndex = findIndex_js_1.default;
	var findKey_js_1 = findKey_1;
	exports.findKey = findKey_js_1.default;
	var findLast_js_1 = findLast_1;
	exports.findLast = findLast_js_1.default;
	var findLastIndex_js_1 = findLastIndex_1;
	exports.findLastIndex = findLastIndex_js_1.default;
	var findLastKey_js_1 = findLastKey_1;
	exports.findLastKey = findLastKey_js_1.default;
	var first_js_1 = first;
	exports.first = first_js_1.default;
	var flatMap_js_1 = flatMap_1;
	exports.flatMap = flatMap_js_1.default;
	var flatMapDeep_js_1 = flatMapDeep_1;
	exports.flatMapDeep = flatMapDeep_js_1.default;
	var flatMapDepth_js_1 = flatMapDepth_1;
	exports.flatMapDepth = flatMapDepth_js_1.default;
	var flatten_js_1 = flatten_1;
	exports.flatten = flatten_js_1.default;
	var flattenDeep_js_1 = flattenDeep_1;
	exports.flattenDeep = flattenDeep_js_1.default;
	var flattenDepth_js_1 = flattenDepth_1;
	exports.flattenDepth = flattenDepth_js_1.default;
	var flip_js_1 = flip_1;
	exports.flip = flip_js_1.default;
	var floor_js_1 = floor_1;
	exports.floor = floor_js_1.default;
	var flow_js_1 = flow_1;
	exports.flow = flow_js_1.default;
	var flowRight_js_1 = flowRight_1;
	exports.flowRight = flowRight_js_1.default;
	var forEach_js_1 = forEach_1;
	exports.forEach = forEach_js_1.default;
	var forEachRight_js_1 = forEachRight_1;
	exports.forEachRight = forEachRight_js_1.default;
	var forIn_js_1 = forIn_1;
	exports.forIn = forIn_js_1.default;
	var forInRight_js_1 = forInRight_1;
	exports.forInRight = forInRight_js_1.default;
	var forOwn_js_1 = forOwn_1;
	exports.forOwn = forOwn_js_1.default;
	var forOwnRight_js_1 = forOwnRight_1;
	exports.forOwnRight = forOwnRight_js_1.default;
	var fromPairs_js_1 = fromPairs_1;
	exports.fromPairs = fromPairs_js_1.default;
	var functions_js_1 = functions_1;
	exports.functions = functions_js_1.default;
	var functionsIn_js_1 = functionsIn_1;
	exports.functionsIn = functionsIn_js_1.default;
	var get_js_1 = get_1;
	exports.get = get_js_1.default;
	var groupBy_js_1 = groupBy_1;
	exports.groupBy = groupBy_js_1.default;
	var gt_js_1 = gt_1;
	exports.gt = gt_js_1.default;
	var gte_js_1 = gte_1;
	exports.gte = gte_js_1.default;
	var has_js_1 = has_1;
	exports.has = has_js_1.default;
	var hasIn_js_1 = hasIn_1;
	exports.hasIn = hasIn_js_1.default;
	var head_js_1 = head_1;
	exports.head = head_js_1.default;
	var identity_js_1 = identity_1;
	exports.identity = identity_js_1.default;
	var inRange_js_1 = inRange_1;
	exports.inRange = inRange_js_1.default;
	var includes_js_1 = includes_1;
	exports.includes = includes_js_1.default;
	var indexOf_js_1 = indexOf_1;
	exports.indexOf = indexOf_js_1.default;
	var initial_js_1 = initial_1;
	exports.initial = initial_js_1.default;
	var intersection_js_1 = intersection_1;
	exports.intersection = intersection_js_1.default;
	var intersectionBy_js_1 = intersectionBy_1;
	exports.intersectionBy = intersectionBy_js_1.default;
	var intersectionWith_js_1 = intersectionWith_1;
	exports.intersectionWith = intersectionWith_js_1.default;
	var invert_js_1 = invert_1;
	exports.invert = invert_js_1.default;
	var invertBy_js_1 = invertBy_1;
	exports.invertBy = invertBy_js_1.default;
	var invoke_js_1 = invoke_1;
	exports.invoke = invoke_js_1.default;
	var invokeMap_js_1 = invokeMap_1;
	exports.invokeMap = invokeMap_js_1.default;
	var isArguments_js_1 = isArguments_1;
	exports.isArguments = isArguments_js_1.default;
	var isArray_js_1 = isArray_1;
	exports.isArray = isArray_js_1.default;
	var isArrayBuffer_js_1 = isArrayBuffer_1;
	exports.isArrayBuffer = isArrayBuffer_js_1.default;
	var isArrayLike_js_1 = isArrayLike_1;
	exports.isArrayLike = isArrayLike_js_1.default;
	var isArrayLikeObject_js_1 = isArrayLikeObject_1;
	exports.isArrayLikeObject = isArrayLikeObject_js_1.default;
	var isBoolean_js_1 = isBoolean_1;
	exports.isBoolean = isBoolean_js_1.default;
	var isBuffer_js_1 = isBuffer_1;
	exports.isBuffer = isBuffer_js_1.default;
	var isDate_js_1 = isDate_1;
	exports.isDate = isDate_js_1.default;
	var isElement_js_1 = isElement_1;
	exports.isElement = isElement_js_1.default;
	var isEmpty_js_1 = isEmpty_1;
	exports.isEmpty = isEmpty_js_1.default;
	var isEqual_js_1 = isEqual_1;
	exports.isEqual = isEqual_js_1.default;
	var isEqualWith_js_1 = isEqualWith_1;
	exports.isEqualWith = isEqualWith_js_1.default;
	var isError_js_1 = isError_1;
	exports.isError = isError_js_1.default;
	var isFinite_js_1 = _isFinite;
	exports.isFinite = isFinite_js_1.default;
	var isFunction_js_1 = isFunction_1;
	exports.isFunction = isFunction_js_1.default;
	var isInteger_js_1 = isInteger_1;
	exports.isInteger = isInteger_js_1.default;
	var isLength_js_1 = isLength_1;
	exports.isLength = isLength_js_1.default;
	var isMap_js_1 = isMap_1;
	exports.isMap = isMap_js_1.default;
	var isMatch_js_1 = isMatch_1;
	exports.isMatch = isMatch_js_1.default;
	var isMatchWith_js_1 = isMatchWith_1;
	exports.isMatchWith = isMatchWith_js_1.default;
	var isNaN_js_1 = _isNaN;
	exports.isNaN = isNaN_js_1.default;
	var isNative_js_1 = isNative_1;
	exports.isNative = isNative_js_1.default;
	var isNil_js_1 = isNil_1;
	exports.isNil = isNil_js_1.default;
	var isNull_js_1 = isNull_1;
	exports.isNull = isNull_js_1.default;
	var isNumber_js_1 = isNumber_1;
	exports.isNumber = isNumber_js_1.default;
	var isObject_js_1 = isObject_1;
	exports.isObject = isObject_js_1.default;
	var isObjectLike_js_1 = isObjectLike_1;
	exports.isObjectLike = isObjectLike_js_1.default;
	var isPlainObject_js_1 = isPlainObject_1;
	exports.isPlainObject = isPlainObject_js_1.default;
	var isRegExp_js_1 = isRegExp_1;
	exports.isRegExp = isRegExp_js_1.default;
	var isSafeInteger_js_1 = isSafeInteger_1;
	exports.isSafeInteger = isSafeInteger_js_1.default;
	var isSet_js_1 = isSet_1;
	exports.isSet = isSet_js_1.default;
	var isString_js_1 = isString_1;
	exports.isString = isString_js_1.default;
	var isSymbol_js_1 = isSymbol_1;
	exports.isSymbol = isSymbol_js_1.default;
	var isTypedArray_js_1 = isTypedArray_1;
	exports.isTypedArray = isTypedArray_js_1.default;
	var isUndefined_js_1 = isUndefined_1;
	exports.isUndefined = isUndefined_js_1.default;
	var isWeakMap_js_1 = isWeakMap_1;
	exports.isWeakMap = isWeakMap_js_1.default;
	var isWeakSet_js_1 = isWeakSet_1;
	exports.isWeakSet = isWeakSet_js_1.default;
	var iteratee_js_1 = iteratee_1;
	exports.iteratee = iteratee_js_1.default;
	var join_js_1 = join_1;
	exports.join = join_js_1.default;
	var kebabCase_js_1 = kebabCase_1;
	exports.kebabCase = kebabCase_js_1.default;
	var keyBy_js_1 = keyBy_1;
	exports.keyBy = keyBy_js_1.default;
	var keys_js_1 = keys_1;
	exports.keys = keys_js_1.default;
	var keysIn_js_1 = keysIn_1;
	exports.keysIn = keysIn_js_1.default;
	var last_js_1 = last_1;
	exports.last = last_js_1.default;
	var lastIndexOf_js_1 = lastIndexOf_1;
	exports.lastIndexOf = lastIndexOf_js_1.default;
	var wrapperLodash_js_1 = wrapperLodash;
	exports.lodash = wrapperLodash_js_1.default;
	var lowerCase_js_1 = lowerCase_1;
	exports.lowerCase = lowerCase_js_1.default;
	var lowerFirst_js_1 = lowerFirst_1;
	exports.lowerFirst = lowerFirst_js_1.default;
	var lt_js_1 = lt_1;
	exports.lt = lt_js_1.default;
	var lte_js_1 = lte_1;
	exports.lte = lte_js_1.default;
	var map_js_1 = map_1;
	exports.map = map_js_1.default;
	var mapKeys_js_1 = mapKeys_1;
	exports.mapKeys = mapKeys_js_1.default;
	var mapValues_js_1 = mapValues_1;
	exports.mapValues = mapValues_js_1.default;
	var matches_js_1 = matches_1;
	exports.matches = matches_js_1.default;
	var matchesProperty_js_1 = matchesProperty_1;
	exports.matchesProperty = matchesProperty_js_1.default;
	var max_js_1 = max_1;
	exports.max = max_js_1.default;
	var maxBy_js_1 = maxBy_1;
	exports.maxBy = maxBy_js_1.default;
	var mean_js_1 = mean_1;
	exports.mean = mean_js_1.default;
	var meanBy_js_1 = meanBy_1;
	exports.meanBy = meanBy_js_1.default;
	var memoize_js_1 = memoize_1;
	exports.memoize = memoize_js_1.default;
	var merge_js_1 = merge_1;
	exports.merge = merge_js_1.default;
	var mergeWith_js_1 = mergeWith_1;
	exports.mergeWith = mergeWith_js_1.default;
	var method_js_1 = method_1;
	exports.method = method_js_1.default;
	var methodOf_js_1 = methodOf_1;
	exports.methodOf = methodOf_js_1.default;
	var min_js_1 = min_1;
	exports.min = min_js_1.default;
	var minBy_js_1 = minBy_1;
	exports.minBy = minBy_js_1.default;
	var mixin_js_1 = mixin_1;
	exports.mixin = mixin_js_1.default;
	var multiply_js_1 = multiply_1;
	exports.multiply = multiply_js_1.default;
	var negate_js_1 = negate_1;
	exports.negate = negate_js_1.default;
	var next_js_1 = next;
	exports.next = next_js_1.default;
	var noop_js_1 = noop_1;
	exports.noop = noop_js_1.default;
	var now_js_1 = now_1;
	exports.now = now_js_1.default;
	var nth_js_1 = nth_1;
	exports.nth = nth_js_1.default;
	var nthArg_js_1 = nthArg_1;
	exports.nthArg = nthArg_js_1.default;
	var omit_js_1 = omit_1;
	exports.omit = omit_js_1.default;
	var omitBy_js_1 = omitBy_1;
	exports.omitBy = omitBy_js_1.default;
	var once_js_1 = once_1;
	exports.once = once_js_1.default;
	var orderBy_js_1 = orderBy_1;
	exports.orderBy = orderBy_js_1.default;
	var over_js_1 = over_1;
	exports.over = over_js_1.default;
	var overArgs_js_1 = overArgs_1;
	exports.overArgs = overArgs_js_1.default;
	var overEvery_js_1 = overEvery_1;
	exports.overEvery = overEvery_js_1.default;
	var overSome_js_1 = overSome_1;
	exports.overSome = overSome_js_1.default;
	var pad_js_1 = pad_1;
	exports.pad = pad_js_1.default;
	var padEnd_js_1 = padEnd_1;
	exports.padEnd = padEnd_js_1.default;
	var padStart_js_1 = padStart_1;
	exports.padStart = padStart_js_1.default;
	var parseInt_js_1 = _parseInt;
	exports.parseInt = parseInt_js_1.default;
	var partial_js_1 = partial_1;
	exports.partial = partial_js_1.default;
	var partialRight_js_1 = partialRight_1;
	exports.partialRight = partialRight_js_1.default;
	var partition_js_1 = partition_1;
	exports.partition = partition_js_1.default;
	var pick_js_1 = pick_1;
	exports.pick = pick_js_1.default;
	var pickBy_js_1 = pickBy_1;
	exports.pickBy = pickBy_js_1.default;
	var plant_js_1 = plant;
	exports.plant = plant_js_1.default;
	var property_js_1 = property_1;
	exports.property = property_js_1.default;
	var propertyOf_js_1 = propertyOf_1;
	exports.propertyOf = propertyOf_js_1.default;
	var pull_js_1 = pull_1;
	exports.pull = pull_js_1.default;
	var pullAll_js_1 = pullAll_1;
	exports.pullAll = pullAll_js_1.default;
	var pullAllBy_js_1 = pullAllBy_1;
	exports.pullAllBy = pullAllBy_js_1.default;
	var pullAllWith_js_1 = pullAllWith_1;
	exports.pullAllWith = pullAllWith_js_1.default;
	var pullAt_js_1 = pullAt_1;
	exports.pullAt = pullAt_js_1.default;
	var random_js_1 = random_1;
	exports.random = random_js_1.default;
	var range_js_1 = range_1;
	exports.range = range_js_1.default;
	var rangeRight_js_1 = rangeRight_1;
	exports.rangeRight = rangeRight_js_1.default;
	var rearg_js_1 = rearg_1;
	exports.rearg = rearg_js_1.default;
	var reduce_js_1 = reduce_1;
	exports.reduce = reduce_js_1.default;
	var reduceRight_js_1 = reduceRight_1;
	exports.reduceRight = reduceRight_js_1.default;
	var reject_js_1 = reject_1;
	exports.reject = reject_js_1.default;
	var remove_js_1 = remove_1;
	exports.remove = remove_js_1.default;
	var repeat_js_1 = repeat_1;
	exports.repeat = repeat_js_1.default;
	var replace_js_1 = replace_1;
	exports.replace = replace_js_1.default;
	var rest_js_1 = rest_1;
	exports.rest = rest_js_1.default;
	var result_js_1 = result_1;
	exports.result = result_js_1.default;
	var reverse_js_1 = reverse_1;
	exports.reverse = reverse_js_1.default;
	var round_js_1 = round_1;
	exports.round = round_js_1.default;
	var sample_js_1 = sample_1;
	exports.sample = sample_js_1.default;
	var sampleSize_js_1 = sampleSize_1;
	exports.sampleSize = sampleSize_js_1.default;
	var set_js_1 = set_1;
	exports.set = set_js_1.default;
	var setWith_js_1 = setWith_1;
	exports.setWith = setWith_js_1.default;
	var shuffle_js_1 = shuffle_1;
	exports.shuffle = shuffle_js_1.default;
	var size_js_1 = size_1;
	exports.size = size_js_1.default;
	var slice_js_1 = slice_1;
	exports.slice = slice_js_1.default;
	var snakeCase_js_1 = snakeCase_1;
	exports.snakeCase = snakeCase_js_1.default;
	var some_js_1 = some_1;
	exports.some = some_js_1.default;
	var sortBy_js_1 = sortBy_1;
	exports.sortBy = sortBy_js_1.default;
	var sortedIndex_js_1 = sortedIndex_1;
	exports.sortedIndex = sortedIndex_js_1.default;
	var sortedIndexBy_js_1 = sortedIndexBy_1;
	exports.sortedIndexBy = sortedIndexBy_js_1.default;
	var sortedIndexOf_js_1 = sortedIndexOf_1;
	exports.sortedIndexOf = sortedIndexOf_js_1.default;
	var sortedLastIndex_js_1 = sortedLastIndex_1;
	exports.sortedLastIndex = sortedLastIndex_js_1.default;
	var sortedLastIndexBy_js_1 = sortedLastIndexBy_1;
	exports.sortedLastIndexBy = sortedLastIndexBy_js_1.default;
	var sortedLastIndexOf_js_1 = sortedLastIndexOf_1;
	exports.sortedLastIndexOf = sortedLastIndexOf_js_1.default;
	var sortedUniq_js_1 = sortedUniq_1;
	exports.sortedUniq = sortedUniq_js_1.default;
	var sortedUniqBy_js_1 = sortedUniqBy_1;
	exports.sortedUniqBy = sortedUniqBy_js_1.default;
	var split_js_1 = split_1;
	exports.split = split_js_1.default;
	var spread_js_1 = spread_1;
	exports.spread = spread_js_1.default;
	var startCase_js_1 = startCase_1;
	exports.startCase = startCase_js_1.default;
	var startsWith_js_1 = startsWith_1;
	exports.startsWith = startsWith_js_1.default;
	var stubArray_js_1 = stubArray_1;
	exports.stubArray = stubArray_js_1.default;
	var stubFalse_js_1 = stubFalse_1;
	exports.stubFalse = stubFalse_js_1.default;
	var stubObject_js_1 = stubObject_1;
	exports.stubObject = stubObject_js_1.default;
	var stubString_js_1 = stubString_1;
	exports.stubString = stubString_js_1.default;
	var stubTrue_js_1 = stubTrue_1;
	exports.stubTrue = stubTrue_js_1.default;
	var subtract_js_1 = subtract_1;
	exports.subtract = subtract_js_1.default;
	var sum_js_1 = sum_1;
	exports.sum = sum_js_1.default;
	var sumBy_js_1 = sumBy_1;
	exports.sumBy = sumBy_js_1.default;
	var tail_js_1 = tail_1;
	exports.tail = tail_js_1.default;
	var take_js_1 = take_1;
	exports.take = take_js_1.default;
	var takeRight_js_1 = takeRight_1;
	exports.takeRight = takeRight_js_1.default;
	var takeRightWhile_js_1 = takeRightWhile_1;
	exports.takeRightWhile = takeRightWhile_js_1.default;
	var takeWhile_js_1 = takeWhile_1;
	exports.takeWhile = takeWhile_js_1.default;
	var tap_js_1 = tap_1;
	exports.tap = tap_js_1.default;
	var template_js_1 = template_1;
	exports.template = template_js_1.default;
	var templateSettings_js_1 = templateSettings_1;
	exports.templateSettings = templateSettings_js_1.default;
	var throttle_js_1 = throttle_1;
	exports.throttle = throttle_js_1.default;
	var thru_js_1 = thru_1;
	exports.thru = thru_js_1.default;
	var times_js_1 = times_1;
	exports.times = times_js_1.default;
	var toArray_js_1 = toArray_1;
	exports.toArray = toArray_js_1.default;
	var toFinite_js_1 = toFinite_1;
	exports.toFinite = toFinite_js_1.default;
	var toInteger_js_1 = toInteger_1;
	exports.toInteger = toInteger_js_1.default;
	var toIterator_js_1 = toIterator;
	exports.toIterator = toIterator_js_1.default;
	var toJSON_js_1 = toJSON;
	exports.toJSON = toJSON_js_1.default;
	var toLength_js_1 = toLength_1;
	exports.toLength = toLength_js_1.default;
	var toLower_js_1 = toLower_1;
	exports.toLower = toLower_js_1.default;
	var toNumber_js_1 = toNumber_1;
	exports.toNumber = toNumber_js_1.default;
	var toPairs_js_1 = toPairs_1;
	exports.toPairs = toPairs_js_1.default;
	var toPairsIn_js_1 = toPairsIn_1;
	exports.toPairsIn = toPairsIn_js_1.default;
	var toPath_js_1 = toPath_1;
	exports.toPath = toPath_js_1.default;
	var toPlainObject_js_1 = toPlainObject_1;
	exports.toPlainObject = toPlainObject_js_1.default;
	var toSafeInteger_js_1 = toSafeInteger_1;
	exports.toSafeInteger = toSafeInteger_js_1.default;
	var toString_js_1 = toString_1;
	exports.toString = toString_js_1.default;
	var toUpper_js_1 = toUpper_1;
	exports.toUpper = toUpper_js_1.default;
	var transform_js_1 = transform_1;
	exports.transform = transform_js_1.default;
	var trim_js_1 = trim_1;
	exports.trim = trim_js_1.default;
	var trimEnd_js_1 = trimEnd_1;
	exports.trimEnd = trimEnd_js_1.default;
	var trimStart_js_1 = trimStart_1;
	exports.trimStart = trimStart_js_1.default;
	var truncate_js_1 = truncate_1;
	exports.truncate = truncate_js_1.default;
	var unary_js_1 = unary_1;
	exports.unary = unary_js_1.default;
	var unescape_js_1 = _unescape;
	exports.unescape = unescape_js_1.default;
	var union_js_1 = union_1;
	exports.union = union_js_1.default;
	var unionBy_js_1 = unionBy_1;
	exports.unionBy = unionBy_js_1.default;
	var unionWith_js_1 = unionWith_1;
	exports.unionWith = unionWith_js_1.default;
	var uniq_js_1 = uniq_1;
	exports.uniq = uniq_js_1.default;
	var uniqBy_js_1 = uniqBy_1;
	exports.uniqBy = uniqBy_js_1.default;
	var uniqWith_js_1 = uniqWith_1;
	exports.uniqWith = uniqWith_js_1.default;
	var uniqueId_js_1 = uniqueId_1;
	exports.uniqueId = uniqueId_js_1.default;
	var unset_js_1 = unset_1;
	exports.unset = unset_js_1.default;
	var unzip_js_1 = unzip_1;
	exports.unzip = unzip_js_1.default;
	var unzipWith_js_1 = unzipWith_1;
	exports.unzipWith = unzipWith_js_1.default;
	var update_js_1 = update_1;
	exports.update = update_js_1.default;
	var updateWith_js_1 = updateWith_1;
	exports.updateWith = updateWith_js_1.default;
	var upperCase_js_1 = upperCase_1;
	exports.upperCase = upperCase_js_1.default;
	var upperFirst_js_1 = upperFirst_1;
	exports.upperFirst = upperFirst_js_1.default;
	var value_js_1 = value;
	exports.value = value_js_1.default;
	var valueOf_js_1 = valueOf_1;
	exports.valueOf = valueOf_js_1.default;
	var values_js_1 = values_1;
	exports.values = values_js_1.default;
	var valuesIn_js_1 = valuesIn_1;
	exports.valuesIn = valuesIn_js_1.default;
	var without_js_1 = without_1;
	exports.without = without_js_1.default;
	var words_js_1 = words_1;
	exports.words = words_js_1.default;
	var wrap_js_1 = wrap_1;
	exports.wrap = wrap_js_1.default;
	var wrapperAt_js_1 = wrapperAt_1;
	exports.wrapperAt = wrapperAt_js_1.default;
	var wrapperChain_js_1 = wrapperChain_1;
	exports.wrapperChain = wrapperChain_js_1.default;
	var commit_js_2 = commit;
	exports.wrapperCommit = commit_js_2.default;
	var wrapperLodash_js_2 = wrapperLodash;
	exports.wrapperLodash = wrapperLodash_js_2.default;
	var next_js_2 = next;
	exports.wrapperNext = next_js_2.default;
	var plant_js_2 = plant;
	exports.wrapperPlant = plant_js_2.default;
	var wrapperReverse_js_1 = wrapperReverse_1;
	exports.wrapperReverse = wrapperReverse_js_1.default;
	var toIterator_js_2 = toIterator;
	exports.wrapperToIterator = toIterator_js_2.default;
	var wrapperValue_js_1 = wrapperValue_1;
	exports.wrapperValue = wrapperValue_js_1.default;
	var xor_js_1 = xor_1;
	exports.xor = xor_js_1.default;
	var xorBy_js_1 = xorBy_1;
	exports.xorBy = xorBy_js_1.default;
	var xorWith_js_1 = xorWith_1;
	exports.xorWith = xorWith_js_1.default;
	var zip_js_1 = zip_1;
	exports.zip = zip_js_1.default;
	var zipObject_js_1 = zipObject_1;
	exports.zipObject = zipObject_js_1.default;
	var zipObjectDeep_js_1 = zipObjectDeep_1;
	exports.zipObjectDeep = zipObjectDeep_js_1.default;
	var zipWith_js_1 = zipWith_1;
	exports.zipWith = zipWith_js_1.default;
	var lodash_default_js_1 = lodash_default;
	exports.default = lodash_default_js_1.default;
	});

	var lodash_34 = lodash$1.curry;
	var lodash_80 = lodash$1.flowRight;
	var lodash_133 = lodash$1.isNumber;

	var demo = (function () {
	    function demo() {
	    }
	    demo.of = function () {
	        var obj = new this();
	        return obj;
	    };
	    demo.prototype.run = function () {
	        var showImg = function (img) {
	            console.log(img);
	            document.getElementById("ct").appendChild(img);
	            return img;
	        };
	        var app = lodash_80(this.getJson, this.url);
	        app("11").map(showImg).run();
	    };
	    demo.prototype.url = function (term) {
	        return './' + term + '.jpg';
	    };
	    demo.prototype.getJson = function (url) {
	        return IO.of(function () {
	            var img = new Image();
	            img.src = url;
	            return img;
	        });
	    };
	    return demo;
	}());

	var _nothing = null;
	var Maybe = (function () {
	    function Maybe() {
	        this.val = null;
	    }
	    Maybe.of = function (x) {
	        return x == null ? _nothing : Maybe.Just(x);
	    };
	    Maybe.maybe = function (x, f, m) {
	    };
	    Maybe.Just = function (x) {
	        return new Just(x);
	    };
	    Maybe.Nothing = function () {
	        return _nothing;
	    };
	    Maybe.isJust = function (x) {
	        return x.isJust();
	    };
	    Maybe.isNothing = function (x) {
	        return x.isNothing();
	    };
	    Maybe.prototype.toString = function () {
	        return "Maybe.Just(" + toString$1(this.val) + ")";
	    };
	    Maybe.prototype.isNothing = function () {
	        return false;
	    };
	    Maybe.prototype.isJust = function () {
	        return false;
	    };
	    return Maybe;
	}());
	Maybe.maybe = curry(function (x, f, m) {
	    return m.isNothing() ? x : f(m.val);
	});
	var Just = (function (_super) {
	    __extends(Just, _super);
	    function Just(x) {
	        var _this = _super.call(this) || this;
	        _this.val = x;
	        return _this;
	    }
	    Just.prototype.isJust = function () {
	        return true;
	    };
	    Just.prototype.isNothing = function () {
	        return false;
	    };
	    Just.prototype.map = function (f) {
	        return new Just(f(this.val));
	    };
	    Just.prototype.chain = function (f) {
	        return f(this.val);
	    };
	    Just.prototype.ap = function (m) {
	        return m.map(this.val);
	    };
	    
	    Just.prototype.getOrElse = function () {
	        return this.val;
	    };
	    Just.prototype.toString = function () {
	        return "Maybe.Just(" + toString$1(this.val) + ")";
	    };
	    return Just;
	}(Maybe));
	var Nothing = (function (_super) {
	    __extends(Nothing, _super);
	    function Nothing() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    Nothing.prototype.isJust = function () {
	        return false;
	    };
	    Nothing.prototype.isNothing = function () {
	        return true;
	    };
	    Nothing.prototype.map = function (f) {
	        return this;
	    };
	    Nothing.prototype.chain = function (f) {
	        return this;
	    };
	    Nothing.prototype.ap = function (m) {
	        return this;
	    };
	    
	    Nothing.prototype.getOrElse = function (value) {
	        return value;
	    };
	    Nothing.prototype.toString = function () {
	        return "Maybe.Nothing()";
	    };
	    return Nothing;
	}(Maybe));
	_nothing = new Nothing();

	var Either = (function () {
	    function Either(x) {
	        this.val = null;
	        this.val = x;
	    }
	    Either.prototype.either = function (leftFn, rightFn) {
	        return null;
	    };
	    return Either;
	}());
	var Right = (function (_super) {
	    __extends(Right, _super);
	    function Right() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    Right.of = function (x) {
	        var obj = new this(x);
	        return obj;
	    };
	    Right.prototype.isRight = function () {
	        return true;
	    };
	    Right.prototype.isLeft = function () {
	        return false;
	    };
	    Right.prototype.map = function (f) {
	        return Right.of(f(this.val));
	    };
	    Right.prototype.ap = function (that) {
	        return that.map(this.val);
	    };
	    Right.prototype.chain = function (f) {
	        return f(this.val);
	    };
	    Right.prototype.toString = function () {
	        return "Right(" + toString$1(this.val) + ")";
	    };
	    return Right;
	}(Either));
	Right.prototype.either = curry(function either(leftFn, rightFn) {
	    return rightFn(this.val);
	});
	var Left = (function (_super) {
	    __extends(Left, _super);
	    function Left() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    Left.of = function (x) {
	        var obj = new this(x);
	        return obj;
	    };
	    Left.prototype.isRight = function () {
	        return false;
	    };
	    Left.prototype.isLeft = function () {
	        return true;
	    };
	    Left.prototype.map = function (f) {
	        return this;
	    };
	    Left.prototype.ap = function (that) {
	        return this;
	    };
	    Left.prototype.chain = function (f) {
	        return this;
	    };
	    Left.prototype.toString = function () {
	        return "Left(" + toString$1(this.val) + ")";
	    };
	    return Left;
	}(Either));
	Left.prototype.either = curry(function either(leftFn, rightFn) {
	    return leftFn(this.val);
	});

	var chain$1 = curry(function (f, m) {
	    return m.chain(f);
	});
	var map$1 = curry(function (f, m) {
	    return m.map(f);
	});
	var either = curry(function (left, right, m) {
	    return m.either(left, right);
	});
	var trace = curry(function (x, m) {
	    console.log(x, " ----> ", m);
	    return m;
	});
	var objToStr = function (m) {
	    return {}.toString.call(m);
	};
	var slice$1 = curry(function (start, end, m) {
	    return m.slice(start, end);
	});
	var lower = function (m) {
	    return m.toLowerCase();
	};
	var trim$1 = function (m) {
	    return m.trim();
	};
	var type = lodash_80(lower, slice$1(8, -1), objToStr);
	var props = curry(function (v, m) {
	    if (type(v) == "string") {
	        return Maybe.of(m[v]);
	    }
	    else if (type(v) == "array") {
	        v.map(function (val) {
	            m = m[val];
	        });
	        return Maybe.of(m);
	    }
	});

	var discount = (function () {
	    function discount() {
	    }
	    discount.prototype.run = function () {
	        var taxPrice = lodash_34(function (tax, price) {
	            if (!lodash_133(price)) {
	                return Left.of("you input price is error");
	            }
	            else {
	                return Right.of(price + (tax * price));
	            }
	        });
	        var discount = lodash_34(function (dis, price) {
	            if (!lodash_133(price))
	                return Left.of("you input price is error");
	            if (price < 10)
	                return Left.of("you input price is lt 10");
	            return Right.of(price - (price * dis));
	        });
	        var addTenTax = taxPrice(0.1);
	        var discount25 = discount(0.25);
	        var displayTotal = function (total) { console.log(': ' + total); };
	        var logError = function (error) { console.log(': ' + error); };
	        var eitherLogOrShow = either(logError, displayTotal);
	        var getPriceAndDiscount = function (item) {
	            return Maybe.of(item).chain(props("price")).chain(addTenTax).chain(discount25);
	        };
	        var showTotalPrice = function (item) { return eitherLogOrShow(getPriceAndDiscount(item)); };
	        var tShirt = { name: 't-shirt', price: 11 };
	        var pant = { name: 't-shirt', price: '10 ' };
	        var chips = { name: 't-shirt', price: 5 };
	        showTotalPrice(tShirt);
	        showTotalPrice(pant);
	        showTotalPrice(chips);
	    };
	    return discount;
	}());
	var a = new discount();

	var Game = (function () {
	    function Game() {
	    }
	    Game.of = function () {
	        var obj = new this();
	        return obj;
	    };
	    Game.prototype.run = function () {
	    };
	    Game.prototype.getCanvas = function () {
	        return IO.of(function () {
	            var canvas = document.createElement("canvas");
	            var ctx = canvas.getContext("2d");
	            document.body.appendChild(canvas);
	            canvas.width = window.innerWidth;
	            canvas.height = window.innerHeight;
	        });
	    };
	    return Game;
	}());

	var AjaxUtil = (function () {
	    function AjaxUtil() {
	    }
	    AjaxUtil.create = function () {
	        var obj = new this();
	        return obj;
	    };
	    AjaxUtil.prototype.ajax = function (params) {
	        params = params || {};
	        params.data = params.data || {};
	        params.jsonp ? this._jsonp(params) : this._json(params);
	    };
	    AjaxUtil.prototype._jsonp = function (params) {
	        var callbackName = params.jsonp;
	        var head = document.getElementsByTagName('head')[0];
	        params.data['jsoncallback'] = callbackName;
	        var data = this._formatParams(params.data);
	        var script = document.createElement('script');
	        head.appendChild(script);
	        window[callbackName] = function (json) {
	            head.removeChild(script);
	            window[callbackName] = null;
	            params.success && params.success(json);
	        };
	        script.src = params.url;
	    };
	    AjaxUtil.prototype._json = function (params) {
	        params.type = (params.type || 'GET').toUpperCase();
	        params.data = this._formatParams(params.data);
	        var xhr = null;
	        try {
	            xhr = new ActiveXObject("microsoft.xmlhttp");
	        }
	        catch (e1) {
	            try {
	                xhr = new XMLHttpRequest();
	            }
	            catch (e2) {
	                console.log(xhr, { message: "ajax" });
	                return null;
	            }
	        }
	        xhr.onreadystatechange = function () {
	            if (xhr.readyState == 4) {
	                var status = xhr.status;
	                if (status >= 200 && status < 300) {
	                    var response = '';
	                    var type = xhr.getResponseHeader('Content-type');
	                    if (type.indexOf('xml') !== -1 && xhr.responseXML) {
	                        response = xhr.responseXML;
	                    }
	                    else if (type === 'application/json') {
	                        response = JSON.parse(xhr.responseText);
	                    }
	                    else {
	                        response = xhr.responseText;
	                    }
	                    params.success && params.success(response);
	                }
	                else {
	                    params.error && params.error(status);
	                }
	            }
	        };
	        if (params.type == 'GET') {
	            xhr.open(params.type, params.url + '?' + params.data, true);
	            xhr.send(null);
	        }
	        else {
	            xhr.open(params.type, params.url, true);
	            xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded; charset=UTF-8');
	            xhr.send(params.data);
	        }
	    };
	    AjaxUtil.prototype._formatParams = function (data) {
	        var arr = [];
	        for (var name in data) {
	            arr.push(encodeURIComponent(name) + '=' + encodeURIComponent(data[name]));
	        }
	        arr.push('v=' + this._random());
	        return arr.join('&');
	    };
	    AjaxUtil.prototype._random = function () {
	        return Math.floor(Math.random() * 10000 + 500);
	    };
	    return AjaxUtil;
	}());

	var imgLoad = (function () {
	    function imgLoad() {
	    }
	    imgLoad.of = function () {
	        var obj = new this();
	        return obj;
	    };
	    imgLoad.prototype.run = function () {
	        var ajax = this.getJson();
	        var showImg = function (url) {
	            return IO.of(function () {
	                var img = new Image();
	                img.onload = function () {
	                    document.getElementById("ct").appendChild(img);
	                };
	                img.src = url;
	            });
	        };
	        var executeIo = function (val) {
	            val.run();
	        };
	        var getImgUrl = lodash_80(executeIo, chain$1(showImg), props(["media", "m"]));
	        var eachImgUrl = map$1(getImgUrl);
	        var safeResponse = function (res) {
	            return Maybe.of(res).chain(props("items")).chain(eachImgUrl);
	        };
	        var response = ajax(safeResponse);
	        var app = lodash_80(response, this.url);
	        app("cars").run();
	    };
	    imgLoad.prototype.url = function (term) {
	        return 'https://api.flickr.com/services/feeds/photos_public.gne?tags=' + term + '&format=json&jsoncallback=callback';
	    };
	    imgLoad.prototype.getJson = function () {
	        return lodash_34(function (callback, url) {
	            return IO.of(function () {
	                return AjaxUtil.create().ajax({
	                    url: url,
	                    jsonp: "callback",
	                    success: callback,
	                    error: function () {
	                        console.log("ajax error");
	                    }
	                });
	            });
	        });
	    };
	    return imgLoad;
	}());

	var parse = (function () {
	    function parse() {
	    }
	    parse.prototype.run = function () {
	        var joeUser = {
	            name: 'joe',
	            email: 'joe@example.com',
	            prefas: {
	                languages: {
	                    primary: 'sp',
	                    secondary: 'en'
	                }
	            }
	        };
	        var indexURLs = {
	            'en': 'http://mysite.com/en',
	            'sp': 'http://mysite.com/sp',
	            'jp': 'http://mysite.com/jp'
	        };
	        var showPage = function (url) {
	            console.log(url);
	        };
	        var maybeGetUrl = curry(function (allUrls, language) {
	            return Maybe.of(allUrls[language]);
	        })(indexURLs);
	        var getUserPrimary = function (user) {
	            return Maybe.of(user).chain(props(["prefas", "languages", "primary"])).chain(maybeGetUrl);
	        };
	        var root = function (user) {
	            showPage(getUserPrimary(user).getOrElse("http://fckthis.com"));
	        };
	        root(joeUser);
	    };
	    return parse;
	}());
	var a$1 = new parse();

	var JudgeUtils = (function () {
	    function JudgeUtils() {
	    }
	    JudgeUtils.isArray = function (arr) {
	        var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
	        var length = arr && arr.length;
	        return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
	    };
	    JudgeUtils.isArrayExactly = function (arr) {
	        return Object.prototype.toString.call(arr) === "[object Array]";
	    };
	    JudgeUtils.isNumber = function (num) {
	        return typeof num == "number";
	    };
	    JudgeUtils.isNumberExactly = function (num) {
	        return Object.prototype.toString.call(num) === "[object Number]";
	    };
	    JudgeUtils.isString = function (str) {
	        return typeof str == "string";
	    };
	    JudgeUtils.isStringExactly = function (str) {
	        return Object.prototype.toString.call(str) === "[object String]";
	    };
	    JudgeUtils.isBoolean = function (bool) {
	        return bool === true || bool === false || toString.call(bool) === '[boolect Boolean]';
	    };
	    JudgeUtils.isDom = function (obj) {
	        return !!(obj && obj.nodeType === 1);
	    };
	    JudgeUtils.isObject = function (obj) {
	        var type = typeof obj;
	        return type === 'function' || type === 'object' && !!obj;
	    };
	    JudgeUtils.isDirectObject = function (obj) {
	        return Object.prototype.toString.call(obj) === "[object Object]";
	    };
	    JudgeUtils.isHostMethod = function (object, property) {
	        var type = typeof object[property];
	        return type === "function" ||
	            (type === "object" && !!object[property]);
	    };
	    JudgeUtils.isNodeJs = function () {
	        return ((typeof global != "undefined" && global.module) || (typeof module != "undefined")) && typeof module.exports != "undefined";
	    };
	    JudgeUtils.isFunction = function (func) {
	        return true;
	    };
	    return JudgeUtils;
	}());
	if (typeof /./ != 'function' && typeof Int8Array != 'object') {
	    JudgeUtils.isFunction = function (func) {
	        return typeof func == 'function';
	    };
	}
	else {
	    JudgeUtils.isFunction = function (func) {
	        return Object.prototype.toString.call(func) === "[object Function]";
	    };
	}

	var root;
	if (JudgeUtils.isNodeJs() && typeof global != "undefined") {
	    root = global;
	}
	else if (typeof window != "undefined") {
	    root = window;
	}
	else if (typeof self != "undefined") {
	    root = self;
	}
	else {
	    Log.error("no avaliable root!");
	}

	var Log = (function () {
	    function Log() {
	    }
	    Log.log = function () {
	        var messages = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            messages[_i] = arguments[_i];
	        }
	        if (!this._exec("log", messages)) {
	            root.alert(messages.join(","));
	        }
	        this._exec("trace", messages);
	    };
	    Log.assert = function (cond) {
	        var messages = [];
	        for (var _i = 1; _i < arguments.length; _i++) {
	            messages[_i - 1] = arguments[_i];
	        }
	        if (cond) {
	            if (!this._exec("assert", arguments, 1)) {
	                this.log.apply(this, Array.prototype.slice.call(arguments, 1));
	            }
	        }
	    };
	    Log.error = function (cond) {
	        var message = [];
	        for (var _i = 1; _i < arguments.length; _i++) {
	            message[_i - 1] = arguments[_i];
	        }
	        if (cond) {
	            throw new Error(Array.prototype.slice.call(arguments, 1).join("\n"));
	        }
	    };
	    Log.warn = function () {
	        var message = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            message[_i] = arguments[_i];
	        }
	        var result = this._exec("warn", arguments);
	        if (!result) {
	            this.log.apply(this, arguments);
	        }
	        else {
	            this._exec("trace", ["warn trace"]);
	        }
	    };
	    Log._exec = function (consoleMethod, args, sliceBegin) {
	        if (sliceBegin === void 0) { sliceBegin = 0; }
	        if (root.console && root.console[consoleMethod]) {
	            root.console[consoleMethod].apply(root.console, Array.prototype.slice.call(args, sliceBegin));
	            return true;
	        }
	        return false;
	    };
	    return Log;
	}());
	Log.info = {
	    INVALID_PARAM: "invalid parameter",
	    helperFunc: function () {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i] = arguments[_i];
	        }
	        var result = "";
	        args.forEach(function (val) {
	            result += String(val) + " ";
	        });
	        return result.slice(0, -1);
	    },
	    assertion: function () {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i] = arguments[_i];
	        }
	        if (args.length === 2) {
	            return this.helperFunc(args[0], args[1]);
	        }
	        else if (args.length === 3) {
	            return this.helperFunc(args[1], args[0], args[2]);
	        }
	        else {
	            throw new Error("args.length must <= 3");
	        }
	    },
	    FUNC_INVALID: function () {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i] = arguments[_i];
	        }
	        args.unshift("invalid");
	        return this.assertion.apply(this, args);
	    },
	    FUNC_MUST: function () {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i] = arguments[_i];
	        }
	        args.unshift("must");
	        return this.assertion.apply(this, args);
	    },
	    FUNC_MUST_BE: function () {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i] = arguments[_i];
	        }
	        args.unshift("must be");
	        return this.assertion.apply(this, args);
	    },
	    FUNC_MUST_NOT_BE: function () {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i] = arguments[_i];
	        }
	        args.unshift("must not be");
	        return this.assertion.apply(this, args);
	    },
	    FUNC_SHOULD: function () {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i] = arguments[_i];
	        }
	        args.unshift("should");
	        return this.assertion.apply(this, args);
	    },
	    FUNC_SHOULD_NOT: function () {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i] = arguments[_i];
	        }
	        args.unshift("should not");
	        return this.assertion.apply(this, args);
	    },
	    FUNC_SUPPORT: function () {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i] = arguments[_i];
	        }
	        args.unshift("support");
	        return this.assertion.apply(this, args);
	    },
	    FUNC_NOT_SUPPORT: function () {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i] = arguments[_i];
	        }
	        args.unshift("not support");
	        return this.assertion.apply(this, args);
	    },
	    FUNC_MUST_DEFINE: function () {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i] = arguments[_i];
	        }
	        args.unshift("must define");
	        return this.assertion.apply(this, args);
	    },
	    FUNC_MUST_NOT_DEFINE: function () {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i] = arguments[_i];
	        }
	        args.unshift("must not define");
	        return this.assertion.apply(this, args);
	    },
	    FUNC_UNKNOW: function () {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i] = arguments[_i];
	        }
	        args.unshift("unknow");
	        return this.assertion.apply(this, args);
	    },
	    FUNC_EXPECT: function () {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i] = arguments[_i];
	        }
	        args.unshift("expect");
	        return this.assertion.apply(this, args);
	    },
	    FUNC_UNEXPECT: function () {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i] = arguments[_i];
	        }
	        args.unshift("unexpect");
	        return this.assertion.apply(this, args);
	    },
	    FUNC_EXIST: function () {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i] = arguments[_i];
	        }
	        args.unshift("exist");
	        return this.assertion.apply(this, args);
	    },
	    FUNC_NOT_EXIST: function () {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i] = arguments[_i];
	        }
	        args.unshift("not exist");
	        return this.assertion.apply(this, args);
	    },
	    FUNC_ONLY: function () {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i] = arguments[_i];
	        }
	        args.unshift("only");
	        return this.assertion.apply(this, args);
	    },
	    FUNC_CAN_NOT: function () {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i] = arguments[_i];
	        }
	        args.unshift("can't");
	        return this.assertion.apply(this, args);
	    }
	};

	var Entity = (function () {
	    function Entity(uidPre) {
	        this._uid = null;
	        this._uid = uidPre + String(Entity.UID++);
	    }
	    Object.defineProperty(Entity.prototype, "uid", {
	        get: function () {
	            return this._uid;
	        },
	        set: function (uid) {
	            this._uid = uid;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return Entity;
	}());
	Entity.UID = 1;

	var $BREAK = {
	    break: true
	};
	var $REMOVE = void 0;

	var List = (function () {
	    function List() {
	        this.children = null;
	    }
	    List.prototype.getCount = function () {
	        return this.children.length;
	    };
	    List.prototype.hasChild = function (child) {
	        var c = null, children = this.children;
	        for (var i = 0, len = children.length; i < len; i++) {
	            c = children[i];
	            if (child.uid && c.uid && child.uid == c.uid) {
	                return true;
	            }
	            else if (child === c) {
	                return true;
	            }
	        }
	        return false;
	    };
	    List.prototype.hasChildWithFunc = function (func) {
	        for (var i = 0, len = this.children.length; i < len; i++) {
	            if (func(this.children[i], i)) {
	                return true;
	            }
	        }
	        return false;
	    };
	    List.prototype.getChildren = function () {
	        return this.children;
	    };
	    List.prototype.getChild = function (index) {
	        return this.children[index];
	    };
	    List.prototype.addChild = function (child) {
	        this.children.push(child);
	        return this;
	    };
	    List.prototype.addChildren = function (arg) {
	        if (JudgeUtils.isArray(arg)) {
	            var children = arg;
	            this.children = this.children.concat(children);
	        }
	        else if (arg instanceof List) {
	            var children = arg;
	            this.children = this.children.concat(children.getChildren());
	        }
	        else {
	            var child = arg;
	            this.addChild(child);
	        }
	        return this;
	    };
	    List.prototype.setChildren = function (children) {
	        this.children = children;
	        return this;
	    };
	    List.prototype.unShiftChild = function (child) {
	        this.children.unshift(child);
	    };
	    List.prototype.removeAllChildren = function () {
	        this.children = [];
	        return this;
	    };
	    List.prototype.forEach = function (func, context) {
	        this._forEach(this.children, func, context);
	        return this;
	    };
	    List.prototype.toArray = function () {
	        return this.children;
	    };
	    List.prototype.copyChildren = function () {
	        return this.children.slice(0);
	    };
	    List.prototype.removeChildHelper = function (arg) {
	        var result = null;
	        if (JudgeUtils.isFunction(arg)) {
	            var func = arg;
	            result = this._removeChild(this.children, func);
	        }
	        else if (arg.uid) {
	            result = this._removeChild(this.children, function (e) {
	                if (!e.uid) {
	                    return false;
	                }
	                return e.uid === arg.uid;
	            });
	        }
	        else {
	            result = this._removeChild(this.children, function (e) {
	                return e === arg;
	            });
	        }
	        return result;
	    };
	    List.prototype._forEach = function (arr, func, context) {
	        var scope = context, i = 0, len = arr.length;
	        for (i = 0; i < len; i++) {
	            if (func.call(scope, arr[i], i) === $BREAK) {
	                break;
	            }
	        }
	    };
	    List.prototype._removeChild = function (arr, func) {
	        var self = this, removedElementArr = [], remainElementArr = [];
	        this._forEach(arr, function (e, index) {
	            if (!!func.call(self, e)) {
	                removedElementArr.push(e);
	            }
	            else {
	                remainElementArr.push(e);
	            }
	        });
	        this.children = remainElementArr;
	        return removedElementArr;
	    };
	    return List;
	}());

	var ExtendUtils = (function () {
	    function ExtendUtils() {
	    }
	    ExtendUtils.extendDeep = function (parent, child, filter) {
	        if (filter === void 0) { filter = function (val, i) { return true; }; }
	        var i = null, len = 0, toStr = Object.prototype.toString, sArr = "[object Array]", sOb = "[object Object]", type = "", _child = null;
	        if (toStr.call(parent) === sArr) {
	            _child = child || [];
	            for (i = 0, len = parent.length; i < len; i++) {
	                var member = parent[i];
	                if (!filter(member, i)) {
	                    continue;
	                }
	                if (member.clone) {
	                    _child[i] = member.clone();
	                    continue;
	                }
	                type = toStr.call(member);
	                if (type === sArr || type === sOb) {
	                    _child[i] = type === sArr ? [] : {};
	                    ExtendUtils.extendDeep(member, _child[i]);
	                }
	                else {
	                    _child[i] = member;
	                }
	            }
	        }
	        else if (toStr.call(parent) === sOb) {
	            _child = child || {};
	            for (i in parent) {
	                var member = parent[i];
	                if (!filter(member, i)) {
	                    continue;
	                }
	                if (member.clone) {
	                    _child[i] = member.clone();
	                    continue;
	                }
	                type = toStr.call(member);
	                if (type === sArr || type === sOb) {
	                    _child[i] = type === sArr ? [] : {};
	                    ExtendUtils.extendDeep(member, _child[i]);
	                }
	                else {
	                    _child[i] = member;
	                }
	            }
	        }
	        else {
	            _child = parent;
	        }
	        return _child;
	    };
	    ExtendUtils.extend = function (destination, source) {
	        var property = "";
	        for (property in source) {
	            destination[property] = source[property];
	        }
	        return destination;
	    };
	    ExtendUtils.copyPublicAttri = function (source) {
	        var property = null, destination = {};
	        this.extendDeep(source, destination, function (item, property) {
	            return property.slice(0, 1) !== "_"
	                && !JudgeUtils.isFunction(item);
	        });
	        return destination;
	    };
	    return ExtendUtils;
	}());

	var Collection = (function (_super) {
	    __extends(Collection, _super);
	    function Collection(children) {
	        if (children === void 0) { children = []; }
	        var _this = _super.call(this) || this;
	        _this.children = children;
	        return _this;
	    }
	    Collection.create = function (children) {
	        if (children === void 0) { children = []; }
	        var obj = new this(children);
	        return obj;
	    };
	    Collection.prototype.clone = function () {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i] = arguments[_i];
	        }
	        var target = null, isDeep = null;
	        if (args.length === 0) {
	            isDeep = false;
	            target = Collection.create();
	        }
	        else if (args.length === 1) {
	            if (JudgeUtils.isBoolean(args[0])) {
	                target = Collection.create();
	                isDeep = args[0];
	            }
	            else {
	                target = args[0];
	                isDeep = false;
	            }
	        }
	        else {
	            target = args[0];
	            isDeep = args[1];
	        }
	        if (isDeep === true) {
	            target.setChildren(ExtendUtils.extendDeep(this.children));
	        }
	        else {
	            target.setChildren(ExtendUtils.extend([], this.children));
	        }
	        return target;
	    };
	    Collection.prototype.filter = function (func) {
	        var children = this.children, result = [], value = null;
	        for (var i = 0, len = children.length; i < len; i++) {
	            value = children[i];
	            if (func.call(children, value, i)) {
	                result.push(value);
	            }
	        }
	        return Collection.create(result);
	    };
	    Collection.prototype.findOne = function (func) {
	        var scope = this.children, result = null;
	        this.forEach(function (value, index) {
	            if (!func.call(scope, value, index)) {
	                return;
	            }
	            result = value;
	            return $BREAK;
	        });
	        return result;
	    };
	    Collection.prototype.reverse = function () {
	        return Collection.create(this.copyChildren().reverse());
	    };
	    Collection.prototype.removeChild = function (arg) {
	        return Collection.create(this.removeChildHelper(arg));
	    };
	    Collection.prototype.sort = function (func, isSortSelf) {
	        if (isSortSelf === void 0) { isSortSelf = false; }
	        if (isSortSelf) {
	            this.children.sort(func);
	            return this;
	        }
	        return Collection.create(this.copyChildren().sort(func));
	    };
	    Collection.prototype.map = function (func) {
	        var resultArr = [];
	        this.forEach(function (e, index) {
	            var result = func(e, index);
	            if (result !== $REMOVE) {
	                resultArr.push(result);
	            }
	        });
	        return Collection.create(resultArr);
	    };
	    Collection.prototype.removeRepeatItems = function () {
	        var noRepeatList = Collection.create();
	        this.forEach(function (item) {
	            if (noRepeatList.hasChild(item)) {
	                return;
	            }
	            noRepeatList.addChild(item);
	        });
	        return noRepeatList;
	    };
	    Collection.prototype.hasRepeatItems = function () {
	        var noRepeatList = Collection.create(), hasRepeat = false;
	        this.forEach(function (item) {
	            if (noRepeatList.hasChild(item)) {
	                hasRepeat = true;
	                return $BREAK;
	            }
	            noRepeatList.addChild(item);
	        });
	        return hasRepeat;
	    };
	    return Collection;
	}(List));

	var JudgeUtils$1 = (function (_super) {
	    __extends(JudgeUtils$$1, _super);
	    function JudgeUtils$$1() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    JudgeUtils$$1.isPromise = function (obj) {
	        return !!obj
	            && !_super.isFunction.call(this, obj.subscribe)
	            && _super.isFunction.call(this, obj.then);
	    };
	    JudgeUtils$$1.isEqual = function (ob1, ob2) {
	        return ob1.uid === ob2.uid;
	    };
	    JudgeUtils$$1.isIObserver = function (i) {
	        return i.next && i.error && i.completed;
	    };
	    return JudgeUtils$$1;
	}(JudgeUtils));

	var SubjectObserver = (function () {
	    function SubjectObserver() {
	        this.observers = Collection.create();
	        this._disposable = null;
	    }
	    SubjectObserver.prototype.isEmpty = function () {
	        return this.observers.getCount() === 0;
	    };
	    SubjectObserver.prototype.next = function (value) {
	        this.observers.forEach(function (ob) {
	            ob.next(value);
	        });
	    };
	    SubjectObserver.prototype.error = function (error) {
	        this.observers.forEach(function (ob) {
	            ob.error(error);
	        });
	    };
	    SubjectObserver.prototype.completed = function () {
	        this.observers.forEach(function (ob) {
	            ob.completed();
	        });
	    };
	    SubjectObserver.prototype.addChild = function (observer) {
	        this.observers.addChild(observer);
	        observer.setDisposable(this._disposable);
	    };
	    SubjectObserver.prototype.removeChild = function (observer) {
	        this.observers.removeChild(function (ob) {
	            return JudgeUtils$1.isEqual(ob, observer);
	        });
	    };
	    SubjectObserver.prototype.dispose = function () {
	        this.observers.forEach(function (ob) {
	            ob.dispose();
	        });
	        this.observers.removeAllChildren();
	    };
	    SubjectObserver.prototype.setDisposable = function (disposable) {
	        this.observers.forEach(function (observer) {
	            observer.setDisposable(disposable);
	        });
	        this._disposable = disposable;
	    };
	    return SubjectObserver;
	}());

	var Observer = (function (_super) {
	    __extends(Observer, _super);
	    function Observer() {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i] = arguments[_i];
	        }
	        var _this = _super.call(this, "Observer") || this;
	        _this._isDisposed = null;
	        _this.onUserNext = null;
	        _this.onUserError = null;
	        _this.onUserCompleted = null;
	        _this._isStop = false;
	        _this._disposable = null;
	        if (args.length === 1) {
	            var observer_1 = args[0];
	            _this.onUserNext = function (v) {
	                observer_1.next(v);
	            };
	            _this.onUserError = function (e) {
	                observer_1.error(e);
	            };
	            _this.onUserCompleted = function () {
	                observer_1.completed();
	            };
	        }
	        else {
	            var onNext = args[0], onError = args[1], onCompleted = args[2];
	            _this.onUserNext = onNext || function (v) { };
	            _this.onUserError = onError || function (e) {
	                throw e;
	            };
	            _this.onUserCompleted = onCompleted || function () { };
	        }
	        return _this;
	    }
	    Object.defineProperty(Observer.prototype, "isDisposed", {
	        get: function () {
	            return this._isDisposed;
	        },
	        set: function (isDisposed) {
	            this._isDisposed = isDisposed;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Observer.prototype.next = function (value) {
	        if (!this._isStop) {
	            return this.onNext(value);
	        }
	    };
	    Observer.prototype.error = function (error) {
	        if (!this._isStop) {
	            this._isStop = true;
	            this.onError(error);
	        }
	    };
	    Observer.prototype.completed = function () {
	        if (!this._isStop) {
	            this._isStop = true;
	            this.onCompleted();
	        }
	    };
	    Observer.prototype.dispose = function () {
	        this._isStop = true;
	        this._isDisposed = true;
	        if (this._disposable) {
	            this._disposable.dispose();
	        }
	    };
	    Observer.prototype.setDisposable = function (disposable) {
	        this._disposable = disposable;
	    };
	    return Observer;
	}(Entity));

	var Main = (function () {
	    function Main() {
	    }
	    return Main;
	}());
	Main.isTest = false;

	function assert(cond, message) {
	    if (message === void 0) { message = "contract error"; }
	    Log.error(!cond, message);
	}
	function requireCheck(InFunc) {
	    return function (target, name, descriptor) {
	        var value = descriptor.value;
	        descriptor.value = function () {
	            var args = [];
	            for (var _i = 0; _i < arguments.length; _i++) {
	                args[_i] = arguments[_i];
	            }
	            if (Main.isTest) {
	                InFunc.apply(this, args);
	            }
	            return value.apply(this, args);
	        };
	        return descriptor;
	    };
	}

	var AutoDetachObserver = (function (_super) {
	    __extends(AutoDetachObserver, _super);
	    function AutoDetachObserver() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    AutoDetachObserver.create = function () {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i] = arguments[_i];
	        }
	        if (args.length === 1) {
	            return new this(args[0]);
	        }
	        else {
	            return new this(args[0], args[1], args[2]);
	        }
	    };
	    AutoDetachObserver.prototype.dispose = function () {
	        if (this.isDisposed) {
	            return;
	        }
	        _super.prototype.dispose.call(this);
	    };
	    AutoDetachObserver.prototype.onNext = function (value) {
	        try {
	            this.onUserNext(value);
	        }
	        catch (e) {
	            this.onError(e);
	        }
	    };
	    AutoDetachObserver.prototype.onError = function (error) {
	        try {
	            this.onUserError(error);
	        }
	        catch (e) {
	            throw e;
	        }
	        finally {
	            this.dispose();
	        }
	    };
	    AutoDetachObserver.prototype.onCompleted = function () {
	        try {
	            this.onUserCompleted();
	            this.dispose();
	        }
	        catch (e) {
	            throw e;
	        }
	    };
	    return AutoDetachObserver;
	}(Observer));
	__decorate([
	    requireCheck(function () {
	        if (this.isDisposed) {
	            Log.warn("only can dispose once");
	        }
	    })
	], AutoDetachObserver.prototype, "dispose", null);

	var InnerSubscription = (function () {
	    function InnerSubscription(subject, observer) {
	        this._subject = null;
	        this._observer = null;
	        this._subject = subject;
	        this._observer = observer;
	    }
	    InnerSubscription.create = function (subject, observer) {
	        var obj = new this(subject, observer);
	        return obj;
	    };
	    InnerSubscription.prototype.dispose = function () {
	        this._subject.remove(this._observer);
	        this._observer.dispose();
	    };
	    return InnerSubscription;
	}());

	var Subject = (function () {
	    function Subject() {
	        this._source = null;
	        this._observer = new SubjectObserver();
	    }
	    Subject.create = function () {
	        var obj = new this();
	        return obj;
	    };
	    Object.defineProperty(Subject.prototype, "source", {
	        get: function () {
	            return this._source;
	        },
	        set: function (source) {
	            this._source = source;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Subject.prototype.subscribe = function (arg1, onError, onCompleted) {
	        var observer = arg1 instanceof Observer
	            ? arg1
	            : AutoDetachObserver.create(arg1, onError, onCompleted);
	        this._observer.addChild(observer);
	        return InnerSubscription.create(this, observer);
	    };
	    Subject.prototype.next = function (value) {
	        this._observer.next(value);
	    };
	    Subject.prototype.error = function (error) {
	        this._observer.error(error);
	    };
	    Subject.prototype.completed = function () {
	        this._observer.completed();
	    };
	    Subject.prototype.start = function () {
	        if (!this._source) {
	            return;
	        }
	        this._observer.setDisposable(this._source.buildStream(this));
	    };
	    Subject.prototype.remove = function (observer) {
	        this._observer.removeChild(observer);
	    };
	    Subject.prototype.dispose = function () {
	        this._observer.dispose();
	    };
	    return Subject;
	}());

	var SingleDisposable = (function (_super) {
	    __extends(SingleDisposable, _super);
	    function SingleDisposable(disposeHandler) {
	        var _this = _super.call(this, "SingleDisposable") || this;
	        _this._disposeHandler = null;
	        _this._isDisposed = false;
	        _this._disposeHandler = disposeHandler;
	        return _this;
	    }
	    SingleDisposable.create = function (disposeHandler) {
	        if (disposeHandler === void 0) { disposeHandler = function () { }; }
	        var obj = new this(disposeHandler);
	        return obj;
	    };
	    SingleDisposable.prototype.setDisposeHandler = function (handler) {
	        this._disposeHandler = handler;
	    };
	    SingleDisposable.prototype.dispose = function () {
	        if (this._isDisposed) {
	            return;
	        }
	        this._isDisposed = true;
	        this._disposeHandler();
	    };
	    return SingleDisposable;
	}(Entity));

	var ClassMapUtils = (function () {
	    function ClassMapUtils() {
	    }
	    ClassMapUtils.addClassMap = function (className, _class) {
	        this._classMap[className] = _class;
	    };
	    ClassMapUtils.getClass = function (className) {
	        return this._classMap[className];
	    };
	    return ClassMapUtils;
	}());
	ClassMapUtils._classMap = {};

	var FunctionUtils = (function () {
	    function FunctionUtils() {
	    }
	    FunctionUtils.bind = function (object, func) {
	        return function () {
	            return func.apply(object, arguments);
	        };
	    };
	    return FunctionUtils;
	}());

	var Stream = (function (_super) {
	    __extends(Stream, _super);
	    function Stream(subscribeFunc) {
	        var _this = _super.call(this, "Stream") || this;
	        _this.scheduler = null;
	        _this.subscribeFunc = null;
	        _this.subscribeFunc = subscribeFunc || function () { };
	        return _this;
	    }
	    Stream.prototype.buildStream = function (observer) {
	        return SingleDisposable.create((this.subscribeFunc(observer) || function () { }));
	    };
	    Stream.prototype.do = function (onNext, onError, onCompleted) {
	        return ClassMapUtils.getClass("DoStream").create(this, onNext, onError, onCompleted);
	    };
	    Stream.prototype.map = function (selector) {
	        return ClassMapUtils.getClass("MapStream").create(this, selector);
	    };
	    Stream.prototype.flatMap = function (selector) {
	        return this.map(selector).mergeAll();
	    };
	    Stream.prototype.concatMap = function (selector) {
	        return this.map(selector).concatAll();
	    };
	    Stream.prototype.mergeAll = function () {
	        return ClassMapUtils.getClass("MergeAllStream").create(this);
	    };
	    Stream.prototype.concatAll = function () {
	        return this.merge(1);
	    };
	    Stream.prototype.skipUntil = function (otherStream) {
	        return ClassMapUtils.getClass("SkipUntilStream").create(this, otherStream);
	    };
	    Stream.prototype.takeUntil = function (otherStream) {
	        return ClassMapUtils.getClass("TakeUntilStream").create(this, otherStream);
	    };
	    Stream.prototype.take = function (count) {
	        if (count === void 0) { count = 1; }
	        var self = this;
	        if (count === 0) {
	            return ClassMapUtils.getClass("Operator").empty();
	        }
	        return ClassMapUtils.getClass("Operator").createStream(function (observer) {
	            self.subscribe(function (value) {
	                if (count > 0) {
	                    observer.next(value);
	                }
	                count--;
	                if (count <= 0) {
	                    observer.completed();
	                }
	            }, function (e) {
	                observer.error(e);
	            }, function () {
	                observer.completed();
	            });
	        });
	    };
	    Stream.prototype.takeLast = function (count) {
	        if (count === void 0) { count = 1; }
	        var self = this;
	        if (count === 0) {
	            return ClassMapUtils.getClass("Operator").empty();
	        }
	        return ClassMapUtils.getClass("Operator").createStream(function (observer) {
	            var queue = [];
	            self.subscribe(function (value) {
	                queue.push(value);
	                if (queue.length > count) {
	                    queue.shift();
	                }
	            }, function (e) {
	                observer.error(e);
	            }, function () {
	                while (queue.length > 0) {
	                    observer.next(queue.shift());
	                }
	                observer.completed();
	            });
	        });
	    };
	    Stream.prototype.takeWhile = function (predicate, thisArg) {
	        if (thisArg === void 0) { thisArg = this; }
	        var self = this, bindPredicate = null;
	        bindPredicate = FunctionUtils.bind(thisArg, predicate);
	        return ClassMapUtils.getClass("Operator").createStream(function (observer) {
	            var i = 0, isStart = false;
	            self.subscribe(function (value) {
	                if (bindPredicate(value, i++, self)) {
	                    try {
	                        observer.next(value);
	                        isStart = true;
	                    }
	                    catch (e) {
	                        observer.error(e);
	                        return;
	                    }
	                }
	                else {
	                    if (isStart) {
	                        observer.completed();
	                    }
	                }
	            }, function (e) {
	                observer.error(e);
	            }, function () {
	                observer.completed();
	            });
	        });
	    };
	    Stream.prototype.lastOrDefault = function (defaultValue) {
	        if (defaultValue === void 0) { defaultValue = null; }
	        var self = this;
	        return ClassMapUtils.getClass("Operator").createStream(function (observer) {
	            var queue = [];
	            self.subscribe(function (value) {
	                queue.push(value);
	                if (queue.length > 1) {
	                    queue.shift();
	                }
	            }, function (e) {
	                observer.error(e);
	            }, function () {
	                if (queue.length === 0) {
	                    observer.next(defaultValue);
	                }
	                else {
	                    while (queue.length > 0) {
	                        observer.next(queue.shift());
	                    }
	                }
	                observer.completed();
	            });
	        });
	    };
	    Stream.prototype.filter = function (predicate, thisArg) {
	        if (thisArg === void 0) { thisArg = this; }
	        if (this instanceof ClassMapUtils.getClass("FilterStream")) {
	            var self = this;
	            return self.internalFilter(predicate, thisArg);
	        }
	        return ClassMapUtils.getClass("FilterStream").create(this, predicate, thisArg);
	    };
	    Stream.prototype.filterWithState = function (predicate, thisArg) {
	        if (thisArg === void 0) { thisArg = this; }
	        if (this instanceof ClassMapUtils.getClass("FilterStream")) {
	            var self = this;
	            return self.internalFilter(predicate, thisArg);
	        }
	        return ClassMapUtils.getClass("FilterWithStateStream").create(this, predicate, thisArg);
	    };
	    Stream.prototype.concat = function () {
	        var args = null;
	        if (JudgeUtils$1.isArray(arguments[0])) {
	            args = arguments[0];
	        }
	        else {
	            args = Array.prototype.slice.call(arguments, 0);
	        }
	        args.unshift(this);
	        return ClassMapUtils.getClass("ConcatStream").create(args);
	    };
	    Stream.prototype.merge = function () {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i] = arguments[_i];
	        }
	        if (JudgeUtils$1.isNumber(args[0])) {
	            var maxConcurrent = args[0];
	            return ClassMapUtils.getClass("MergeStream").create(this, maxConcurrent);
	        }
	        if (JudgeUtils$1.isArray(args[0])) {
	            args = arguments[0];
	        }
	        else {
	        }
	        var stream = null;
	        args.unshift(this);
	        stream = ClassMapUtils.getClass("Operator").fromArray(args).mergeAll();
	        return stream;
	    };
	    Stream.prototype.repeat = function (count) {
	        if (count === void 0) { count = -1; }
	        return ClassMapUtils.getClass("RepeatStream").create(this, count);
	    };
	    Stream.prototype.ignoreElements = function () {
	        return ClassMapUtils.getClass("IgnoreElementsStream").create(this);
	    };
	    Stream.prototype.handleSubject = function (subject) {
	        if (this._isSubject(subject)) {
	            this._setSubject(subject);
	            return true;
	        }
	        return false;
	    };
	    Stream.prototype._isSubject = function (subject) {
	        return subject instanceof Subject;
	    };
	    Stream.prototype._setSubject = function (subject) {
	        subject.source = this;
	    };
	    return Stream;
	}(Entity));
	__decorate([
	    requireCheck(function (count) {
	        if (count === void 0) { count = 1; }
	        assert(count >= 0, Log.info.FUNC_SHOULD("count", ">= 0"));
	    })
	], Stream.prototype, "take", null);
	__decorate([
	    requireCheck(function (count) {
	        if (count === void 0) { count = 1; }
	        assert(count >= 0, Log.info.FUNC_SHOULD("count", ">= 0"));
	    })
	], Stream.prototype, "takeLast", null);

	var BaseStream = (function (_super) {
	    __extends(BaseStream, _super);
	    function BaseStream() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    BaseStream.prototype.subscribe = function (arg1, onError, onCompleted) {
	        var observer = null;
	        if (this.handleSubject(arg1)) {
	            return;
	        }
	        observer = arg1 instanceof Observer
	            ? AutoDetachObserver.create(arg1)
	            : AutoDetachObserver.create(arg1, onError, onCompleted);
	        observer.setDisposable(this.buildStream(observer));
	        return observer;
	    };
	    BaseStream.prototype.buildStream = function (observer) {
	        _super.prototype.buildStream.call(this, observer);
	        return this.subscribeCore(observer);
	    };
	    return BaseStream;
	}(Stream));

	var MapObserver = (function (_super) {
	    __extends(MapObserver, _super);
	    function MapObserver(currentObserver, selector) {
	        var _this = _super.call(this, null, null, null) || this;
	        _this._currentObserver = null;
	        _this._selector = null;
	        _this._currentObserver = currentObserver;
	        _this._selector = selector;
	        return _this;
	    }
	    MapObserver.create = function (currentObserver, selector) {
	        return new this(currentObserver, selector);
	    };
	    MapObserver.prototype.onNext = function (value) {
	        var result = null;
	        try {
	            result = this._selector(value);
	        }
	        catch (e) {
	            this._currentObserver.error(e);
	        }
	        finally {
	            this._currentObserver.next(result);
	        }
	    };
	    MapObserver.prototype.onError = function (error) {
	        this._currentObserver.error(error);
	    };
	    MapObserver.prototype.onCompleted = function () {
	        this._currentObserver.completed();
	    };
	    return MapObserver;
	}(Observer));

	function registerClass(className) {
	    return function (target) {
	        ClassMapUtils.addClassMap(className, target);
	    };
	}

	var MapStream = (function (_super) {
	    __extends(MapStream, _super);
	    function MapStream(source, selector) {
	        var _this = _super.call(this, null) || this;
	        _this._source = null;
	        _this._selector = null;
	        _this._source = source;
	        _this.scheduler = _this._source.scheduler;
	        _this._selector = selector;
	        return _this;
	    }
	    MapStream.create = function (source, selector) {
	        var obj = new this(source, selector);
	        return obj;
	    };
	    MapStream.prototype.subscribeCore = function (observer) {
	        return this._source.buildStream(MapObserver.create(observer, this._selector));
	    };
	    return MapStream;
	}(BaseStream));
	MapStream = __decorate([
	    registerClass("MapStream")
	], MapStream);

	// CommonJS / Node have global context exposed as "global" variable.
	// We don't want to include the whole node.d.ts this this compilation unit so we'll just fake
	// the global "global" var for now.
	var __window = typeof window !== 'undefined' && window;
	var __self = typeof self !== 'undefined' && typeof WorkerGlobalScope !== 'undefined' &&
	    self instanceof WorkerGlobalScope && self;
	var __global = typeof commonjsGlobal !== 'undefined' && commonjsGlobal;
	var _root$2 = __window || __global || __self;
	var root_1$1 = _root$2;
	// Workaround Closure Compiler restriction: The body of a goog.module cannot use throw.
	// This is needed when used with angular/tsickle which inserts a goog.module statement.
	// Wrap in IIFE
	(function () {
	    if (!_root$2) {
	        throw new Error('RxJS could not find any global context (window, self, global)');
	    }
	})();


	var root$1 = {
		root: root_1$1
	};

	function isFunction$1(x) {
	    return typeof x === 'function';
	}
	var isFunction_2 = isFunction$1;


	var isFunction_1$2 = {
		isFunction: isFunction_2
	};

	var isArray_1$2 = Array.isArray || (function (x) { return x && typeof x.length === 'number'; });


	var isArray$1 = {
		isArray: isArray_1$2
	};

	function isObject$1(x) {
	    return x != null && typeof x === 'object';
	}
	var isObject_2 = isObject$1;


	var isObject_1$2 = {
		isObject: isObject_2
	};

	// typeof any so that it we don't have to cast when comparing a result to the error object
	var errorObject_1$2 = { e: {} };


	var errorObject = {
		errorObject: errorObject_1$2
	};

	var errorObject_1$1 = errorObject;
	var tryCatchTarget;
	function tryCatcher() {
	    try {
	        return tryCatchTarget.apply(this, arguments);
	    }
	    catch (e) {
	        errorObject_1$1.errorObject.e = e;
	        return errorObject_1$1.errorObject;
	    }
	}
	function tryCatch(fn) {
	    tryCatchTarget = fn;
	    return tryCatcher;
	}
	var tryCatch_2 = tryCatch;



	var tryCatch_1$1 = {
		tryCatch: tryCatch_2
	};

	var __extends$3 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/**
	 * An error thrown when one or more errors have occurred during the
	 * `unsubscribe` of a {@link Subscription}.
	 */
	var UnsubscriptionError$1 = (function (_super) {
	    __extends$3(UnsubscriptionError, _super);
	    function UnsubscriptionError(errors) {
	        _super.call(this);
	        this.errors = errors;
	        var err = Error.call(this, errors ?
	            errors.length + " errors occurred during unsubscription:\n  " + errors.map(function (err, i) { return ((i + 1) + ") " + err.toString()); }).join('\n  ') : '');
	        this.name = err.name = 'UnsubscriptionError';
	        this.stack = err.stack;
	        this.message = err.message;
	    }
	    return UnsubscriptionError;
	}(Error));
	var UnsubscriptionError_2 = UnsubscriptionError$1;


	var UnsubscriptionError_1$2 = {
		UnsubscriptionError: UnsubscriptionError_2
	};

	var isArray_1$1 = isArray$1;
	var isObject_1$1 = isObject_1$2;
	var isFunction_1$4 = isFunction_1$2;
	var tryCatch_1 = tryCatch_1$1;
	var errorObject_1 = errorObject;
	var UnsubscriptionError_1$1 = UnsubscriptionError_1$2;
	/**
	 * Represents a disposable resource, such as the execution of an Observable. A
	 * Subscription has one important method, `unsubscribe`, that takes no argument
	 * and just disposes the resource held by the subscription.
	 *
	 * Additionally, subscriptions may be grouped together through the `add()`
	 * method, which will attach a child Subscription to the current Subscription.
	 * When a Subscription is unsubscribed, all its children (and its grandchildren)
	 * will be unsubscribed as well.
	 *
	 * @class Subscription
	 */
	var Subscription$1 = (function () {
	    /**
	     * @param {function(): void} [unsubscribe] A function describing how to
	     * perform the disposal of resources when the `unsubscribe` method is called.
	     */
	    function Subscription(unsubscribe) {
	        /**
	         * A flag to indicate whether this Subscription has already been unsubscribed.
	         * @type {boolean}
	         */
	        this.closed = false;
	        this._parent = null;
	        this._parents = null;
	        this._subscriptions = null;
	        if (unsubscribe) {
	            this._unsubscribe = unsubscribe;
	        }
	    }
	    /**
	     * Disposes the resources held by the subscription. May, for instance, cancel
	     * an ongoing Observable execution or cancel any other type of work that
	     * started when the Subscription was created.
	     * @return {void}
	     */
	    Subscription.prototype.unsubscribe = function () {
	        var hasErrors = false;
	        var errors;
	        if (this.closed) {
	            return;
	        }
	        var _a = this, _parent = _a._parent, _parents = _a._parents, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;
	        this.closed = true;
	        this._parent = null;
	        this._parents = null;
	        // null out _subscriptions first so any child subscriptions that attempt
	        // to remove themselves from this subscription will noop
	        this._subscriptions = null;
	        var index = -1;
	        var len = _parents ? _parents.length : 0;
	        // if this._parent is null, then so is this._parents, and we
	        // don't have to remove ourselves from any parent subscriptions.
	        while (_parent) {
	            _parent.remove(this);
	            // if this._parents is null or index >= len,
	            // then _parent is set to null, and the loop exits
	            _parent = ++index < len && _parents[index] || null;
	        }
	        if (isFunction_1$4.isFunction(_unsubscribe)) {
	            var trial = tryCatch_1.tryCatch(_unsubscribe).call(this);
	            if (trial === errorObject_1.errorObject) {
	                hasErrors = true;
	                errors = errors || (errorObject_1.errorObject.e instanceof UnsubscriptionError_1$1.UnsubscriptionError ?
	                    flattenUnsubscriptionErrors(errorObject_1.errorObject.e.errors) : [errorObject_1.errorObject.e]);
	            }
	        }
	        if (isArray_1$1.isArray(_subscriptions)) {
	            index = -1;
	            len = _subscriptions.length;
	            while (++index < len) {
	                var sub = _subscriptions[index];
	                if (isObject_1$1.isObject(sub)) {
	                    var trial = tryCatch_1.tryCatch(sub.unsubscribe).call(sub);
	                    if (trial === errorObject_1.errorObject) {
	                        hasErrors = true;
	                        errors = errors || [];
	                        var err = errorObject_1.errorObject.e;
	                        if (err instanceof UnsubscriptionError_1$1.UnsubscriptionError) {
	                            errors = errors.concat(flattenUnsubscriptionErrors(err.errors));
	                        }
	                        else {
	                            errors.push(err);
	                        }
	                    }
	                }
	            }
	        }
	        if (hasErrors) {
	            throw new UnsubscriptionError_1$1.UnsubscriptionError(errors);
	        }
	    };
	    /**
	     * Adds a tear down to be called during the unsubscribe() of this
	     * Subscription.
	     *
	     * If the tear down being added is a subscription that is already
	     * unsubscribed, is the same reference `add` is being called on, or is
	     * `Subscription.EMPTY`, it will not be added.
	     *
	     * If this subscription is already in an `closed` state, the passed
	     * tear down logic will be executed immediately.
	     *
	     * @param {TeardownLogic} teardown The additional logic to execute on
	     * teardown.
	     * @return {Subscription} Returns the Subscription used or created to be
	     * added to the inner subscriptions list. This Subscription can be used with
	     * `remove()` to remove the passed teardown logic from the inner subscriptions
	     * list.
	     */
	    Subscription.prototype.add = function (teardown) {
	        if (!teardown || (teardown === Subscription.EMPTY)) {
	            return Subscription.EMPTY;
	        }
	        if (teardown === this) {
	            return this;
	        }
	        var subscription = teardown;
	        switch (typeof teardown) {
	            case 'function':
	                subscription = new Subscription(teardown);
	            case 'object':
	                if (subscription.closed || typeof subscription.unsubscribe !== 'function') {
	                    return subscription;
	                }
	                else if (this.closed) {
	                    subscription.unsubscribe();
	                    return subscription;
	                }
	                else if (typeof subscription._addParent !== 'function' /* quack quack */) {
	                    var tmp = subscription;
	                    subscription = new Subscription();
	                    subscription._subscriptions = [tmp];
	                }
	                break;
	            default:
	                throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');
	        }
	        var subscriptions = this._subscriptions || (this._subscriptions = []);
	        subscriptions.push(subscription);
	        subscription._addParent(this);
	        return subscription;
	    };
	    /**
	     * Removes a Subscription from the internal list of subscriptions that will
	     * unsubscribe during the unsubscribe process of this Subscription.
	     * @param {Subscription} subscription The subscription to remove.
	     * @return {void}
	     */
	    Subscription.prototype.remove = function (subscription) {
	        var subscriptions = this._subscriptions;
	        if (subscriptions) {
	            var subscriptionIndex = subscriptions.indexOf(subscription);
	            if (subscriptionIndex !== -1) {
	                subscriptions.splice(subscriptionIndex, 1);
	            }
	        }
	    };
	    Subscription.prototype._addParent = function (parent) {
	        var _a = this, _parent = _a._parent, _parents = _a._parents;
	        if (!_parent || _parent === parent) {
	            // If we don't have a parent, or the new parent is the same as the
	            // current parent, then set this._parent to the new parent.
	            this._parent = parent;
	        }
	        else if (!_parents) {
	            // If there's already one parent, but not multiple, allocate an Array to
	            // store the rest of the parent Subscriptions.
	            this._parents = [parent];
	        }
	        else if (_parents.indexOf(parent) === -1) {
	            // Only add the new parent to the _parents list if it's not already there.
	            _parents.push(parent);
	        }
	    };
	    Subscription.EMPTY = (function (empty) {
	        empty.closed = true;
	        return empty;
	    }(new Subscription()));
	    return Subscription;
	}());
	var Subscription_2 = Subscription$1;
	function flattenUnsubscriptionErrors(errors) {
	    return errors.reduce(function (errs, err) { return errs.concat((err instanceof UnsubscriptionError_1$1.UnsubscriptionError) ? err.errors : err); }, []);
	}


	var Subscription_1$3 = {
		Subscription: Subscription_2
	};

	var empty = {
	    closed: true,
	    next: function (value) { },
	    error: function (err) { throw err; },
	    complete: function () { }
	};


	var Observer$1 = {
		empty: empty
	};

	var rxSubscriber = createCommonjsModule(function (module, exports) {
	"use strict";
	var root_1 = root$1;
	var Symbol = root_1.root.Symbol;
	exports.rxSubscriber = (typeof Symbol === 'function' && typeof Symbol.for === 'function') ?
	    Symbol.for('rxSubscriber') : '@@rxSubscriber';
	/**
	 * @deprecated use rxSubscriber instead
	 */
	exports.$$rxSubscriber = exports.rxSubscriber;

	});

	var __extends$2 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var isFunction_1$1 = isFunction_1$2;
	var Subscription_1$2 = Subscription_1$3;
	var Observer_1$1 = Observer$1;
	var rxSubscriber_1$3 = rxSubscriber;
	/**
	 * Implements the {@link Observer} interface and extends the
	 * {@link Subscription} class. While the {@link Observer} is the public API for
	 * consuming the values of an {@link Observable}, all Observers get converted to
	 * a Subscriber, in order to provide Subscription-like capabilities such as
	 * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for
	 * implementing operators, but it is rarely used as a public API.
	 *
	 * @class Subscriber<T>
	 */
	var Subscriber$1 = (function (_super) {
	    __extends$2(Subscriber, _super);
	    /**
	     * @param {Observer|function(value: T): void} [destinationOrNext] A partially
	     * defined Observer or a `next` callback function.
	     * @param {function(e: ?any): void} [error] The `error` callback of an
	     * Observer.
	     * @param {function(): void} [complete] The `complete` callback of an
	     * Observer.
	     */
	    function Subscriber(destinationOrNext, error, complete) {
	        _super.call(this);
	        this.syncErrorValue = null;
	        this.syncErrorThrown = false;
	        this.syncErrorThrowable = false;
	        this.isStopped = false;
	        switch (arguments.length) {
	            case 0:
	                this.destination = Observer_1$1.empty;
	                break;
	            case 1:
	                if (!destinationOrNext) {
	                    this.destination = Observer_1$1.empty;
	                    break;
	                }
	                if (typeof destinationOrNext === 'object') {
	                    if (destinationOrNext instanceof Subscriber) {
	                        this.destination = destinationOrNext;
	                        this.destination.add(this);
	                    }
	                    else {
	                        this.syncErrorThrowable = true;
	                        this.destination = new SafeSubscriber(this, destinationOrNext);
	                    }
	                    break;
	                }
	            default:
	                this.syncErrorThrowable = true;
	                this.destination = new SafeSubscriber(this, destinationOrNext, error, complete);
	                break;
	        }
	    }
	    Subscriber.prototype[rxSubscriber_1$3.rxSubscriber] = function () { return this; };
	    /**
	     * A static factory for a Subscriber, given a (potentially partial) definition
	     * of an Observer.
	     * @param {function(x: ?T): void} [next] The `next` callback of an Observer.
	     * @param {function(e: ?any): void} [error] The `error` callback of an
	     * Observer.
	     * @param {function(): void} [complete] The `complete` callback of an
	     * Observer.
	     * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)
	     * Observer represented by the given arguments.
	     */
	    Subscriber.create = function (next, error, complete) {
	        var subscriber = new Subscriber(next, error, complete);
	        subscriber.syncErrorThrowable = false;
	        return subscriber;
	    };
	    /**
	     * The {@link Observer} callback to receive notifications of type `next` from
	     * the Observable, with a value. The Observable may call this method 0 or more
	     * times.
	     * @param {T} [value] The `next` value.
	     * @return {void}
	     */
	    Subscriber.prototype.next = function (value) {
	        if (!this.isStopped) {
	            this._next(value);
	        }
	    };
	    /**
	     * The {@link Observer} callback to receive notifications of type `error` from
	     * the Observable, with an attached {@link Error}. Notifies the Observer that
	     * the Observable has experienced an error condition.
	     * @param {any} [err] The `error` exception.
	     * @return {void}
	     */
	    Subscriber.prototype.error = function (err) {
	        if (!this.isStopped) {
	            this.isStopped = true;
	            this._error(err);
	        }
	    };
	    /**
	     * The {@link Observer} callback to receive a valueless notification of type
	     * `complete` from the Observable. Notifies the Observer that the Observable
	     * has finished sending push-based notifications.
	     * @return {void}
	     */
	    Subscriber.prototype.complete = function () {
	        if (!this.isStopped) {
	            this.isStopped = true;
	            this._complete();
	        }
	    };
	    Subscriber.prototype.unsubscribe = function () {
	        if (this.closed) {
	            return;
	        }
	        this.isStopped = true;
	        _super.prototype.unsubscribe.call(this);
	    };
	    Subscriber.prototype._next = function (value) {
	        this.destination.next(value);
	    };
	    Subscriber.prototype._error = function (err) {
	        this.destination.error(err);
	        this.unsubscribe();
	    };
	    Subscriber.prototype._complete = function () {
	        this.destination.complete();
	        this.unsubscribe();
	    };
	    Subscriber.prototype._unsubscribeAndRecycle = function () {
	        var _a = this, _parent = _a._parent, _parents = _a._parents;
	        this._parent = null;
	        this._parents = null;
	        this.unsubscribe();
	        this.closed = false;
	        this.isStopped = false;
	        this._parent = _parent;
	        this._parents = _parents;
	        return this;
	    };
	    return Subscriber;
	}(Subscription_1$2.Subscription));
	var Subscriber_2 = Subscriber$1;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var SafeSubscriber = (function (_super) {
	    __extends$2(SafeSubscriber, _super);
	    function SafeSubscriber(_parentSubscriber, observerOrNext, error, complete) {
	        _super.call(this);
	        this._parentSubscriber = _parentSubscriber;
	        var next;
	        var context = this;
	        if (isFunction_1$1.isFunction(observerOrNext)) {
	            next = observerOrNext;
	        }
	        else if (observerOrNext) {
	            next = observerOrNext.next;
	            error = observerOrNext.error;
	            complete = observerOrNext.complete;
	            if (observerOrNext !== Observer_1$1.empty) {
	                context = Object.create(observerOrNext);
	                if (isFunction_1$1.isFunction(context.unsubscribe)) {
	                    this.add(context.unsubscribe.bind(context));
	                }
	                context.unsubscribe = this.unsubscribe.bind(this);
	            }
	        }
	        this._context = context;
	        this._next = next;
	        this._error = error;
	        this._complete = complete;
	    }
	    SafeSubscriber.prototype.next = function (value) {
	        if (!this.isStopped && this._next) {
	            var _parentSubscriber = this._parentSubscriber;
	            if (!_parentSubscriber.syncErrorThrowable) {
	                this.__tryOrUnsub(this._next, value);
	            }
	            else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {
	                this.unsubscribe();
	            }
	        }
	    };
	    SafeSubscriber.prototype.error = function (err) {
	        if (!this.isStopped) {
	            var _parentSubscriber = this._parentSubscriber;
	            if (this._error) {
	                if (!_parentSubscriber.syncErrorThrowable) {
	                    this.__tryOrUnsub(this._error, err);
	                    this.unsubscribe();
	                }
	                else {
	                    this.__tryOrSetError(_parentSubscriber, this._error, err);
	                    this.unsubscribe();
	                }
	            }
	            else if (!_parentSubscriber.syncErrorThrowable) {
	                this.unsubscribe();
	                throw err;
	            }
	            else {
	                _parentSubscriber.syncErrorValue = err;
	                _parentSubscriber.syncErrorThrown = true;
	                this.unsubscribe();
	            }
	        }
	    };
	    SafeSubscriber.prototype.complete = function () {
	        var _this = this;
	        if (!this.isStopped) {
	            var _parentSubscriber = this._parentSubscriber;
	            if (this._complete) {
	                var wrappedComplete = function () { return _this._complete.call(_this._context); };
	                if (!_parentSubscriber.syncErrorThrowable) {
	                    this.__tryOrUnsub(wrappedComplete);
	                    this.unsubscribe();
	                }
	                else {
	                    this.__tryOrSetError(_parentSubscriber, wrappedComplete);
	                    this.unsubscribe();
	                }
	            }
	            else {
	                this.unsubscribe();
	            }
	        }
	    };
	    SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {
	        try {
	            fn.call(this._context, value);
	        }
	        catch (err) {
	            this.unsubscribe();
	            throw err;
	        }
	    };
	    SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {
	        try {
	            fn.call(this._context, value);
	        }
	        catch (err) {
	            parent.syncErrorValue = err;
	            parent.syncErrorThrown = true;
	            return true;
	        }
	        return false;
	    };
	    SafeSubscriber.prototype._unsubscribe = function () {
	        var _parentSubscriber = this._parentSubscriber;
	        this._context = null;
	        this._parentSubscriber = null;
	        _parentSubscriber.unsubscribe();
	    };
	    return SafeSubscriber;
	}(Subscriber$1));


	var Subscriber_1$3 = {
		Subscriber: Subscriber_2
	};

	var Subscriber_1$2 = Subscriber_1$3;
	var rxSubscriber_1$2 = rxSubscriber;
	var Observer_1 = Observer$1;
	function toSubscriber(nextOrObserver, error, complete) {
	    if (nextOrObserver) {
	        if (nextOrObserver instanceof Subscriber_1$2.Subscriber) {
	            return nextOrObserver;
	        }
	        if (nextOrObserver[rxSubscriber_1$2.rxSubscriber]) {
	            return nextOrObserver[rxSubscriber_1$2.rxSubscriber]();
	        }
	    }
	    if (!nextOrObserver && !error && !complete) {
	        return new Subscriber_1$2.Subscriber(Observer_1.empty);
	    }
	    return new Subscriber_1$2.Subscriber(nextOrObserver, error, complete);
	}
	var toSubscriber_2 = toSubscriber;


	var toSubscriber_1$1 = {
		toSubscriber: toSubscriber_2
	};

	var observable = createCommonjsModule(function (module, exports) {
	"use strict";
	var root_1 = root$1;
	function getSymbolObservable(context) {
	    var $$observable;
	    var Symbol = context.Symbol;
	    if (typeof Symbol === 'function') {
	        if (Symbol.observable) {
	            $$observable = Symbol.observable;
	        }
	        else {
	            $$observable = Symbol('observable');
	            Symbol.observable = $$observable;
	        }
	    }
	    else {
	        $$observable = '@@observable';
	    }
	    return $$observable;
	}
	exports.getSymbolObservable = getSymbolObservable;
	exports.observable = getSymbolObservable(root_1.root);
	/**
	 * @deprecated use observable instead
	 */
	exports.$$observable = exports.observable;

	});

	var root_1 = root$1;
	var toSubscriber_1 = toSubscriber_1$1;
	var observable_1$1 = observable;
	/**
	 * A representation of any set of values over any amount of time. This the most basic building block
	 * of RxJS.
	 *
	 * @class Observable<T>
	 */
	var Observable$1 = (function () {
	    /**
	     * @constructor
	     * @param {Function} subscribe the function that is  called when the Observable is
	     * initially subscribed to. This function is given a Subscriber, to which new values
	     * can be `next`ed, or an `error` method can be called to raise an error, or
	     * `complete` can be called to notify of a successful completion.
	     */
	    function Observable(subscribe) {
	        this._isScalar = false;
	        if (subscribe) {
	            this._subscribe = subscribe;
	        }
	    }
	    /**
	     * Creates a new Observable, with this Observable as the source, and the passed
	     * operator defined as the new observable's operator.
	     * @method lift
	     * @param {Operator} operator the operator defining the operation to take on the observable
	     * @return {Observable} a new observable with the Operator applied
	     */
	    Observable.prototype.lift = function (operator) {
	        var observable$$1 = new Observable();
	        observable$$1.source = this;
	        observable$$1.operator = operator;
	        return observable$$1;
	    };
	    Observable.prototype.subscribe = function (observerOrNext, error, complete) {
	        var operator = this.operator;
	        var sink = toSubscriber_1.toSubscriber(observerOrNext, error, complete);
	        if (operator) {
	            operator.call(sink, this.source);
	        }
	        else {
	            sink.add(this._trySubscribe(sink));
	        }
	        if (sink.syncErrorThrowable) {
	            sink.syncErrorThrowable = false;
	            if (sink.syncErrorThrown) {
	                throw sink.syncErrorValue;
	            }
	        }
	        return sink;
	    };
	    Observable.prototype._trySubscribe = function (sink) {
	        try {
	            return this._subscribe(sink);
	        }
	        catch (err) {
	            sink.syncErrorThrown = true;
	            sink.syncErrorValue = err;
	            sink.error(err);
	        }
	    };
	    /**
	     * @method forEach
	     * @param {Function} next a handler for each value emitted by the observable
	     * @param {PromiseConstructor} [PromiseCtor] a constructor function used to instantiate the Promise
	     * @return {Promise} a promise that either resolves on observable completion or
	     *  rejects with the handled error
	     */
	    Observable.prototype.forEach = function (next, PromiseCtor) {
	        var _this = this;
	        if (!PromiseCtor) {
	            if (root_1.root.Rx && root_1.root.Rx.config && root_1.root.Rx.config.Promise) {
	                PromiseCtor = root_1.root.Rx.config.Promise;
	            }
	            else if (root_1.root.Promise) {
	                PromiseCtor = root_1.root.Promise;
	            }
	        }
	        if (!PromiseCtor) {
	            throw new Error('no Promise impl found');
	        }
	        return new PromiseCtor(function (resolve, reject) {
	            // Must be declared in a separate statement to avoid a RefernceError when
	            // accessing subscription below in the closure due to Temporal Dead Zone.
	            var subscription;
	            subscription = _this.subscribe(function (value) {
	                if (subscription) {
	                    // if there is a subscription, then we can surmise
	                    // the next handling is asynchronous. Any errors thrown
	                    // need to be rejected explicitly and unsubscribe must be
	                    // called manually
	                    try {
	                        next(value);
	                    }
	                    catch (err) {
	                        reject(err);
	                        subscription.unsubscribe();
	                    }
	                }
	                else {
	                    // if there is NO subscription, then we're getting a nexted
	                    // value synchronously during subscription. We can just call it.
	                    // If it errors, Observable's `subscribe` will ensure the
	                    // unsubscription logic is called, then synchronously rethrow the error.
	                    // After that, Promise will trap the error and send it
	                    // down the rejection path.
	                    next(value);
	                }
	            }, reject, resolve);
	        });
	    };
	    Observable.prototype._subscribe = function (subscriber) {
	        return this.source.subscribe(subscriber);
	    };
	    /**
	     * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable
	     * @method Symbol.observable
	     * @return {Observable} this instance of the observable
	     */
	    Observable.prototype[observable_1$1.observable] = function () {
	        return this;
	    };
	    // HACK: Since TypeScript inherits static properties too, we have to
	    // fight against TypeScript here so Subject can have a different static create signature
	    /**
	     * Creates a new cold Observable by calling the Observable constructor
	     * @static true
	     * @owner Observable
	     * @method create
	     * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor
	     * @return {Observable} a new cold observable
	     */
	    Observable.create = function (subscribe) {
	        return new Observable(subscribe);
	    };
	    return Observable;
	}());
	var Observable_2 = Observable$1;


	var Observable_1$2 = {
		Observable: Observable_2
	};

	var __extends$4 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/**
	 * An error thrown when an action is invalid because the object has been
	 * unsubscribed.
	 *
	 * @see {@link Subject}
	 * @see {@link BehaviorSubject}
	 *
	 * @class ObjectUnsubscribedError
	 */
	var ObjectUnsubscribedError$1 = (function (_super) {
	    __extends$4(ObjectUnsubscribedError, _super);
	    function ObjectUnsubscribedError() {
	        var err = _super.call(this, 'object unsubscribed');
	        this.name = err.name = 'ObjectUnsubscribedError';
	        this.stack = err.stack;
	        this.message = err.message;
	    }
	    return ObjectUnsubscribedError;
	}(Error));
	var ObjectUnsubscribedError_2 = ObjectUnsubscribedError$1;


	var ObjectUnsubscribedError_1$2 = {
		ObjectUnsubscribedError: ObjectUnsubscribedError_2
	};

	var __extends$5 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscription_1$5 = Subscription_1$3;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var SubjectSubscription = (function (_super) {
	    __extends$5(SubjectSubscription, _super);
	    function SubjectSubscription(subject, subscriber) {
	        _super.call(this);
	        this.subject = subject;
	        this.subscriber = subscriber;
	        this.closed = false;
	    }
	    SubjectSubscription.prototype.unsubscribe = function () {
	        if (this.closed) {
	            return;
	        }
	        this.closed = true;
	        var subject = this.subject;
	        var observers = subject.observers;
	        this.subject = null;
	        if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {
	            return;
	        }
	        var subscriberIndex = observers.indexOf(this.subscriber);
	        if (subscriberIndex !== -1) {
	            observers.splice(subscriberIndex, 1);
	        }
	    };
	    return SubjectSubscription;
	}(Subscription_1$5.Subscription));
	var SubjectSubscription_2 = SubjectSubscription;


	var SubjectSubscription_1$1 = {
		SubjectSubscription: SubjectSubscription_2
	};

	var __extends$1 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Observable_1$1 = Observable_1$2;
	var Subscriber_1$1 = Subscriber_1$3;
	var Subscription_1$1 = Subscription_1$3;
	var ObjectUnsubscribedError_1$1 = ObjectUnsubscribedError_1$2;
	var SubjectSubscription_1 = SubjectSubscription_1$1;
	var rxSubscriber_1$1 = rxSubscriber;
	/**
	 * @class SubjectSubscriber<T>
	 */
	var SubjectSubscriber = (function (_super) {
	    __extends$1(SubjectSubscriber, _super);
	    function SubjectSubscriber(destination) {
	        _super.call(this, destination);
	        this.destination = destination;
	    }
	    return SubjectSubscriber;
	}(Subscriber_1$1.Subscriber));
	var SubjectSubscriber_1 = SubjectSubscriber;
	/**
	 * @class Subject<T>
	 */
	var Subject$2 = (function (_super) {
	    __extends$1(Subject, _super);
	    function Subject() {
	        _super.call(this);
	        this.observers = [];
	        this.closed = false;
	        this.isStopped = false;
	        this.hasError = false;
	        this.thrownError = null;
	    }
	    Subject.prototype[rxSubscriber_1$1.rxSubscriber] = function () {
	        return new SubjectSubscriber(this);
	    };
	    Subject.prototype.lift = function (operator) {
	        var subject = new AnonymousSubject$1(this, this);
	        subject.operator = operator;
	        return subject;
	    };
	    Subject.prototype.next = function (value) {
	        if (this.closed) {
	            throw new ObjectUnsubscribedError_1$1.ObjectUnsubscribedError();
	        }
	        if (!this.isStopped) {
	            var observers = this.observers;
	            var len = observers.length;
	            var copy = observers.slice();
	            for (var i = 0; i < len; i++) {
	                copy[i].next(value);
	            }
	        }
	    };
	    Subject.prototype.error = function (err) {
	        if (this.closed) {
	            throw new ObjectUnsubscribedError_1$1.ObjectUnsubscribedError();
	        }
	        this.hasError = true;
	        this.thrownError = err;
	        this.isStopped = true;
	        var observers = this.observers;
	        var len = observers.length;
	        var copy = observers.slice();
	        for (var i = 0; i < len; i++) {
	            copy[i].error(err);
	        }
	        this.observers.length = 0;
	    };
	    Subject.prototype.complete = function () {
	        if (this.closed) {
	            throw new ObjectUnsubscribedError_1$1.ObjectUnsubscribedError();
	        }
	        this.isStopped = true;
	        var observers = this.observers;
	        var len = observers.length;
	        var copy = observers.slice();
	        for (var i = 0; i < len; i++) {
	            copy[i].complete();
	        }
	        this.observers.length = 0;
	    };
	    Subject.prototype.unsubscribe = function () {
	        this.isStopped = true;
	        this.closed = true;
	        this.observers = null;
	    };
	    Subject.prototype._trySubscribe = function (subscriber) {
	        if (this.closed) {
	            throw new ObjectUnsubscribedError_1$1.ObjectUnsubscribedError();
	        }
	        else {
	            return _super.prototype._trySubscribe.call(this, subscriber);
	        }
	    };
	    Subject.prototype._subscribe = function (subscriber) {
	        if (this.closed) {
	            throw new ObjectUnsubscribedError_1$1.ObjectUnsubscribedError();
	        }
	        else if (this.hasError) {
	            subscriber.error(this.thrownError);
	            return Subscription_1$1.Subscription.EMPTY;
	        }
	        else if (this.isStopped) {
	            subscriber.complete();
	            return Subscription_1$1.Subscription.EMPTY;
	        }
	        else {
	            this.observers.push(subscriber);
	            return new SubjectSubscription_1.SubjectSubscription(this, subscriber);
	        }
	    };
	    Subject.prototype.asObservable = function () {
	        var observable = new Observable_1$1.Observable();
	        observable.source = this;
	        return observable;
	    };
	    Subject.create = function (destination, source) {
	        return new AnonymousSubject$1(destination, source);
	    };
	    return Subject;
	}(Observable_1$1.Observable));
	var Subject_2 = Subject$2;
	/**
	 * @class AnonymousSubject<T>
	 */
	var AnonymousSubject$1 = (function (_super) {
	    __extends$1(AnonymousSubject, _super);
	    function AnonymousSubject(destination, source) {
	        _super.call(this);
	        this.destination = destination;
	        this.source = source;
	    }
	    AnonymousSubject.prototype.next = function (value) {
	        var destination = this.destination;
	        if (destination && destination.next) {
	            destination.next(value);
	        }
	    };
	    AnonymousSubject.prototype.error = function (err) {
	        var destination = this.destination;
	        if (destination && destination.error) {
	            this.destination.error(err);
	        }
	    };
	    AnonymousSubject.prototype.complete = function () {
	        var destination = this.destination;
	        if (destination && destination.complete) {
	            this.destination.complete();
	        }
	    };
	    AnonymousSubject.prototype._subscribe = function (subscriber) {
	        var source = this.source;
	        if (source) {
	            return this.source.subscribe(subscriber);
	        }
	        else {
	            return Subscription_1$1.Subscription.EMPTY;
	        }
	    };
	    return AnonymousSubject;
	}(Subject$2));
	var AnonymousSubject_1 = AnonymousSubject$1;


	var Subject_1$1 = {
		SubjectSubscriber: SubjectSubscriber_1,
		Subject: Subject_2,
		AnonymousSubject: AnonymousSubject_1
	};

	var __extends$7 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subject_1$3 = Subject_1$1;
	var Subscription_1$6 = Subscription_1$3;
	/**
	 * @class AsyncSubject<T>
	 */
	var AsyncSubject$1 = (function (_super) {
	    __extends$7(AsyncSubject, _super);
	    function AsyncSubject() {
	        _super.apply(this, arguments);
	        this.value = null;
	        this.hasNext = false;
	        this.hasCompleted = false;
	    }
	    AsyncSubject.prototype._subscribe = function (subscriber) {
	        if (this.hasError) {
	            subscriber.error(this.thrownError);
	            return Subscription_1$6.Subscription.EMPTY;
	        }
	        else if (this.hasCompleted && this.hasNext) {
	            subscriber.next(this.value);
	            subscriber.complete();
	            return Subscription_1$6.Subscription.EMPTY;
	        }
	        return _super.prototype._subscribe.call(this, subscriber);
	    };
	    AsyncSubject.prototype.next = function (value) {
	        if (!this.hasCompleted) {
	            this.value = value;
	            this.hasNext = true;
	        }
	    };
	    AsyncSubject.prototype.error = function (error) {
	        if (!this.hasCompleted) {
	            _super.prototype.error.call(this, error);
	        }
	    };
	    AsyncSubject.prototype.complete = function () {
	        this.hasCompleted = true;
	        if (this.hasNext) {
	            _super.prototype.next.call(this, this.value);
	        }
	        _super.prototype.complete.call(this);
	    };
	    return AsyncSubject;
	}(Subject_1$3.Subject));
	var AsyncSubject_2 = AsyncSubject$1;


	var AsyncSubject_1$2 = {
		AsyncSubject: AsyncSubject_2
	};

	var __extends$6 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Observable_1$5 = Observable_1$2;
	var tryCatch_1$3 = tryCatch_1$1;
	var errorObject_1$3 = errorObject;
	var AsyncSubject_1$1 = AsyncSubject_1$2;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var BoundCallbackObservable = (function (_super) {
	    __extends$6(BoundCallbackObservable, _super);
	    function BoundCallbackObservable(callbackFunc, selector, args, context, scheduler) {
	        _super.call(this);
	        this.callbackFunc = callbackFunc;
	        this.selector = selector;
	        this.args = args;
	        this.context = context;
	        this.scheduler = scheduler;
	    }
	    /* tslint:enable:max-line-length */
	    /**
	     * Converts a callback API to a function that returns an Observable.
	     *
	     * <span class="informal">Give it a function `f` of type `f(x, callback)` and
	     * it will return a function `g` that when called as `g(x)` will output an
	     * Observable.</span>
	     *
	     * `bindCallback` is not an operator because its input and output are not
	     * Observables. The input is a function `func` with some parameters, but the
	     * last parameter must be a callback function that `func` calls when it is
	     * done.
	     *
	     * The output of `bindCallback` is a function that takes the same parameters
	     * as `func`, except the last one (the callback). When the output function
	     * is called with arguments, it will return an Observable. If `func` function
	     * calls its callback with one argument, the Observable will emit that value.
	     * If on the other hand callback is called with multiple values, resulting
	     * Observable will emit an array with these arguments.
	     *
	     * It is very important to remember, that input function `func` is not called
	     * when output function is, but rather when Observable returned by output
	     * function is subscribed. This means if `func` makes AJAX request, that request
	     * will be made every time someone subscribes to resulting Observable, but not before.
	     *
	     * Optionally, selector function can be passed to `bindObservable`. That function
	     * takes the same arguments as callback, and returns value
	     * that will be emitted by Observable instead of callback parameters themselves.
	     * Even though by default multiple arguments passed to callback appear in the stream as array,
	     * selector function will be called with arguments directly, just as callback would.
	     * This means you can imagine default selector (when one is not provided explicitly)
	     * as function that aggregates all its arguments into array, or simply returns first argument,
	     * if there is only one.
	     *
	     * Last optional parameter - {@link Scheduler} - can be used to control when call
	     * to `func` happens after someone subscribes to Observable, as well as when results
	     * passed to callback will be emitted. By default subscription to Observable calls `func`
	     * synchronously, but using `Scheduler.async` as last parameter will defer call to input function,
	     * just like wrapping that call in `setTimeout` with time `0` would. So if you use async Scheduler
	     * and call `subscribe` on output Observable, all function calls that are currently executing,
	     * will end before `func` is invoked.
	     *
	     * When it comes to emitting results passed to callback, by default they are emitted
	     * immediately after `func` invokes callback. In particular, if callback is called synchronously,
	     * then subscription to resulting Observable will call `next` function synchronously as well.
	     * If you want to defer that call, using `Scheduler.async` will, again, do the job.
	     * This means that by using `Scheduler.async` you can, in a sense, ensure that `func`
	     * always calls its callback asynchronously, thus avoiding terrifying Zalgo.
	     *
	     * Note that Observable created by output function will always emit only one value
	     * and then complete right after. Even if `func` calls callback multiple times, values from
	     * second and following calls will never appear in the stream. If you need to
	     * listen for multiple calls, you probably want to use {@link fromEvent} or
	     * {@link fromEventPattern} instead.
	     *
	     * If `func` depends on some context (`this` property), that context will be set
	     * to the same context that output function has at call time. In particular, if `func`
	     * is called as method of some object, in order to preserve proper behaviour,
	     * it is recommended to set context of output function to that object as well,
	     * provided `func` is not already bound.
	     *
	     * If input function calls its callback in "node style" (i.e. first argument to callback is
	     * optional error parameter signaling whether call failed or not), {@link bindNodeCallback}
	     * provides convenient error handling and probably is a better choice.
	     * `bindCallback` will treat such functions without any difference and error parameter
	     * (whether passed or not) will always be interpreted as regular callback argument.
	     *
	     *
	     * @example <caption>Convert jQuery's getJSON to an Observable API</caption>
	     * // Suppose we have jQuery.getJSON('/my/url', callback)
	     * var getJSONAsObservable = Rx.Observable.bindCallback(jQuery.getJSON);
	     * var result = getJSONAsObservable('/my/url');
	     * result.subscribe(x => console.log(x), e => console.error(e));
	     *
	     *
	     * @example <caption>Receive array of arguments passed to callback</caption>
	     * someFunction((a, b, c) => {
	     *   console.log(a); // 5
	     *   console.log(b); // 'some string'
	     *   console.log(c); // {someProperty: 'someValue'}
	     * });
	     *
	     * const boundSomeFunction = Rx.Observable.bindCallback(someFunction);
	     * boundSomeFunction().subscribe(values => {
	     *   console.log(values) // [5, 'some string', {someProperty: 'someValue'}]
	     * });
	     *
	     *
	     * @example <caption>Use bindCallback with selector function</caption>
	     * someFunction((a, b, c) => {
	     *   console.log(a); // 'a'
	     *   console.log(b); // 'b'
	     *   console.log(c); // 'c'
	     * });
	     *
	     * const boundSomeFunction = Rx.Observable.bindCallback(someFunction, (a, b, c) => a + b + c);
	     * boundSomeFunction().subscribe(value => {
	     *   console.log(value) // 'abc'
	     * });
	     *
	     *
	     * @example <caption>Compare behaviour with and without async Scheduler</caption>
	     * function iCallMyCallbackSynchronously(cb) {
	     *   cb();
	     * }
	     *
	     * const boundSyncFn = Rx.Observable.bindCallback(iCallMyCallbackSynchronously);
	     * const boundAsyncFn = Rx.Observable.bindCallback(iCallMyCallbackSynchronously, null, Rx.Scheduler.async);
	     *
	     * boundSyncFn().subscribe(() => console.log('I was sync!'));
	     * boundAsyncFn().subscribe(() => console.log('I was async!'));
	     * console.log('This happened...');
	     *
	     * // Logs:
	     * // I was sync!
	     * // This happened...
	     * // I was async!
	     *
	     *
	     * @example <caption>Use bindCallback on object method</caption>
	     * const boundMethod = Rx.Observable.bindCallback(someObject.methodWithCallback);
	     * boundMethod.call(someObject) // make sure methodWithCallback has access to someObject
	     * .subscribe(subscriber);
	     *
	     *
	     * @see {@link bindNodeCallback}
	     * @see {@link from}
	     * @see {@link fromPromise}
	     *
	     * @param {function} func Function with a callback as the last parameter.
	     * @param {function} [selector] A function which takes the arguments from the
	     * callback and maps those to a value to emit on the output Observable.
	     * @param {Scheduler} [scheduler] The scheduler on which to schedule the
	     * callbacks.
	     * @return {function(...params: *): Observable} A function which returns the
	     * Observable that delivers the same values the callback would deliver.
	     * @static true
	     * @name bindCallback
	     * @owner Observable
	     */
	    BoundCallbackObservable.create = function (func, selector, scheduler) {
	        if (selector === void 0) { selector = undefined; }
	        return function () {
	            var args = [];
	            for (var _i = 0; _i < arguments.length; _i++) {
	                args[_i - 0] = arguments[_i];
	            }
	            return new BoundCallbackObservable(func, selector, args, this, scheduler);
	        };
	    };
	    BoundCallbackObservable.prototype._subscribe = function (subscriber) {
	        var callbackFunc = this.callbackFunc;
	        var args = this.args;
	        var scheduler = this.scheduler;
	        var subject = this.subject;
	        if (!scheduler) {
	            if (!subject) {
	                subject = this.subject = new AsyncSubject_1$1.AsyncSubject();
	                var handler = function handlerFn() {
	                    var innerArgs = [];
	                    for (var _i = 0; _i < arguments.length; _i++) {
	                        innerArgs[_i - 0] = arguments[_i];
	                    }
	                    var source = handlerFn.source;
	                    var selector = source.selector, subject = source.subject;
	                    if (selector) {
	                        var result_1 = tryCatch_1$3.tryCatch(selector).apply(this, innerArgs);
	                        if (result_1 === errorObject_1$3.errorObject) {
	                            subject.error(errorObject_1$3.errorObject.e);
	                        }
	                        else {
	                            subject.next(result_1);
	                            subject.complete();
	                        }
	                    }
	                    else {
	                        subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);
	                        subject.complete();
	                    }
	                };
	                // use named function instance to avoid closure.
	                handler.source = this;
	                var result = tryCatch_1$3.tryCatch(callbackFunc).apply(this.context, args.concat(handler));
	                if (result === errorObject_1$3.errorObject) {
	                    subject.error(errorObject_1$3.errorObject.e);
	                }
	            }
	            return subject.subscribe(subscriber);
	        }
	        else {
	            return scheduler.schedule(BoundCallbackObservable.dispatch, 0, { source: this, subscriber: subscriber, context: this.context });
	        }
	    };
	    BoundCallbackObservable.dispatch = function (state) {
	        var self = this;
	        var source = state.source, subscriber = state.subscriber, context = state.context;
	        var callbackFunc = source.callbackFunc, args = source.args, scheduler = source.scheduler;
	        var subject = source.subject;
	        if (!subject) {
	            subject = source.subject = new AsyncSubject_1$1.AsyncSubject();
	            var handler = function handlerFn() {
	                var innerArgs = [];
	                for (var _i = 0; _i < arguments.length; _i++) {
	                    innerArgs[_i - 0] = arguments[_i];
	                }
	                var source = handlerFn.source;
	                var selector = source.selector, subject = source.subject;
	                if (selector) {
	                    var result_2 = tryCatch_1$3.tryCatch(selector).apply(this, innerArgs);
	                    if (result_2 === errorObject_1$3.errorObject) {
	                        self.add(scheduler.schedule(dispatchError, 0, { err: errorObject_1$3.errorObject.e, subject: subject }));
	                    }
	                    else {
	                        self.add(scheduler.schedule(dispatchNext, 0, { value: result_2, subject: subject }));
	                    }
	                }
	                else {
	                    var value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;
	                    self.add(scheduler.schedule(dispatchNext, 0, { value: value, subject: subject }));
	                }
	            };
	            // use named function to pass values in without closure
	            handler.source = source;
	            var result = tryCatch_1$3.tryCatch(callbackFunc).apply(context, args.concat(handler));
	            if (result === errorObject_1$3.errorObject) {
	                subject.error(errorObject_1$3.errorObject.e);
	            }
	        }
	        self.add(subject.subscribe(subscriber));
	    };
	    return BoundCallbackObservable;
	}(Observable_1$5.Observable));
	var BoundCallbackObservable_2 = BoundCallbackObservable;
	function dispatchNext(arg) {
	    var value = arg.value, subject = arg.subject;
	    subject.next(value);
	    subject.complete();
	}
	function dispatchError(arg) {
	    var err = arg.err, subject = arg.subject;
	    subject.error(err);
	}


	var BoundCallbackObservable_1$1 = {
		BoundCallbackObservable: BoundCallbackObservable_2
	};

	var BoundCallbackObservable_1 = BoundCallbackObservable_1$1;
	var bindCallback_1$1 = BoundCallbackObservable_1.BoundCallbackObservable.create;


	var bindCallback$2 = {
		bindCallback: bindCallback_1$1
	};

	var Observable_1$4 = Observable_1$2;
	var bindCallback_1 = bindCallback$2;
	Observable_1$4.Observable.bindCallback = bindCallback_1.bindCallback;

	var __extends$8 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Observable_1$7 = Observable_1$2;
	var tryCatch_1$4 = tryCatch_1$1;
	var errorObject_1$4 = errorObject;
	var AsyncSubject_1$4 = AsyncSubject_1$2;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var BoundNodeCallbackObservable = (function (_super) {
	    __extends$8(BoundNodeCallbackObservable, _super);
	    function BoundNodeCallbackObservable(callbackFunc, selector, args, context, scheduler) {
	        _super.call(this);
	        this.callbackFunc = callbackFunc;
	        this.selector = selector;
	        this.args = args;
	        this.context = context;
	        this.scheduler = scheduler;
	    }
	    /* tslint:enable:max-line-length */
	    /**
	     * Converts a Node.js-style callback API to a function that returns an
	     * Observable.
	     *
	     * <span class="informal">It's just like {@link bindCallback}, but the
	     * callback is expected to be of type `callback(error, result)`.</span>
	     *
	     * `bindNodeCallback` is not an operator because its input and output are not
	     * Observables. The input is a function `func` with some parameters, but the
	     * last parameter must be a callback function that `func` calls when it is
	     * done. The callback function is expected to follow Node.js conventions,
	     * where the first argument to the callback is an error object, signaling
	     * whether call was successful. If that object is passed to callback, it means
	     * something went wrong.
	     *
	     * The output of `bindNodeCallback` is a function that takes the same
	     * parameters as `func`, except the last one (the callback). When the output
	     * function is called with arguments, it will return an Observable.
	     * If `func` calls its callback with error parameter present, Observable will
	     * error with that value as well. If error parameter is not passed, Observable will emit
	     * second parameter. If there are more parameters (third and so on),
	     * Observable will emit an array with all arguments, except first error argument.
	     *
	     * Optionally `bindNodeCallback` accepts selector function, which allows you to
	     * make resulting Observable emit value computed by selector, instead of regular
	     * callback arguments. It works similarly to {@link bindCallback} selector, but
	     * Node.js-style error argument will never be passed to that function.
	     *
	     * Note that `func` will not be called at the same time output function is,
	     * but rather whenever resulting Observable is subscribed. By default call to
	     * `func` will happen synchronously after subscription, but that can be changed
	     * with proper {@link Scheduler} provided as optional third parameter. Scheduler
	     * can also control when values from callback will be emitted by Observable.
	     * To find out more, check out documentation for {@link bindCallback}, where
	     * Scheduler works exactly the same.
	     *
	     * As in {@link bindCallback}, context (`this` property) of input function will be set to context
	     * of returned function, when it is called.
	     *
	     * After Observable emits value, it will complete immediately. This means
	     * even if `func` calls callback again, values from second and consecutive
	     * calls will never appear on the stream. If you need to handle functions
	     * that call callbacks multiple times, check out {@link fromEvent} or
	     * {@link fromEventPattern} instead.
	     *
	     * Note that `bindNodeCallback` can be used in non-Node.js environments as well.
	     * "Node.js-style" callbacks are just a convention, so if you write for
	     * browsers or any other environment and API you use implements that callback style,
	     * `bindNodeCallback` can be safely used on that API functions as well.
	     *
	     * Remember that Error object passed to callback does not have to be an instance
	     * of JavaScript built-in `Error` object. In fact, it does not even have to an object.
	     * Error parameter of callback function is interpreted as "present", when value
	     * of that parameter is truthy. It could be, for example, non-zero number, non-empty
	     * string or boolean `true`. In all of these cases resulting Observable would error
	     * with that value. This means usually regular style callbacks will fail very often when
	     * `bindNodeCallback` is used. If your Observable errors much more often then you
	     * would expect, check if callback really is called in Node.js-style and, if not,
	     * switch to {@link bindCallback} instead.
	     *
	     * Note that even if error parameter is technically present in callback, but its value
	     * is falsy, it still won't appear in array emitted by Observable or in selector function.
	     *
	     *
	     * @example <caption>Read a file from the filesystem and get the data as an Observable</caption>
	     * import * as fs from 'fs';
	     * var readFileAsObservable = Rx.Observable.bindNodeCallback(fs.readFile);
	     * var result = readFileAsObservable('./roadNames.txt', 'utf8');
	     * result.subscribe(x => console.log(x), e => console.error(e));
	     *
	     *
	     * @example <caption>Use on function calling callback with multiple arguments</caption>
	     * someFunction((err, a, b) => {
	     *   console.log(err); // null
	     *   console.log(a); // 5
	     *   console.log(b); // "some string"
	     * });
	     * var boundSomeFunction = Rx.Observable.bindNodeCallback(someFunction);
	     * boundSomeFunction()
	     * .subscribe(value => {
	     *   console.log(value); // [5, "some string"]
	     * });
	     *
	     *
	     * @example <caption>Use with selector function</caption>
	     * someFunction((err, a, b) => {
	     *   console.log(err); // undefined
	     *   console.log(a); // "abc"
	     *   console.log(b); // "DEF"
	     * });
	     * var boundSomeFunction = Rx.Observable.bindNodeCallback(someFunction, (a, b) => a + b);
	     * boundSomeFunction()
	     * .subscribe(value => {
	     *   console.log(value); // "abcDEF"
	     * });
	     *
	     *
	     * @example <caption>Use on function calling callback in regular style</caption>
	     * someFunction(a => {
	     *   console.log(a); // 5
	     * });
	     * var boundSomeFunction = Rx.Observable.bindNodeCallback(someFunction);
	     * boundSomeFunction()
	     * .subscribe(
	     *   value => {}             // never gets called
	     *   err => console.log(err) // 5
	     *);
	     *
	     *
	     * @see {@link bindCallback}
	     * @see {@link from}
	     * @see {@link fromPromise}
	     *
	     * @param {function} func Function with a Node.js-style callback as the last parameter.
	     * @param {function} [selector] A function which takes the arguments from the
	     * callback and maps those to a value to emit on the output Observable.
	     * @param {Scheduler} [scheduler] The scheduler on which to schedule the
	     * callbacks.
	     * @return {function(...params: *): Observable} A function which returns the
	     * Observable that delivers the same values the Node.js callback would
	     * deliver.
	     * @static true
	     * @name bindNodeCallback
	     * @owner Observable
	     */
	    BoundNodeCallbackObservable.create = function (func, selector, scheduler) {
	        if (selector === void 0) { selector = undefined; }
	        return function () {
	            var args = [];
	            for (var _i = 0; _i < arguments.length; _i++) {
	                args[_i - 0] = arguments[_i];
	            }
	            return new BoundNodeCallbackObservable(func, selector, args, this, scheduler);
	        };
	    };
	    BoundNodeCallbackObservable.prototype._subscribe = function (subscriber) {
	        var callbackFunc = this.callbackFunc;
	        var args = this.args;
	        var scheduler = this.scheduler;
	        var subject = this.subject;
	        if (!scheduler) {
	            if (!subject) {
	                subject = this.subject = new AsyncSubject_1$4.AsyncSubject();
	                var handler = function handlerFn() {
	                    var innerArgs = [];
	                    for (var _i = 0; _i < arguments.length; _i++) {
	                        innerArgs[_i - 0] = arguments[_i];
	                    }
	                    var source = handlerFn.source;
	                    var selector = source.selector, subject = source.subject;
	                    var err = innerArgs.shift();
	                    if (err) {
	                        subject.error(err);
	                    }
	                    else if (selector) {
	                        var result_1 = tryCatch_1$4.tryCatch(selector).apply(this, innerArgs);
	                        if (result_1 === errorObject_1$4.errorObject) {
	                            subject.error(errorObject_1$4.errorObject.e);
	                        }
	                        else {
	                            subject.next(result_1);
	                            subject.complete();
	                        }
	                    }
	                    else {
	                        subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);
	                        subject.complete();
	                    }
	                };
	                // use named function instance to avoid closure.
	                handler.source = this;
	                var result = tryCatch_1$4.tryCatch(callbackFunc).apply(this.context, args.concat(handler));
	                if (result === errorObject_1$4.errorObject) {
	                    subject.error(errorObject_1$4.errorObject.e);
	                }
	            }
	            return subject.subscribe(subscriber);
	        }
	        else {
	            return scheduler.schedule(dispatch, 0, { source: this, subscriber: subscriber, context: this.context });
	        }
	    };
	    return BoundNodeCallbackObservable;
	}(Observable_1$7.Observable));
	var BoundNodeCallbackObservable_2 = BoundNodeCallbackObservable;
	function dispatch(state) {
	    var self = this;
	    var source = state.source, subscriber = state.subscriber, context = state.context;
	    // XXX: cast to `any` to access to the private field in `source`.
	    var _a = source, callbackFunc = _a.callbackFunc, args = _a.args, scheduler = _a.scheduler;
	    var subject = source.subject;
	    if (!subject) {
	        subject = source.subject = new AsyncSubject_1$4.AsyncSubject();
	        var handler = function handlerFn() {
	            var innerArgs = [];
	            for (var _i = 0; _i < arguments.length; _i++) {
	                innerArgs[_i - 0] = arguments[_i];
	            }
	            var source = handlerFn.source;
	            var selector = source.selector, subject = source.subject;
	            var err = innerArgs.shift();
	            if (err) {
	                self.add(scheduler.schedule(dispatchError$1, 0, { err: err, subject: subject }));
	            }
	            else if (selector) {
	                var result_2 = tryCatch_1$4.tryCatch(selector).apply(this, innerArgs);
	                if (result_2 === errorObject_1$4.errorObject) {
	                    self.add(scheduler.schedule(dispatchError$1, 0, { err: errorObject_1$4.errorObject.e, subject: subject }));
	                }
	                else {
	                    self.add(scheduler.schedule(dispatchNext$1, 0, { value: result_2, subject: subject }));
	                }
	            }
	            else {
	                var value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;
	                self.add(scheduler.schedule(dispatchNext$1, 0, { value: value, subject: subject }));
	            }
	        };
	        // use named function to pass values in without closure
	        handler.source = source;
	        var result = tryCatch_1$4.tryCatch(callbackFunc).apply(context, args.concat(handler));
	        if (result === errorObject_1$4.errorObject) {
	            self.add(scheduler.schedule(dispatchError$1, 0, { err: errorObject_1$4.errorObject.e, subject: subject }));
	        }
	    }
	    self.add(subject.subscribe(subscriber));
	}
	function dispatchNext$1(arg) {
	    var value = arg.value, subject = arg.subject;
	    subject.next(value);
	    subject.complete();
	}
	function dispatchError$1(arg) {
	    var err = arg.err, subject = arg.subject;
	    subject.error(err);
	}


	var BoundNodeCallbackObservable_1$1 = {
		BoundNodeCallbackObservable: BoundNodeCallbackObservable_2
	};

	var BoundNodeCallbackObservable_1 = BoundNodeCallbackObservable_1$1;
	var bindNodeCallback_1$1 = BoundNodeCallbackObservable_1.BoundNodeCallbackObservable.create;


	var bindNodeCallback$2 = {
		bindNodeCallback: bindNodeCallback_1$1
	};

	var Observable_1$6 = Observable_1$2;
	var bindNodeCallback_1 = bindNodeCallback$2;
	Observable_1$6.Observable.bindNodeCallback = bindNodeCallback_1.bindNodeCallback;

	function isScheduler(value) {
	    return value && typeof value.schedule === 'function';
	}
	var isScheduler_2 = isScheduler;


	var isScheduler_1$1 = {
		isScheduler: isScheduler_2
	};

	var __extends$10 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Observable_1$10 = Observable_1$2;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var ScalarObservable = (function (_super) {
	    __extends$10(ScalarObservable, _super);
	    function ScalarObservable(value, scheduler) {
	        _super.call(this);
	        this.value = value;
	        this.scheduler = scheduler;
	        this._isScalar = true;
	        if (scheduler) {
	            this._isScalar = false;
	        }
	    }
	    ScalarObservable.create = function (value, scheduler) {
	        return new ScalarObservable(value, scheduler);
	    };
	    ScalarObservable.dispatch = function (state) {
	        var done = state.done, value = state.value, subscriber = state.subscriber;
	        if (done) {
	            subscriber.complete();
	            return;
	        }
	        subscriber.next(value);
	        if (subscriber.closed) {
	            return;
	        }
	        state.done = true;
	        this.schedule(state);
	    };
	    ScalarObservable.prototype._subscribe = function (subscriber) {
	        var value = this.value;
	        var scheduler = this.scheduler;
	        if (scheduler) {
	            return scheduler.schedule(ScalarObservable.dispatch, 0, {
	                done: false, value: value, subscriber: subscriber
	            });
	        }
	        else {
	            subscriber.next(value);
	            if (!subscriber.closed) {
	                subscriber.complete();
	            }
	        }
	    };
	    return ScalarObservable;
	}(Observable_1$10.Observable));
	var ScalarObservable_2 = ScalarObservable;


	var ScalarObservable_1$1 = {
		ScalarObservable: ScalarObservable_2
	};

	var __extends$11 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Observable_1$11 = Observable_1$2;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var EmptyObservable = (function (_super) {
	    __extends$11(EmptyObservable, _super);
	    function EmptyObservable(scheduler) {
	        _super.call(this);
	        this.scheduler = scheduler;
	    }
	    /**
	     * Creates an Observable that emits no items to the Observer and immediately
	     * emits a complete notification.
	     *
	     * <span class="informal">Just emits 'complete', and nothing else.
	     * </span>
	     *
	     * <img src="./img/empty.png" width="100%">
	     *
	     * This static operator is useful for creating a simple Observable that only
	     * emits the complete notification. It can be used for composing with other
	     * Observables, such as in a {@link mergeMap}.
	     *
	     * @example <caption>Emit the number 7, then complete.</caption>
	     * var result = Rx.Observable.empty().startWith(7);
	     * result.subscribe(x => console.log(x));
	     *
	     * @example <caption>Map and flatten only odd numbers to the sequence 'a', 'b', 'c'</caption>
	     * var interval = Rx.Observable.interval(1000);
	     * var result = interval.mergeMap(x =>
	     *   x % 2 === 1 ? Rx.Observable.of('a', 'b', 'c') : Rx.Observable.empty()
	     * );
	     * result.subscribe(x => console.log(x));
	     *
	     * // Results in the following to the console:
	     * // x is equal to the count on the interval eg(0,1,2,3,...)
	     * // x will occur every 1000ms
	     * // if x % 2 is equal to 1 print abc
	     * // if x % 2 is not equal to 1 nothing will be output
	     *
	     * @see {@link create}
	     * @see {@link never}
	     * @see {@link of}
	     * @see {@link throw}
	     *
	     * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling
	     * the emission of the complete notification.
	     * @return {Observable} An "empty" Observable: emits only the complete
	     * notification.
	     * @static true
	     * @name empty
	     * @owner Observable
	     */
	    EmptyObservable.create = function (scheduler) {
	        return new EmptyObservable(scheduler);
	    };
	    EmptyObservable.dispatch = function (arg) {
	        var subscriber = arg.subscriber;
	        subscriber.complete();
	    };
	    EmptyObservable.prototype._subscribe = function (subscriber) {
	        var scheduler = this.scheduler;
	        if (scheduler) {
	            return scheduler.schedule(EmptyObservable.dispatch, 0, { subscriber: subscriber });
	        }
	        else {
	            subscriber.complete();
	        }
	    };
	    return EmptyObservable;
	}(Observable_1$11.Observable));
	var EmptyObservable_2 = EmptyObservable;


	var EmptyObservable_1$1 = {
		EmptyObservable: EmptyObservable_2
	};

	var __extends$9 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Observable_1$9 = Observable_1$2;
	var ScalarObservable_1 = ScalarObservable_1$1;
	var EmptyObservable_1 = EmptyObservable_1$1;
	var isScheduler_1$3 = isScheduler_1$1;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var ArrayObservable = (function (_super) {
	    __extends$9(ArrayObservable, _super);
	    function ArrayObservable(array, scheduler) {
	        _super.call(this);
	        this.array = array;
	        this.scheduler = scheduler;
	        if (!scheduler && array.length === 1) {
	            this._isScalar = true;
	            this.value = array[0];
	        }
	    }
	    ArrayObservable.create = function (array, scheduler) {
	        return new ArrayObservable(array, scheduler);
	    };
	    /**
	     * Creates an Observable that emits some values you specify as arguments,
	     * immediately one after the other, and then emits a complete notification.
	     *
	     * <span class="informal">Emits the arguments you provide, then completes.
	     * </span>
	     *
	     * <img src="./img/of.png" width="100%">
	     *
	     * This static operator is useful for creating a simple Observable that only
	     * emits the arguments given, and the complete notification thereafter. It can
	     * be used for composing with other Observables, such as with {@link concat}.
	     * By default, it uses a `null` IScheduler, which means the `next`
	     * notifications are sent synchronously, although with a different IScheduler
	     * it is possible to determine when those notifications will be delivered.
	     *
	     * @example <caption>Emit 10, 20, 30, then 'a', 'b', 'c', then start ticking every second.</caption>
	     * var numbers = Rx.Observable.of(10, 20, 30);
	     * var letters = Rx.Observable.of('a', 'b', 'c');
	     * var interval = Rx.Observable.interval(1000);
	     * var result = numbers.concat(letters).concat(interval);
	     * result.subscribe(x => console.log(x));
	     *
	     * @see {@link create}
	     * @see {@link empty}
	     * @see {@link never}
	     * @see {@link throw}
	     *
	     * @param {...T} values Arguments that represent `next` values to be emitted.
	     * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling
	     * the emissions of the `next` notifications.
	     * @return {Observable<T>} An Observable that emits each given input value.
	     * @static true
	     * @name of
	     * @owner Observable
	     */
	    ArrayObservable.of = function () {
	        var array = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            array[_i - 0] = arguments[_i];
	        }
	        var scheduler = array[array.length - 1];
	        if (isScheduler_1$3.isScheduler(scheduler)) {
	            array.pop();
	        }
	        else {
	            scheduler = null;
	        }
	        var len = array.length;
	        if (len > 1) {
	            return new ArrayObservable(array, scheduler);
	        }
	        else if (len === 1) {
	            return new ScalarObservable_1.ScalarObservable(array[0], scheduler);
	        }
	        else {
	            return new EmptyObservable_1.EmptyObservable(scheduler);
	        }
	    };
	    ArrayObservable.dispatch = function (state) {
	        var array = state.array, index = state.index, count = state.count, subscriber = state.subscriber;
	        if (index >= count) {
	            subscriber.complete();
	            return;
	        }
	        subscriber.next(array[index]);
	        if (subscriber.closed) {
	            return;
	        }
	        state.index = index + 1;
	        this.schedule(state);
	    };
	    ArrayObservable.prototype._subscribe = function (subscriber) {
	        var index = 0;
	        var array = this.array;
	        var count = array.length;
	        var scheduler = this.scheduler;
	        if (scheduler) {
	            return scheduler.schedule(ArrayObservable.dispatch, 0, {
	                array: array, index: index, count: count, subscriber: subscriber
	            });
	        }
	        else {
	            for (var i = 0; i < count && !subscriber.closed; i++) {
	                subscriber.next(array[i]);
	            }
	            subscriber.complete();
	        }
	    };
	    return ArrayObservable;
	}(Observable_1$9.Observable));
	var ArrayObservable_2 = ArrayObservable;


	var ArrayObservable_1$1 = {
		ArrayObservable: ArrayObservable_2
	};

	var __extends$13 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1$5 = Subscriber_1$3;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var OuterSubscriber = (function (_super) {
	    __extends$13(OuterSubscriber, _super);
	    function OuterSubscriber() {
	        _super.apply(this, arguments);
	    }
	    OuterSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        this.destination.next(innerValue);
	    };
	    OuterSubscriber.prototype.notifyError = function (error, innerSub) {
	        this.destination.error(error);
	    };
	    OuterSubscriber.prototype.notifyComplete = function (innerSub) {
	        this.destination.complete();
	    };
	    return OuterSubscriber;
	}(Subscriber_1$5.Subscriber));
	var OuterSubscriber_2 = OuterSubscriber;


	var OuterSubscriber_1$1 = {
		OuterSubscriber: OuterSubscriber_2
	};

	var isArrayLike_1$2 = (function (x) { return x && typeof x.length === 'number'; });


	var isArrayLike$1 = {
		isArrayLike: isArrayLike_1$2
	};

	function isPromise(value) {
	    return value && typeof value.subscribe !== 'function' && typeof value.then === 'function';
	}
	var isPromise_2 = isPromise;


	var isPromise_1$1 = {
		isPromise: isPromise_2
	};

	var iterator = createCommonjsModule(function (module, exports) {
	"use strict";
	var root_1 = root$1;
	function symbolIteratorPonyfill(root) {
	    var Symbol = root.Symbol;
	    if (typeof Symbol === 'function') {
	        if (!Symbol.iterator) {
	            Symbol.iterator = Symbol('iterator polyfill');
	        }
	        return Symbol.iterator;
	    }
	    else {
	        // [for Mozilla Gecko 27-35:](https://mzl.la/2ewE1zC)
	        var Set_1 = root.Set;
	        if (Set_1 && typeof new Set_1()['@@iterator'] === 'function') {
	            return '@@iterator';
	        }
	        var Map_1 = root.Map;
	        // required for compatability with es6-shim
	        if (Map_1) {
	            var keys = Object.getOwnPropertyNames(Map_1.prototype);
	            for (var i = 0; i < keys.length; ++i) {
	                var key = keys[i];
	                // according to spec, Map.prototype[@@iterator] and Map.orototype.entries must be equal.
	                if (key !== 'entries' && key !== 'size' && Map_1.prototype[key] === Map_1.prototype['entries']) {
	                    return key;
	                }
	            }
	        }
	        return '@@iterator';
	    }
	}
	exports.symbolIteratorPonyfill = symbolIteratorPonyfill;
	exports.iterator = symbolIteratorPonyfill(root_1.root);
	/**
	 * @deprecated use iterator instead
	 */
	exports.$$iterator = exports.iterator;

	});

	var __extends$14 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1$6 = Subscriber_1$3;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var InnerSubscriber = (function (_super) {
	    __extends$14(InnerSubscriber, _super);
	    function InnerSubscriber(parent, outerValue, outerIndex) {
	        _super.call(this);
	        this.parent = parent;
	        this.outerValue = outerValue;
	        this.outerIndex = outerIndex;
	        this.index = 0;
	    }
	    InnerSubscriber.prototype._next = function (value) {
	        this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);
	    };
	    InnerSubscriber.prototype._error = function (error) {
	        this.parent.notifyError(error, this);
	        this.unsubscribe();
	    };
	    InnerSubscriber.prototype._complete = function () {
	        this.parent.notifyComplete(this);
	        this.unsubscribe();
	    };
	    return InnerSubscriber;
	}(Subscriber_1$6.Subscriber));
	var InnerSubscriber_2 = InnerSubscriber;


	var InnerSubscriber_1$1 = {
		InnerSubscriber: InnerSubscriber_2
	};

	var root_1$2 = root$1;
	var isArrayLike_1$1 = isArrayLike$1;
	var isPromise_1 = isPromise_1$1;
	var isObject_1$4 = isObject_1$2;
	var Observable_1$12 = Observable_1$2;
	var iterator_1$1 = iterator;
	var InnerSubscriber_1 = InnerSubscriber_1$1;
	var observable_1$3 = observable;
	function subscribeToResult(outerSubscriber, result, outerValue, outerIndex) {
	    var destination = new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex);
	    if (destination.closed) {
	        return null;
	    }
	    if (result instanceof Observable_1$12.Observable) {
	        if (result._isScalar) {
	            destination.next(result.value);
	            destination.complete();
	            return null;
	        }
	        else {
	            return result.subscribe(destination);
	        }
	    }
	    else if (isArrayLike_1$1.isArrayLike(result)) {
	        for (var i = 0, len = result.length; i < len && !destination.closed; i++) {
	            destination.next(result[i]);
	        }
	        if (!destination.closed) {
	            destination.complete();
	        }
	    }
	    else if (isPromise_1.isPromise(result)) {
	        result.then(function (value) {
	            if (!destination.closed) {
	                destination.next(value);
	                destination.complete();
	            }
	        }, function (err) { return destination.error(err); })
	            .then(null, function (err) {
	            // Escaping the Promise trap: globally throw unhandled errors
	            root_1$2.root.setTimeout(function () { throw err; });
	        });
	        return destination;
	    }
	    else if (result && typeof result[iterator_1$1.iterator] === 'function') {
	        var iterator$$1 = result[iterator_1$1.iterator]();
	        do {
	            var item = iterator$$1.next();
	            if (item.done) {
	                destination.complete();
	                break;
	            }
	            destination.next(item.value);
	            if (destination.closed) {
	                break;
	            }
	        } while (true);
	    }
	    else if (result && typeof result[observable_1$3.observable] === 'function') {
	        var obs = result[observable_1$3.observable]();
	        if (typeof obs.subscribe !== 'function') {
	            destination.error(new TypeError('Provided object does not correctly implement Symbol.observable'));
	        }
	        else {
	            return obs.subscribe(new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex));
	        }
	    }
	    else {
	        var value = isObject_1$4.isObject(result) ? 'an invalid object' : "'" + result + "'";
	        var msg = ("You provided " + value + " where a stream was expected.")
	            + ' You can provide an Observable, Promise, Array, or Iterable.';
	        destination.error(new TypeError(msg));
	    }
	    return null;
	}
	var subscribeToResult_2 = subscribeToResult;


	var subscribeToResult_1$1 = {
		subscribeToResult: subscribeToResult_2
	};

	var __extends$12 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ArrayObservable_1$3 = ArrayObservable_1$1;
	var isArray_1$4 = isArray$1;
	var OuterSubscriber_1 = OuterSubscriber_1$1;
	var subscribeToResult_1 = subscribeToResult_1$1;
	var none = {};
	/* tslint:enable:max-line-length */
	/**
	 * Combines multiple Observables to create an Observable whose values are
	 * calculated from the latest values of each of its input Observables.
	 *
	 * <span class="informal">Whenever any input Observable emits a value, it
	 * computes a formula using the latest values from all the inputs, then emits
	 * the output of that formula.</span>
	 *
	 * <img src="./img/combineLatest.png" width="100%">
	 *
	 * `combineLatest` combines the values from this Observable with values from
	 * Observables passed as arguments. This is done by subscribing to each
	 * Observable, in order, and collecting an array of each of the most recent
	 * values any time any of the input Observables emits, then either taking that
	 * array and passing it as arguments to an optional `project` function and
	 * emitting the return value of that, or just emitting the array of recent
	 * values directly if there is no `project` function.
	 *
	 * @example <caption>Dynamically calculate the Body-Mass Index from an Observable of weight and one for height</caption>
	 * var weight = Rx.Observable.of(70, 72, 76, 79, 75);
	 * var height = Rx.Observable.of(1.76, 1.77, 1.78);
	 * var bmi = weight.combineLatest(height, (w, h) => w / (h * h));
	 * bmi.subscribe(x => console.log('BMI is ' + x));
	 *
	 * // With output to console:
	 * // BMI is 24.212293388429753
	 * // BMI is 23.93948099205209
	 * // BMI is 23.671253629592222
	 *
	 * @see {@link combineAll}
	 * @see {@link merge}
	 * @see {@link withLatestFrom}
	 *
	 * @param {ObservableInput} other An input Observable to combine with the source
	 * Observable. More than one input Observables may be given as argument.
	 * @param {function} [project] An optional function to project the values from
	 * the combined latest values into a new value on the output Observable.
	 * @return {Observable} An Observable of projected values from the most recent
	 * values from each input Observable, or an array of the most recent values from
	 * each input Observable.
	 * @method combineLatest
	 * @owner Observable
	 */
	function combineLatest$3() {
	    var observables = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        observables[_i - 0] = arguments[_i];
	    }
	    var project = null;
	    if (typeof observables[observables.length - 1] === 'function') {
	        project = observables.pop();
	    }
	    // if the first and only other argument besides the resultSelector is an array
	    // assume it's been called with `combineLatest([obs1, obs2, obs3], project)`
	    if (observables.length === 1 && isArray_1$4.isArray(observables[0])) {
	        observables = observables[0].slice();
	    }
	    observables.unshift(this);
	    return this.lift.call(new ArrayObservable_1$3.ArrayObservable(observables), new CombineLatestOperator(project));
	}
	var combineLatest_2$2 = combineLatest$3;
	var CombineLatestOperator = (function () {
	    function CombineLatestOperator(project) {
	        this.project = project;
	    }
	    CombineLatestOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new CombineLatestSubscriber(subscriber, this.project));
	    };
	    return CombineLatestOperator;
	}());
	var CombineLatestOperator_1 = CombineLatestOperator;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var CombineLatestSubscriber = (function (_super) {
	    __extends$12(CombineLatestSubscriber, _super);
	    function CombineLatestSubscriber(destination, project) {
	        _super.call(this, destination);
	        this.project = project;
	        this.active = 0;
	        this.values = [];
	        this.observables = [];
	    }
	    CombineLatestSubscriber.prototype._next = function (observable) {
	        this.values.push(none);
	        this.observables.push(observable);
	    };
	    CombineLatestSubscriber.prototype._complete = function () {
	        var observables = this.observables;
	        var len = observables.length;
	        if (len === 0) {
	            this.destination.complete();
	        }
	        else {
	            this.active = len;
	            this.toRespond = len;
	            for (var i = 0; i < len; i++) {
	                var observable = observables[i];
	                this.add(subscribeToResult_1.subscribeToResult(this, observable, observable, i));
	            }
	        }
	    };
	    CombineLatestSubscriber.prototype.notifyComplete = function (unused) {
	        if ((this.active -= 1) === 0) {
	            this.destination.complete();
	        }
	    };
	    CombineLatestSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        var values = this.values;
	        var oldVal = values[outerIndex];
	        var toRespond = !this.toRespond
	            ? 0
	            : oldVal === none ? --this.toRespond : this.toRespond;
	        values[outerIndex] = innerValue;
	        if (toRespond === 0) {
	            if (this.project) {
	                this._tryProject(values);
	            }
	            else {
	                this.destination.next(values.slice());
	            }
	        }
	    };
	    CombineLatestSubscriber.prototype._tryProject = function (values) {
	        var result;
	        try {
	            result = this.project.apply(this, values);
	        }
	        catch (err) {
	            this.destination.error(err);
	            return;
	        }
	        this.destination.next(result);
	    };
	    return CombineLatestSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));
	var CombineLatestSubscriber_1 = CombineLatestSubscriber;


	var combineLatest_1$2 = {
		combineLatest: combineLatest_2$2,
		CombineLatestOperator: CombineLatestOperator_1,
		CombineLatestSubscriber: CombineLatestSubscriber_1
	};

	var isScheduler_1 = isScheduler_1$1;
	var isArray_1$3 = isArray$1;
	var ArrayObservable_1 = ArrayObservable_1$1;
	var combineLatest_1$1 = combineLatest_1$2;
	/* tslint:enable:max-line-length */
	/**
	 * Combines multiple Observables to create an Observable whose values are
	 * calculated from the latest values of each of its input Observables.
	 *
	 * <span class="informal">Whenever any input Observable emits a value, it
	 * computes a formula using the latest values from all the inputs, then emits
	 * the output of that formula.</span>
	 *
	 * <img src="./img/combineLatest.png" width="100%">
	 *
	 * `combineLatest` combines the values from all the Observables passed as
	 * arguments. This is done by subscribing to each Observable in order and,
	 * whenever any Observable emits, collecting an array of the most recent
	 * values from each Observable. So if you pass `n` Observables to operator,
	 * returned Observable will always emit an array of `n` values, in order
	 * corresponding to order of passed Observables (value from the first Observable
	 * on the first place and so on).
	 *
	 * Static version of `combineLatest` accepts either an array of Observables
	 * or each Observable can be put directly as an argument. Note that array of
	 * Observables is good choice, if you don't know beforehand how many Observables
	 * you will combine. Passing empty array will result in Observable that
	 * completes immediately.
	 *
	 * To ensure output array has always the same length, `combineLatest` will
	 * actually wait for all input Observables to emit at least once,
	 * before it starts emitting results. This means if some Observable emits
	 * values before other Observables started emitting, all that values but last
	 * will be lost. On the other hand, is some Observable does not emit value but
	 * completes, resulting Observable will complete at the same moment without
	 * emitting anything, since it will be now impossible to include value from
	 * completed Observable in resulting array. Also, if some input Observable does
	 * not emit any value and never completes, `combineLatest` will also never emit
	 * and never complete, since, again, it will wait for all streams to emit some
	 * value.
	 *
	 * If at least one Observable was passed to `combineLatest` and all passed Observables
	 * emitted something, resulting Observable will complete when all combined
	 * streams complete. So even if some Observable completes, result of
	 * `combineLatest` will still emit values when other Observables do. In case
	 * of completed Observable, its value from now on will always be the last
	 * emitted value. On the other hand, if any Observable errors, `combineLatest`
	 * will error immediately as well, and all other Observables will be unsubscribed.
	 *
	 * `combineLatest` accepts as optional parameter `project` function, which takes
	 * as arguments all values that would normally be emitted by resulting Observable.
	 * `project` can return any kind of value, which will be then emitted by Observable
	 * instead of default array. Note that `project` does not take as argument that array
	 * of values, but values themselves. That means default `project` can be imagined
	 * as function that takes all its arguments and puts them into an array.
	 *
	 *
	 * @example <caption>Combine two timer Observables</caption>
	 * const firstTimer = Rx.Observable.timer(0, 1000); // emit 0, 1, 2... after every second, starting from now
	 * const secondTimer = Rx.Observable.timer(500, 1000); // emit 0, 1, 2... after every second, starting 0,5s from now
	 * const combinedTimers = Rx.Observable.combineLatest(firstTimer, secondTimer);
	 * combinedTimers.subscribe(value => console.log(value));
	 * // Logs
	 * // [0, 0] after 0.5s
	 * // [1, 0] after 1s
	 * // [1, 1] after 1.5s
	 * // [2, 1] after 2s
	 *
	 *
	 * @example <caption>Combine an array of Observables</caption>
	 * const observables = [1, 5, 10].map(
	 *   n => Rx.Observable.of(n).delay(n * 1000).startWith(0) // emit 0 and then emit n after n seconds
	 * );
	 * const combined = Rx.Observable.combineLatest(observables);
	 * combined.subscribe(value => console.log(value));
	 * // Logs
	 * // [0, 0, 0] immediately
	 * // [1, 0, 0] after 1s
	 * // [1, 5, 0] after 5s
	 * // [1, 5, 10] after 10s
	 *
	 *
	 * @example <caption>Use project function to dynamically calculate the Body-Mass Index</caption>
	 * var weight = Rx.Observable.of(70, 72, 76, 79, 75);
	 * var height = Rx.Observable.of(1.76, 1.77, 1.78);
	 * var bmi = Rx.Observable.combineLatest(weight, height, (w, h) => w / (h * h));
	 * bmi.subscribe(x => console.log('BMI is ' + x));
	 *
	 * // With output to console:
	 * // BMI is 24.212293388429753
	 * // BMI is 23.93948099205209
	 * // BMI is 23.671253629592222
	 *
	 *
	 * @see {@link combineAll}
	 * @see {@link merge}
	 * @see {@link withLatestFrom}
	 *
	 * @param {ObservableInput} observable1 An input Observable to combine with other Observables.
	 * @param {ObservableInput} observable2 An input Observable to combine with other Observables.
	 * More than one input Observables may be given as arguments
	 * or an array of Observables may be given as the first argument.
	 * @param {function} [project] An optional function to project the values from
	 * the combined latest values into a new value on the output Observable.
	 * @param {Scheduler} [scheduler=null] The IScheduler to use for subscribing to
	 * each input Observable.
	 * @return {Observable} An Observable of projected values from the most recent
	 * values from each input Observable, or an array of the most recent values from
	 * each input Observable.
	 * @static true
	 * @name combineLatest
	 * @owner Observable
	 */
	function combineLatest$2() {
	    var observables = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        observables[_i - 0] = arguments[_i];
	    }
	    var project = null;
	    var scheduler = null;
	    if (isScheduler_1.isScheduler(observables[observables.length - 1])) {
	        scheduler = observables.pop();
	    }
	    if (typeof observables[observables.length - 1] === 'function') {
	        project = observables.pop();
	    }
	    // if the first and only other argument besides the resultSelector is an array
	    // assume it's been called with `combineLatest([obs1, obs2, obs3], project)`
	    if (observables.length === 1 && isArray_1$3.isArray(observables[0])) {
	        observables = observables[0];
	    }
	    return new ArrayObservable_1.ArrayObservable(observables, scheduler).lift(new combineLatest_1$1.CombineLatestOperator(project));
	}
	var combineLatest_3 = combineLatest$2;


	var combineLatest_2 = {
		combineLatest: combineLatest_3
	};

	var Observable_1$8 = Observable_1$2;
	var combineLatest_1 = combineLatest_2;
	Observable_1$8.Observable.combineLatest = combineLatest_1.combineLatest;

	var __extends$15 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var OuterSubscriber_1$3 = OuterSubscriber_1$1;
	var subscribeToResult_1$3 = subscribeToResult_1$1;
	/**
	 * Converts a higher-order Observable into a first-order Observable which
	 * concurrently delivers all values that are emitted on the inner Observables.
	 *
	 * <span class="informal">Flattens an Observable-of-Observables.</span>
	 *
	 * <img src="./img/mergeAll.png" width="100%">
	 *
	 * `mergeAll` subscribes to an Observable that emits Observables, also known as
	 * a higher-order Observable. Each time it observes one of these emitted inner
	 * Observables, it subscribes to that and delivers all the values from the
	 * inner Observable on the output Observable. The output Observable only
	 * completes once all inner Observables have completed. Any error delivered by
	 * a inner Observable will be immediately emitted on the output Observable.
	 *
	 * @example <caption>Spawn a new interval Observable for each click event, and blend their outputs as one Observable</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000));
	 * var firstOrder = higherOrder.mergeAll();
	 * firstOrder.subscribe(x => console.log(x));
	 *
	 * @example <caption>Count from 0 to 9 every second for each click, but only allow 2 concurrent timers</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000).take(10));
	 * var firstOrder = higherOrder.mergeAll(2);
	 * firstOrder.subscribe(x => console.log(x));
	 *
	 * @see {@link combineAll}
	 * @see {@link concatAll}
	 * @see {@link exhaust}
	 * @see {@link merge}
	 * @see {@link mergeMap}
	 * @see {@link mergeMapTo}
	 * @see {@link mergeScan}
	 * @see {@link switch}
	 * @see {@link zipAll}
	 *
	 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of inner
	 * Observables being subscribed to concurrently.
	 * @return {Observable} An Observable that emits values coming from all the
	 * inner Observables emitted by the source Observable.
	 * @method mergeAll
	 * @owner Observable
	 */
	function mergeAll(concurrent) {
	    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
	    return this.lift(new MergeAllOperator(concurrent));
	}
	var mergeAll_2 = mergeAll;
	var MergeAllOperator = (function () {
	    function MergeAllOperator(concurrent) {
	        this.concurrent = concurrent;
	    }
	    MergeAllOperator.prototype.call = function (observer, source) {
	        return source.subscribe(new MergeAllSubscriber(observer, this.concurrent));
	    };
	    return MergeAllOperator;
	}());
	var MergeAllOperator_1 = MergeAllOperator;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var MergeAllSubscriber = (function (_super) {
	    __extends$15(MergeAllSubscriber, _super);
	    function MergeAllSubscriber(destination, concurrent) {
	        _super.call(this, destination);
	        this.concurrent = concurrent;
	        this.hasCompleted = false;
	        this.buffer = [];
	        this.active = 0;
	    }
	    MergeAllSubscriber.prototype._next = function (observable) {
	        if (this.active < this.concurrent) {
	            this.active++;
	            this.add(subscribeToResult_1$3.subscribeToResult(this, observable));
	        }
	        else {
	            this.buffer.push(observable);
	        }
	    };
	    MergeAllSubscriber.prototype._complete = function () {
	        this.hasCompleted = true;
	        if (this.active === 0 && this.buffer.length === 0) {
	            this.destination.complete();
	        }
	    };
	    MergeAllSubscriber.prototype.notifyComplete = function (innerSub) {
	        var buffer = this.buffer;
	        this.remove(innerSub);
	        this.active--;
	        if (buffer.length > 0) {
	            this._next(buffer.shift());
	        }
	        else if (this.active === 0 && this.hasCompleted) {
	            this.destination.complete();
	        }
	    };
	    return MergeAllSubscriber;
	}(OuterSubscriber_1$3.OuterSubscriber));
	var MergeAllSubscriber_1 = MergeAllSubscriber;


	var mergeAll_1$1 = {
		mergeAll: mergeAll_2,
		MergeAllOperator: MergeAllOperator_1,
		MergeAllSubscriber: MergeAllSubscriber_1
	};

	var Observable_1$14 = Observable_1$2;
	var isScheduler_1$4 = isScheduler_1$1;
	var ArrayObservable_1$4 = ArrayObservable_1$1;
	var mergeAll_1 = mergeAll_1$1;
	/* tslint:enable:max-line-length */
	/**
	 * Creates an output Observable which sequentially emits all values from every
	 * given input Observable after the current Observable.
	 *
	 * <span class="informal">Concatenates multiple Observables together by
	 * sequentially emitting their values, one Observable after the other.</span>
	 *
	 * <img src="./img/concat.png" width="100%">
	 *
	 * Joins this Observable with multiple other Observables by subscribing to them
	 * one at a time, starting with the source, and merging their results into the
	 * output Observable. Will wait for each Observable to complete before moving
	 * on to the next.
	 *
	 * @example <caption>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</caption>
	 * var timer = Rx.Observable.interval(1000).take(4);
	 * var sequence = Rx.Observable.range(1, 10);
	 * var result = timer.concat(sequence);
	 * result.subscribe(x => console.log(x));
	 *
	 * // results in:
	 * // 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3 -immediate-> 1 ... 10
	 *
	 * @example <caption>Concatenate 3 Observables</caption>
	 * var timer1 = Rx.Observable.interval(1000).take(10);
	 * var timer2 = Rx.Observable.interval(2000).take(6);
	 * var timer3 = Rx.Observable.interval(500).take(10);
	 * var result = timer1.concat(timer2, timer3);
	 * result.subscribe(x => console.log(x));
	 *
	 * // results in the following:
	 * // (Prints to console sequentially)
	 * // -1000ms-> 0 -1000ms-> 1 -1000ms-> ... 9
	 * // -2000ms-> 0 -2000ms-> 1 -2000ms-> ... 5
	 * // -500ms-> 0 -500ms-> 1 -500ms-> ... 9
	 *
	 * @see {@link concatAll}
	 * @see {@link concatMap}
	 * @see {@link concatMapTo}
	 *
	 * @param {ObservableInput} other An input Observable to concatenate after the source
	 * Observable. More than one input Observables may be given as argument.
	 * @param {Scheduler} [scheduler=null] An optional IScheduler to schedule each
	 * Observable subscription on.
	 * @return {Observable} All values of each passed Observable merged into a
	 * single Observable, in order, in serial fashion.
	 * @method concat
	 * @owner Observable
	 */
	function concat$5() {
	    var observables = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        observables[_i - 0] = arguments[_i];
	    }
	    return this.lift.call(concatStatic.apply(void 0, [this].concat(observables)));
	}
	var concat_2$1 = concat$5;
	/* tslint:enable:max-line-length */
	/**
	 * Creates an output Observable which sequentially emits all values from given
	 * Observable and then moves on to the next.
	 *
	 * <span class="informal">Concatenates multiple Observables together by
	 * sequentially emitting their values, one Observable after the other.</span>
	 *
	 * <img src="./img/concat.png" width="100%">
	 *
	 * `concat` joins multiple Observables together, by subscribing to them one at a time and
	 * merging their results into the output Observable. You can pass either an array of
	 * Observables, or put them directly as arguments. Passing an empty array will result
	 * in Observable that completes immediately.
	 *
	 * `concat` will subscribe to first input Observable and emit all its values, without
	 * changing or affecting them in any way. When that Observable completes, it will
	 * subscribe to then next Observable passed and, again, emit its values. This will be
	 * repeated, until the operator runs out of Observables. When last input Observable completes,
	 * `concat` will complete as well. At any given moment only one Observable passed to operator
	 * emits values. If you would like to emit values from passed Observables concurrently, check out
	 * {@link merge} instead, especially with optional `concurrent` parameter. As a matter of fact,
	 * `concat` is an equivalent of `merge` operator with `concurrent` parameter set to `1`.
	 *
	 * Note that if some input Observable never completes, `concat` will also never complete
	 * and Observables following the one that did not complete will never be subscribed. On the other
	 * hand, if some Observable simply completes immediately after it is subscribed, it will be
	 * invisible for `concat`, which will just move on to the next Observable.
	 *
	 * If any Observable in chain errors, instead of passing control to the next Observable,
	 * `concat` will error immediately as well. Observables that would be subscribed after
	 * the one that emitted error, never will.
	 *
	 * If you pass to `concat` the same Observable many times, its stream of values
	 * will be "replayed" on every subscription, which means you can repeat given Observable
	 * as many times as you like. If passing the same Observable to `concat` 1000 times becomes tedious,
	 * you can always use {@link repeat}.
	 *
	 * @example <caption>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</caption>
	 * var timer = Rx.Observable.interval(1000).take(4);
	 * var sequence = Rx.Observable.range(1, 10);
	 * var result = Rx.Observable.concat(timer, sequence);
	 * result.subscribe(x => console.log(x));
	 *
	 * // results in:
	 * // 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3 -immediate-> 1 ... 10
	 *
	 *
	 * @example <caption>Concatenate an array of 3 Observables</caption>
	 * var timer1 = Rx.Observable.interval(1000).take(10);
	 * var timer2 = Rx.Observable.interval(2000).take(6);
	 * var timer3 = Rx.Observable.interval(500).take(10);
	 * var result = Rx.Observable.concat([timer1, timer2, timer3]); // note that array is passed
	 * result.subscribe(x => console.log(x));
	 *
	 * // results in the following:
	 * // (Prints to console sequentially)
	 * // -1000ms-> 0 -1000ms-> 1 -1000ms-> ... 9
	 * // -2000ms-> 0 -2000ms-> 1 -2000ms-> ... 5
	 * // -500ms-> 0 -500ms-> 1 -500ms-> ... 9
	 *
	 *
	 * @example <caption>Concatenate the same Observable to repeat it</caption>
	 * const timer = Rx.Observable.interval(1000).take(2);
	 *
	 * Rx.Observable.concat(timer, timer) // concating the same Observable!
	 * .subscribe(
	 *   value => console.log(value),
	 *   err => {},
	 *   () => console.log('...and it is done!')
	 * );
	 *
	 * // Logs:
	 * // 0 after 1s
	 * // 1 after 2s
	 * // 0 after 3s
	 * // 1 after 4s
	 * // "...and it is done!" also after 4s
	 *
	 * @see {@link concatAll}
	 * @see {@link concatMap}
	 * @see {@link concatMapTo}
	 *
	 * @param {ObservableInput} input1 An input Observable to concatenate with others.
	 * @param {ObservableInput} input2 An input Observable to concatenate with others.
	 * More than one input Observables may be given as argument.
	 * @param {Scheduler} [scheduler=null] An optional IScheduler to schedule each
	 * Observable subscription on.
	 * @return {Observable} All values of each passed Observable merged into a
	 * single Observable, in order, in serial fashion.
	 * @static true
	 * @name concat
	 * @owner Observable
	 */
	function concatStatic() {
	    var observables = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        observables[_i - 0] = arguments[_i];
	    }
	    var scheduler = null;
	    var args = observables;
	    if (isScheduler_1$4.isScheduler(args[observables.length - 1])) {
	        scheduler = args.pop();
	    }
	    if (scheduler === null && observables.length === 1 && observables[0] instanceof Observable_1$14.Observable) {
	        return observables[0];
	    }
	    return new ArrayObservable_1$4.ArrayObservable(observables, scheduler).lift(new mergeAll_1.MergeAllOperator(1));
	}
	var concatStatic_1 = concatStatic;


	var concat_1$3 = {
		concat: concat_2$1,
		concatStatic: concatStatic_1
	};

	var concat_1$2 = concat_1$3;
	var concat_2 = concat_1$2.concatStatic;


	var concat$3 = {
		concat: concat_2
	};

	var Observable_1$13 = Observable_1$2;
	var concat_1$1 = concat$3;
	Observable_1$13.Observable.concat = concat_1$1.concat;

	var __extends$16 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Observable_1$16 = Observable_1$2;
	var subscribeToResult_1$4 = subscribeToResult_1$1;
	var OuterSubscriber_1$4 = OuterSubscriber_1$1;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var DeferObservable = (function (_super) {
	    __extends$16(DeferObservable, _super);
	    function DeferObservable(observableFactory) {
	        _super.call(this);
	        this.observableFactory = observableFactory;
	    }
	    /**
	     * Creates an Observable that, on subscribe, calls an Observable factory to
	     * make an Observable for each new Observer.
	     *
	     * <span class="informal">Creates the Observable lazily, that is, only when it
	     * is subscribed.
	     * </span>
	     *
	     * <img src="./img/defer.png" width="100%">
	     *
	     * `defer` allows you to create the Observable only when the Observer
	     * subscribes, and create a fresh Observable for each Observer. It waits until
	     * an Observer subscribes to it, and then it generates an Observable,
	     * typically with an Observable factory function. It does this afresh for each
	     * subscriber, so although each subscriber may think it is subscribing to the
	     * same Observable, in fact each subscriber gets its own individual
	     * Observable.
	     *
	     * @example <caption>Subscribe to either an Observable of clicks or an Observable of interval, at random</caption>
	     * var clicksOrInterval = Rx.Observable.defer(function () {
	     *   if (Math.random() > 0.5) {
	     *     return Rx.Observable.fromEvent(document, 'click');
	     *   } else {
	     *     return Rx.Observable.interval(1000);
	     *   }
	     * });
	     * clicksOrInterval.subscribe(x => console.log(x));
	     *
	     * // Results in the following behavior:
	     * // If the result of Math.random() is greater than 0.5 it will listen
	     * // for clicks anywhere on the "document"; when document is clicked it
	     * // will log a MouseEvent object to the console. If the result is less
	     * // than 0.5 it will emit ascending numbers, one every second(1000ms).
	     *
	     * @see {@link create}
	     *
	     * @param {function(): SubscribableOrPromise} observableFactory The Observable
	     * factory function to invoke for each Observer that subscribes to the output
	     * Observable. May also return a Promise, which will be converted on the fly
	     * to an Observable.
	     * @return {Observable} An Observable whose Observers' subscriptions trigger
	     * an invocation of the given Observable factory function.
	     * @static true
	     * @name defer
	     * @owner Observable
	     */
	    DeferObservable.create = function (observableFactory) {
	        return new DeferObservable(observableFactory);
	    };
	    DeferObservable.prototype._subscribe = function (subscriber) {
	        return new DeferSubscriber(subscriber, this.observableFactory);
	    };
	    return DeferObservable;
	}(Observable_1$16.Observable));
	var DeferObservable_2 = DeferObservable;
	var DeferSubscriber = (function (_super) {
	    __extends$16(DeferSubscriber, _super);
	    function DeferSubscriber(destination, factory) {
	        _super.call(this, destination);
	        this.factory = factory;
	        this.tryDefer();
	    }
	    DeferSubscriber.prototype.tryDefer = function () {
	        try {
	            this._callFactory();
	        }
	        catch (err) {
	            this._error(err);
	        }
	    };
	    DeferSubscriber.prototype._callFactory = function () {
	        var result = this.factory();
	        if (result) {
	            this.add(subscribeToResult_1$4.subscribeToResult(this, result));
	        }
	    };
	    return DeferSubscriber;
	}(OuterSubscriber_1$4.OuterSubscriber));


	var DeferObservable_1$1 = {
		DeferObservable: DeferObservable_2
	};

	var DeferObservable_1 = DeferObservable_1$1;
	var defer_1$2 = DeferObservable_1.DeferObservable.create;


	var defer$3 = {
		defer: defer_1$2
	};

	var Observable_1$15 = Observable_1$2;
	var defer_1$1 = defer$3;
	Observable_1$15.Observable.defer = defer_1$1.defer;

	var EmptyObservable_1$3 = EmptyObservable_1$1;
	var empty_1$1 = EmptyObservable_1$3.EmptyObservable.create;


	var empty$3 = {
		empty: empty_1$1
	};

	var Observable_1$17 = Observable_1$2;
	var empty_1 = empty$3;
	Observable_1$17.Observable.empty = empty_1.empty;

	var __extends$17 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Observable_1$19 = Observable_1$2;
	var EmptyObservable_1$4 = EmptyObservable_1$1;
	var isArray_1$5 = isArray$1;
	var subscribeToResult_1$5 = subscribeToResult_1$1;
	var OuterSubscriber_1$5 = OuterSubscriber_1$1;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var ForkJoinObservable = (function (_super) {
	    __extends$17(ForkJoinObservable, _super);
	    function ForkJoinObservable(sources, resultSelector) {
	        _super.call(this);
	        this.sources = sources;
	        this.resultSelector = resultSelector;
	    }
	    /* tslint:enable:max-line-length */
	    /**
	     * @param sources
	     * @return {any}
	     * @static true
	     * @name forkJoin
	     * @owner Observable
	     */
	    ForkJoinObservable.create = function () {
	        var sources = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            sources[_i - 0] = arguments[_i];
	        }
	        if (sources === null || arguments.length === 0) {
	            return new EmptyObservable_1$4.EmptyObservable();
	        }
	        var resultSelector = null;
	        if (typeof sources[sources.length - 1] === 'function') {
	            resultSelector = sources.pop();
	        }
	        // if the first and only other argument besides the resultSelector is an array
	        // assume it's been called with `forkJoin([obs1, obs2, obs3], resultSelector)`
	        if (sources.length === 1 && isArray_1$5.isArray(sources[0])) {
	            sources = sources[0];
	        }
	        if (sources.length === 0) {
	            return new EmptyObservable_1$4.EmptyObservable();
	        }
	        return new ForkJoinObservable(sources, resultSelector);
	    };
	    ForkJoinObservable.prototype._subscribe = function (subscriber) {
	        return new ForkJoinSubscriber(subscriber, this.sources, this.resultSelector);
	    };
	    return ForkJoinObservable;
	}(Observable_1$19.Observable));
	var ForkJoinObservable_2 = ForkJoinObservable;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var ForkJoinSubscriber = (function (_super) {
	    __extends$17(ForkJoinSubscriber, _super);
	    function ForkJoinSubscriber(destination, sources, resultSelector) {
	        _super.call(this, destination);
	        this.sources = sources;
	        this.resultSelector = resultSelector;
	        this.completed = 0;
	        this.haveValues = 0;
	        var len = sources.length;
	        this.total = len;
	        this.values = new Array(len);
	        for (var i = 0; i < len; i++) {
	            var source = sources[i];
	            var innerSubscription = subscribeToResult_1$5.subscribeToResult(this, source, null, i);
	            if (innerSubscription) {
	                innerSubscription.outerIndex = i;
	                this.add(innerSubscription);
	            }
	        }
	    }
	    ForkJoinSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        this.values[outerIndex] = innerValue;
	        if (!innerSub._hasValue) {
	            innerSub._hasValue = true;
	            this.haveValues++;
	        }
	    };
	    ForkJoinSubscriber.prototype.notifyComplete = function (innerSub) {
	        var destination = this.destination;
	        var _a = this, haveValues = _a.haveValues, resultSelector = _a.resultSelector, values = _a.values;
	        var len = values.length;
	        if (!innerSub._hasValue) {
	            destination.complete();
	            return;
	        }
	        this.completed++;
	        if (this.completed !== len) {
	            return;
	        }
	        if (haveValues === len) {
	            var value = resultSelector ? resultSelector.apply(this, values) : values;
	            destination.next(value);
	        }
	        destination.complete();
	    };
	    return ForkJoinSubscriber;
	}(OuterSubscriber_1$5.OuterSubscriber));


	var ForkJoinObservable_1$1 = {
		ForkJoinObservable: ForkJoinObservable_2
	};

	var ForkJoinObservable_1 = ForkJoinObservable_1$1;
	var forkJoin_1$1 = ForkJoinObservable_1.ForkJoinObservable.create;


	var forkJoin$2 = {
		forkJoin: forkJoin_1$1
	};

	var Observable_1$18 = Observable_1$2;
	var forkJoin_1 = forkJoin$2;
	Observable_1$18.Observable.forkJoin = forkJoin_1.forkJoin;

	var __extends$19 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var root_1$3 = root$1;
	var Observable_1$22 = Observable_1$2;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var PromiseObservable = (function (_super) {
	    __extends$19(PromiseObservable, _super);
	    function PromiseObservable(promise, scheduler) {
	        _super.call(this);
	        this.promise = promise;
	        this.scheduler = scheduler;
	    }
	    /**
	     * Converts a Promise to an Observable.
	     *
	     * <span class="informal">Returns an Observable that just emits the Promise's
	     * resolved value, then completes.</span>
	     *
	     * Converts an ES2015 Promise or a Promises/A+ spec compliant Promise to an
	     * Observable. If the Promise resolves with a value, the output Observable
	     * emits that resolved value as a `next`, and then completes. If the Promise
	     * is rejected, then the output Observable emits the corresponding Error.
	     *
	     * @example <caption>Convert the Promise returned by Fetch to an Observable</caption>
	     * var result = Rx.Observable.fromPromise(fetch('http://myserver.com/'));
	     * result.subscribe(x => console.log(x), e => console.error(e));
	     *
	     * @see {@link bindCallback}
	     * @see {@link from}
	     *
	     * @param {PromiseLike<T>} promise The promise to be converted.
	     * @param {Scheduler} [scheduler] An optional IScheduler to use for scheduling
	     * the delivery of the resolved value (or the rejection).
	     * @return {Observable<T>} An Observable which wraps the Promise.
	     * @static true
	     * @name fromPromise
	     * @owner Observable
	     */
	    PromiseObservable.create = function (promise, scheduler) {
	        return new PromiseObservable(promise, scheduler);
	    };
	    PromiseObservable.prototype._subscribe = function (subscriber) {
	        var _this = this;
	        var promise = this.promise;
	        var scheduler = this.scheduler;
	        if (scheduler == null) {
	            if (this._isScalar) {
	                if (!subscriber.closed) {
	                    subscriber.next(this.value);
	                    subscriber.complete();
	                }
	            }
	            else {
	                promise.then(function (value) {
	                    _this.value = value;
	                    _this._isScalar = true;
	                    if (!subscriber.closed) {
	                        subscriber.next(value);
	                        subscriber.complete();
	                    }
	                }, function (err) {
	                    if (!subscriber.closed) {
	                        subscriber.error(err);
	                    }
	                })
	                    .then(null, function (err) {
	                    // escape the promise trap, throw unhandled errors
	                    root_1$3.root.setTimeout(function () { throw err; });
	                });
	            }
	        }
	        else {
	            if (this._isScalar) {
	                if (!subscriber.closed) {
	                    return scheduler.schedule(dispatchNext$2, 0, { value: this.value, subscriber: subscriber });
	                }
	            }
	            else {
	                promise.then(function (value) {
	                    _this.value = value;
	                    _this._isScalar = true;
	                    if (!subscriber.closed) {
	                        subscriber.add(scheduler.schedule(dispatchNext$2, 0, { value: value, subscriber: subscriber }));
	                    }
	                }, function (err) {
	                    if (!subscriber.closed) {
	                        subscriber.add(scheduler.schedule(dispatchError$2, 0, { err: err, subscriber: subscriber }));
	                    }
	                })
	                    .then(null, function (err) {
	                    // escape the promise trap, throw unhandled errors
	                    root_1$3.root.setTimeout(function () { throw err; });
	                });
	            }
	        }
	    };
	    return PromiseObservable;
	}(Observable_1$22.Observable));
	var PromiseObservable_2 = PromiseObservable;
	function dispatchNext$2(arg) {
	    var value = arg.value, subscriber = arg.subscriber;
	    if (!subscriber.closed) {
	        subscriber.next(value);
	        subscriber.complete();
	    }
	}
	function dispatchError$2(arg) {
	    var err = arg.err, subscriber = arg.subscriber;
	    if (!subscriber.closed) {
	        subscriber.error(err);
	    }
	}


	var PromiseObservable_1$1 = {
		PromiseObservable: PromiseObservable_2
	};

	var __extends$20 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var root_1$4 = root$1;
	var Observable_1$23 = Observable_1$2;
	var iterator_1$4 = iterator;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var IteratorObservable = (function (_super) {
	    __extends$20(IteratorObservable, _super);
	    function IteratorObservable(iterator$$1, scheduler) {
	        _super.call(this);
	        this.scheduler = scheduler;
	        if (iterator$$1 == null) {
	            throw new Error('iterator cannot be null.');
	        }
	        this.iterator = getIterator(iterator$$1);
	    }
	    IteratorObservable.create = function (iterator$$1, scheduler) {
	        return new IteratorObservable(iterator$$1, scheduler);
	    };
	    IteratorObservable.dispatch = function (state) {
	        var index = state.index, hasError = state.hasError, iterator$$1 = state.iterator, subscriber = state.subscriber;
	        if (hasError) {
	            subscriber.error(state.error);
	            return;
	        }
	        var result = iterator$$1.next();
	        if (result.done) {
	            subscriber.complete();
	            return;
	        }
	        subscriber.next(result.value);
	        state.index = index + 1;
	        if (subscriber.closed) {
	            if (typeof iterator$$1.return === 'function') {
	                iterator$$1.return();
	            }
	            return;
	        }
	        this.schedule(state);
	    };
	    IteratorObservable.prototype._subscribe = function (subscriber) {
	        var index = 0;
	        var _a = this, iterator$$1 = _a.iterator, scheduler = _a.scheduler;
	        if (scheduler) {
	            return scheduler.schedule(IteratorObservable.dispatch, 0, {
	                index: index, iterator: iterator$$1, subscriber: subscriber
	            });
	        }
	        else {
	            do {
	                var result = iterator$$1.next();
	                if (result.done) {
	                    subscriber.complete();
	                    break;
	                }
	                else {
	                    subscriber.next(result.value);
	                }
	                if (subscriber.closed) {
	                    if (typeof iterator$$1.return === 'function') {
	                        iterator$$1.return();
	                    }
	                    break;
	                }
	            } while (true);
	        }
	    };
	    return IteratorObservable;
	}(Observable_1$23.Observable));
	var IteratorObservable_2 = IteratorObservable;
	var StringIterator = (function () {
	    function StringIterator(str, idx, len) {
	        if (idx === void 0) { idx = 0; }
	        if (len === void 0) { len = str.length; }
	        this.str = str;
	        this.idx = idx;
	        this.len = len;
	    }
	    StringIterator.prototype[iterator_1$4.iterator] = function () { return (this); };
	    StringIterator.prototype.next = function () {
	        return this.idx < this.len ? {
	            done: false,
	            value: this.str.charAt(this.idx++)
	        } : {
	            done: true,
	            value: undefined
	        };
	    };
	    return StringIterator;
	}());
	var ArrayIterator = (function () {
	    function ArrayIterator(arr, idx, len) {
	        if (idx === void 0) { idx = 0; }
	        if (len === void 0) { len = toLength$1(arr); }
	        this.arr = arr;
	        this.idx = idx;
	        this.len = len;
	    }
	    ArrayIterator.prototype[iterator_1$4.iterator] = function () { return this; };
	    ArrayIterator.prototype.next = function () {
	        return this.idx < this.len ? {
	            done: false,
	            value: this.arr[this.idx++]
	        } : {
	            done: true,
	            value: undefined
	        };
	    };
	    return ArrayIterator;
	}());
	function getIterator(obj) {
	    var i = obj[iterator_1$4.iterator];
	    if (!i && typeof obj === 'string') {
	        return new StringIterator(obj);
	    }
	    if (!i && obj.length !== undefined) {
	        return new ArrayIterator(obj);
	    }
	    if (!i) {
	        throw new TypeError('object is not iterable');
	    }
	    return obj[iterator_1$4.iterator]();
	}
	var maxSafeInteger = Math.pow(2, 53) - 1;
	function toLength$1(o) {
	    var len = +o.length;
	    if (isNaN(len)) {
	        return 0;
	    }
	    if (len === 0 || !numberIsFinite(len)) {
	        return len;
	    }
	    len = sign(len) * Math.floor(Math.abs(len));
	    if (len <= 0) {
	        return 0;
	    }
	    if (len > maxSafeInteger) {
	        return maxSafeInteger;
	    }
	    return len;
	}
	function numberIsFinite(value) {
	    return typeof value === 'number' && root_1$4.root.isFinite(value);
	}
	function sign(value) {
	    var valueAsNumber = +value;
	    if (valueAsNumber === 0) {
	        return valueAsNumber;
	    }
	    if (isNaN(valueAsNumber)) {
	        return valueAsNumber;
	    }
	    return valueAsNumber < 0 ? -1 : 1;
	}


	var IteratorObservable_1$1 = {
		IteratorObservable: IteratorObservable_2
	};

	var __extends$21 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Observable_1$24 = Observable_1$2;
	var ScalarObservable_1$3 = ScalarObservable_1$1;
	var EmptyObservable_1$5 = EmptyObservable_1$1;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var ArrayLikeObservable = (function (_super) {
	    __extends$21(ArrayLikeObservable, _super);
	    function ArrayLikeObservable(arrayLike, scheduler) {
	        _super.call(this);
	        this.arrayLike = arrayLike;
	        this.scheduler = scheduler;
	        if (!scheduler && arrayLike.length === 1) {
	            this._isScalar = true;
	            this.value = arrayLike[0];
	        }
	    }
	    ArrayLikeObservable.create = function (arrayLike, scheduler) {
	        var length = arrayLike.length;
	        if (length === 0) {
	            return new EmptyObservable_1$5.EmptyObservable();
	        }
	        else if (length === 1) {
	            return new ScalarObservable_1$3.ScalarObservable(arrayLike[0], scheduler);
	        }
	        else {
	            return new ArrayLikeObservable(arrayLike, scheduler);
	        }
	    };
	    ArrayLikeObservable.dispatch = function (state) {
	        var arrayLike = state.arrayLike, index = state.index, length = state.length, subscriber = state.subscriber;
	        if (subscriber.closed) {
	            return;
	        }
	        if (index >= length) {
	            subscriber.complete();
	            return;
	        }
	        subscriber.next(arrayLike[index]);
	        state.index = index + 1;
	        this.schedule(state);
	    };
	    ArrayLikeObservable.prototype._subscribe = function (subscriber) {
	        var index = 0;
	        var _a = this, arrayLike = _a.arrayLike, scheduler = _a.scheduler;
	        var length = arrayLike.length;
	        if (scheduler) {
	            return scheduler.schedule(ArrayLikeObservable.dispatch, 0, {
	                arrayLike: arrayLike, index: index, length: length, subscriber: subscriber
	            });
	        }
	        else {
	            for (var i = 0; i < length && !subscriber.closed; i++) {
	                subscriber.next(arrayLike[i]);
	            }
	            subscriber.complete();
	        }
	    };
	    return ArrayLikeObservable;
	}(Observable_1$24.Observable));
	var ArrayLikeObservable_2 = ArrayLikeObservable;


	var ArrayLikeObservable_1$1 = {
		ArrayLikeObservable: ArrayLikeObservable_2
	};

	var Observable_1$25 = Observable_1$2;
	/**
	 * Represents a push-based event or value that an {@link Observable} can emit.
	 * This class is particularly useful for operators that manage notifications,
	 * like {@link materialize}, {@link dematerialize}, {@link observeOn}, and
	 * others. Besides wrapping the actual delivered value, it also annotates it
	 * with metadata of, for instance, what type of push message it is (`next`,
	 * `error`, or `complete`).
	 *
	 * @see {@link materialize}
	 * @see {@link dematerialize}
	 * @see {@link observeOn}
	 *
	 * @class Notification<T>
	 */
	var Notification$1 = (function () {
	    function Notification(kind, value, error) {
	        this.kind = kind;
	        this.value = value;
	        this.error = error;
	        this.hasValue = kind === 'N';
	    }
	    /**
	     * Delivers to the given `observer` the value wrapped by this Notification.
	     * @param {Observer} observer
	     * @return
	     */
	    Notification.prototype.observe = function (observer) {
	        switch (this.kind) {
	            case 'N':
	                return observer.next && observer.next(this.value);
	            case 'E':
	                return observer.error && observer.error(this.error);
	            case 'C':
	                return observer.complete && observer.complete();
	        }
	    };
	    /**
	     * Given some {@link Observer} callbacks, deliver the value represented by the
	     * current Notification to the correctly corresponding callback.
	     * @param {function(value: T): void} next An Observer `next` callback.
	     * @param {function(err: any): void} [error] An Observer `error` callback.
	     * @param {function(): void} [complete] An Observer `complete` callback.
	     * @return {any}
	     */
	    Notification.prototype.do = function (next, error, complete) {
	        var kind = this.kind;
	        switch (kind) {
	            case 'N':
	                return next && next(this.value);
	            case 'E':
	                return error && error(this.error);
	            case 'C':
	                return complete && complete();
	        }
	    };
	    /**
	     * Takes an Observer or its individual callback functions, and calls `observe`
	     * or `do` methods accordingly.
	     * @param {Observer|function(value: T): void} nextOrObserver An Observer or
	     * the `next` callback.
	     * @param {function(err: any): void} [error] An Observer `error` callback.
	     * @param {function(): void} [complete] An Observer `complete` callback.
	     * @return {any}
	     */
	    Notification.prototype.accept = function (nextOrObserver, error, complete) {
	        if (nextOrObserver && typeof nextOrObserver.next === 'function') {
	            return this.observe(nextOrObserver);
	        }
	        else {
	            return this.do(nextOrObserver, error, complete);
	        }
	    };
	    /**
	     * Returns a simple Observable that just delivers the notification represented
	     * by this Notification instance.
	     * @return {any}
	     */
	    Notification.prototype.toObservable = function () {
	        var kind = this.kind;
	        switch (kind) {
	            case 'N':
	                return Observable_1$25.Observable.of(this.value);
	            case 'E':
	                return Observable_1$25.Observable.throw(this.error);
	            case 'C':
	                return Observable_1$25.Observable.empty();
	        }
	        throw new Error('unexpected notification kind value');
	    };
	    /**
	     * A shortcut to create a Notification instance of the type `next` from a
	     * given value.
	     * @param {T} value The `next` value.
	     * @return {Notification<T>} The "next" Notification representing the
	     * argument.
	     */
	    Notification.createNext = function (value) {
	        if (typeof value !== 'undefined') {
	            return new Notification('N', value);
	        }
	        return this.undefinedValueNotification;
	    };
	    /**
	     * A shortcut to create a Notification instance of the type `error` from a
	     * given error.
	     * @param {any} [err] The `error` error.
	     * @return {Notification<T>} The "error" Notification representing the
	     * argument.
	     */
	    Notification.createError = function (err) {
	        return new Notification('E', undefined, err);
	    };
	    /**
	     * A shortcut to create a Notification instance of the type `complete`.
	     * @return {Notification<any>} The valueless "complete" Notification.
	     */
	    Notification.createComplete = function () {
	        return this.completeNotification;
	    };
	    Notification.completeNotification = new Notification('C');
	    Notification.undefinedValueNotification = new Notification('N', undefined);
	    return Notification;
	}());
	var Notification_2 = Notification$1;


	var Notification_1$2 = {
		Notification: Notification_2
	};

	var __extends$22 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1$7 = Subscriber_1$3;
	var Notification_1$1 = Notification_1$2;
	/**
	 *
	 * Re-emits all notifications from source Observable with specified scheduler.
	 *
	 * <span class="informal">Ensure a specific scheduler is used, from outside of an Observable.</span>
	 *
	 * `observeOn` is an operator that accepts a scheduler as a first parameter, which will be used to reschedule
	 * notifications emitted by the source Observable. It might be useful, if you do not have control over
	 * internal scheduler of a given Observable, but want to control when its values are emitted nevertheless.
	 *
	 * Returned Observable emits the same notifications (nexted values, complete and error events) as the source Observable,
	 * but rescheduled with provided scheduler. Note that this doesn't mean that source Observables internal
	 * scheduler will be replaced in any way. Original scheduler still will be used, but when the source Observable emits
	 * notification, it will be immediately scheduled again - this time with scheduler passed to `observeOn`.
	 * An anti-pattern would be calling `observeOn` on Observable that emits lots of values synchronously, to split
	 * that emissions into asynchronous chunks. For this to happen, scheduler would have to be passed into the source
	 * Observable directly (usually into the operator that creates it). `observeOn` simply delays notifications a
	 * little bit more, to ensure that they are emitted at expected moments.
	 *
	 * As a matter of fact, `observeOn` accepts second parameter, which specifies in milliseconds with what delay notifications
	 * will be emitted. The main difference between {@link delay} operator and `observeOn` is that `observeOn`
	 * will delay all notifications - including error notifications - while `delay` will pass through error
	 * from source Observable immediately when it is emitted. In general it is highly recommended to use `delay` operator
	 * for any kind of delaying of values in the stream, while using `observeOn` to specify which scheduler should be used
	 * for notification emissions in general.
	 *
	 * @example <caption>Ensure values in subscribe are called just before browser repaint.</caption>
	 * const intervals = Rx.Observable.interval(10); // Intervals are scheduled
	 *                                               // with async scheduler by default...
	 *
	 * intervals
	 * .observeOn(Rx.Scheduler.animationFrame)       // ...but we will observe on animationFrame
	 * .subscribe(val => {                           // scheduler to ensure smooth animation.
	 *   someDiv.style.height = val + 'px';
	 * });
	 *
	 * @see {@link delay}
	 *
	 * @param {IScheduler} scheduler Scheduler that will be used to reschedule notifications from source Observable.
	 * @param {number} [delay] Number of milliseconds that states with what delay every notification should be rescheduled.
	 * @return {Observable<T>} Observable that emits the same notifications as the source Observable,
	 * but with provided scheduler.
	 *
	 * @method observeOn
	 * @owner Observable
	 */
	function observeOn(scheduler, delay) {
	    if (delay === void 0) { delay = 0; }
	    return this.lift(new ObserveOnOperator(scheduler, delay));
	}
	var observeOn_2 = observeOn;
	var ObserveOnOperator = (function () {
	    function ObserveOnOperator(scheduler, delay) {
	        if (delay === void 0) { delay = 0; }
	        this.scheduler = scheduler;
	        this.delay = delay;
	    }
	    ObserveOnOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new ObserveOnSubscriber(subscriber, this.scheduler, this.delay));
	    };
	    return ObserveOnOperator;
	}());
	var ObserveOnOperator_1 = ObserveOnOperator;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var ObserveOnSubscriber = (function (_super) {
	    __extends$22(ObserveOnSubscriber, _super);
	    function ObserveOnSubscriber(destination, scheduler, delay) {
	        if (delay === void 0) { delay = 0; }
	        _super.call(this, destination);
	        this.scheduler = scheduler;
	        this.delay = delay;
	    }
	    ObserveOnSubscriber.dispatch = function (arg) {
	        var notification = arg.notification, destination = arg.destination;
	        notification.observe(destination);
	        this.unsubscribe();
	    };
	    ObserveOnSubscriber.prototype.scheduleMessage = function (notification) {
	        this.add(this.scheduler.schedule(ObserveOnSubscriber.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));
	    };
	    ObserveOnSubscriber.prototype._next = function (value) {
	        this.scheduleMessage(Notification_1$1.Notification.createNext(value));
	    };
	    ObserveOnSubscriber.prototype._error = function (err) {
	        this.scheduleMessage(Notification_1$1.Notification.createError(err));
	    };
	    ObserveOnSubscriber.prototype._complete = function () {
	        this.scheduleMessage(Notification_1$1.Notification.createComplete());
	    };
	    return ObserveOnSubscriber;
	}(Subscriber_1$7.Subscriber));
	var ObserveOnSubscriber_1 = ObserveOnSubscriber;
	var ObserveOnMessage = (function () {
	    function ObserveOnMessage(notification, destination) {
	        this.notification = notification;
	        this.destination = destination;
	    }
	    return ObserveOnMessage;
	}());
	var ObserveOnMessage_1 = ObserveOnMessage;


	var observeOn_1$1 = {
		observeOn: observeOn_2,
		ObserveOnOperator: ObserveOnOperator_1,
		ObserveOnSubscriber: ObserveOnSubscriber_1,
		ObserveOnMessage: ObserveOnMessage_1
	};

	var __extends$18 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var isArray_1$6 = isArray$1;
	var isArrayLike_1$3 = isArrayLike$1;
	var isPromise_1$3 = isPromise_1$1;
	var PromiseObservable_1 = PromiseObservable_1$1;
	var IteratorObservable_1 = IteratorObservable_1$1;
	var ArrayObservable_1$5 = ArrayObservable_1$1;
	var ArrayLikeObservable_1 = ArrayLikeObservable_1$1;
	var iterator_1$3 = iterator;
	var Observable_1$21 = Observable_1$2;
	var observeOn_1 = observeOn_1$1;
	var observable_1$4 = observable;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var FromObservable = (function (_super) {
	    __extends$18(FromObservable, _super);
	    function FromObservable(ish, scheduler) {
	        _super.call(this, null);
	        this.ish = ish;
	        this.scheduler = scheduler;
	    }
	    /**
	     * Creates an Observable from an Array, an array-like object, a Promise, an
	     * iterable object, or an Observable-like object.
	     *
	     * <span class="informal">Converts almost anything to an Observable.</span>
	     *
	     * <img src="./img/from.png" width="100%">
	     *
	     * Convert various other objects and data types into Observables. `from`
	     * converts a Promise or an array-like or an
	     * [iterable](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterable)
	     * object into an Observable that emits the items in that promise or array or
	     * iterable. A String, in this context, is treated as an array of characters.
	     * Observable-like objects (contains a function named with the ES2015 Symbol
	     * for Observable) can also be converted through this operator.
	     *
	     * @example <caption>Converts an array to an Observable</caption>
	     * var array = [10, 20, 30];
	     * var result = Rx.Observable.from(array);
	     * result.subscribe(x => console.log(x));
	     *
	     * // Results in the following:
	     * // 10 20 30
	     *
	     * @example <caption>Convert an infinite iterable (from a generator) to an Observable</caption>
	     * function* generateDoubles(seed) {
	     *   var i = seed;
	     *   while (true) {
	     *     yield i;
	     *     i = 2 * i; // double it
	     *   }
	     * }
	     *
	     * var iterator = generateDoubles(3);
	     * var result = Rx.Observable.from(iterator).take(10);
	     * result.subscribe(x => console.log(x));
	     *
	     * // Results in the following:
	     * // 3 6 12 24 48 96 192 384 768 1536
	     *
	     * @see {@link create}
	     * @see {@link fromEvent}
	     * @see {@link fromEventPattern}
	     * @see {@link fromPromise}
	     *
	     * @param {ObservableInput<T>} ish A subscribable object, a Promise, an
	     * Observable-like, an Array, an iterable or an array-like object to be
	     * converted.
	     * @param {Scheduler} [scheduler] The scheduler on which to schedule the
	     * emissions of values.
	     * @return {Observable<T>} The Observable whose values are originally from the
	     * input object that was converted.
	     * @static true
	     * @name from
	     * @owner Observable
	     */
	    FromObservable.create = function (ish, scheduler) {
	        if (ish != null) {
	            if (typeof ish[observable_1$4.observable] === 'function') {
	                if (ish instanceof Observable_1$21.Observable && !scheduler) {
	                    return ish;
	                }
	                return new FromObservable(ish, scheduler);
	            }
	            else if (isArray_1$6.isArray(ish)) {
	                return new ArrayObservable_1$5.ArrayObservable(ish, scheduler);
	            }
	            else if (isPromise_1$3.isPromise(ish)) {
	                return new PromiseObservable_1.PromiseObservable(ish, scheduler);
	            }
	            else if (typeof ish[iterator_1$3.iterator] === 'function' || typeof ish === 'string') {
	                return new IteratorObservable_1.IteratorObservable(ish, scheduler);
	            }
	            else if (isArrayLike_1$3.isArrayLike(ish)) {
	                return new ArrayLikeObservable_1.ArrayLikeObservable(ish, scheduler);
	            }
	        }
	        throw new TypeError((ish !== null && typeof ish || ish) + ' is not observable');
	    };
	    FromObservable.prototype._subscribe = function (subscriber) {
	        var ish = this.ish;
	        var scheduler = this.scheduler;
	        if (scheduler == null) {
	            return ish[observable_1$4.observable]().subscribe(subscriber);
	        }
	        else {
	            return ish[observable_1$4.observable]().subscribe(new observeOn_1.ObserveOnSubscriber(subscriber, scheduler, 0));
	        }
	    };
	    return FromObservable;
	}(Observable_1$21.Observable));
	var FromObservable_2 = FromObservable;


	var FromObservable_1$1 = {
		FromObservable: FromObservable_2
	};

	var FromObservable_1 = FromObservable_1$1;
	var from_1$1 = FromObservable_1.FromObservable.create;


	var from$2 = {
		from: from_1$1
	};

	var Observable_1$20 = Observable_1$2;
	var from_1 = from$2;
	Observable_1$20.Observable.from = from_1.from;

	var __extends$23 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Observable_1$27 = Observable_1$2;
	var tryCatch_1$5 = tryCatch_1$1;
	var isFunction_1$5 = isFunction_1$2;
	var errorObject_1$5 = errorObject;
	var Subscription_1$7 = Subscription_1$3;
	var toString$2 = Object.prototype.toString;
	function isNodeStyleEventEmitter(sourceObj) {
	    return !!sourceObj && typeof sourceObj.addListener === 'function' && typeof sourceObj.removeListener === 'function';
	}
	function isJQueryStyleEventEmitter(sourceObj) {
	    return !!sourceObj && typeof sourceObj.on === 'function' && typeof sourceObj.off === 'function';
	}
	function isNodeList(sourceObj) {
	    return !!sourceObj && toString$2.call(sourceObj) === '[object NodeList]';
	}
	function isHTMLCollection(sourceObj) {
	    return !!sourceObj && toString$2.call(sourceObj) === '[object HTMLCollection]';
	}
	function isEventTarget(sourceObj) {
	    return !!sourceObj && typeof sourceObj.addEventListener === 'function' && typeof sourceObj.removeEventListener === 'function';
	}
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var FromEventObservable = (function (_super) {
	    __extends$23(FromEventObservable, _super);
	    function FromEventObservable(sourceObj, eventName, selector, options) {
	        _super.call(this);
	        this.sourceObj = sourceObj;
	        this.eventName = eventName;
	        this.selector = selector;
	        this.options = options;
	    }
	    /* tslint:enable:max-line-length */
	    /**
	     * Creates an Observable that emits events of a specific type coming from the
	     * given event target.
	     *
	     * <span class="informal">Creates an Observable from DOM events, or Node
	     * EventEmitter events or others.</span>
	     *
	     * <img src="./img/fromEvent.png" width="100%">
	     *
	     * Creates an Observable by attaching an event listener to an "event target",
	     * which may be an object with `addEventListener` and `removeEventListener`,
	     * a Node.js EventEmitter, a jQuery style EventEmitter, a NodeList from the
	     * DOM, or an HTMLCollection from the DOM. The event handler is attached when
	     * the output Observable is subscribed, and removed when the Subscription is
	     * unsubscribed.
	     *
	     * @example <caption>Emits clicks happening on the DOM document</caption>
	     * var clicks = Rx.Observable.fromEvent(document, 'click');
	     * clicks.subscribe(x => console.log(x));
	     *
	     * // Results in:
	     * // MouseEvent object logged to console everytime a click
	     * // occurs on the document.
	     *
	     * @see {@link from}
	     * @see {@link fromEventPattern}
	     *
	     * @param {EventTargetLike} target The DOMElement, event target, Node.js
	     * EventEmitter, NodeList or HTMLCollection to attach the event handler to.
	     * @param {string} eventName The event name of interest, being emitted by the
	     * `target`.
	     * @param {EventListenerOptions} [options] Options to pass through to addEventListener
	     * @param {SelectorMethodSignature<T>} [selector] An optional function to
	     * post-process results. It takes the arguments from the event handler and
	     * should return a single value.
	     * @return {Observable<T>}
	     * @static true
	     * @name fromEvent
	     * @owner Observable
	     */
	    FromEventObservable.create = function (target, eventName, options, selector) {
	        if (isFunction_1$5.isFunction(options)) {
	            selector = options;
	            options = undefined;
	        }
	        return new FromEventObservable(target, eventName, selector, options);
	    };
	    FromEventObservable.setupSubscription = function (sourceObj, eventName, handler, subscriber, options) {
	        var unsubscribe;
	        if (isNodeList(sourceObj) || isHTMLCollection(sourceObj)) {
	            for (var i = 0, len = sourceObj.length; i < len; i++) {
	                FromEventObservable.setupSubscription(sourceObj[i], eventName, handler, subscriber, options);
	            }
	        }
	        else if (isEventTarget(sourceObj)) {
	            var source_1 = sourceObj;
	            sourceObj.addEventListener(eventName, handler, options);
	            unsubscribe = function () { return source_1.removeEventListener(eventName, handler); };
	        }
	        else if (isJQueryStyleEventEmitter(sourceObj)) {
	            var source_2 = sourceObj;
	            sourceObj.on(eventName, handler);
	            unsubscribe = function () { return source_2.off(eventName, handler); };
	        }
	        else if (isNodeStyleEventEmitter(sourceObj)) {
	            var source_3 = sourceObj;
	            sourceObj.addListener(eventName, handler);
	            unsubscribe = function () { return source_3.removeListener(eventName, handler); };
	        }
	        else {
	            throw new TypeError('Invalid event target');
	        }
	        subscriber.add(new Subscription_1$7.Subscription(unsubscribe));
	    };
	    FromEventObservable.prototype._subscribe = function (subscriber) {
	        var sourceObj = this.sourceObj;
	        var eventName = this.eventName;
	        var options = this.options;
	        var selector = this.selector;
	        var handler = selector ? function () {
	            var args = [];
	            for (var _i = 0; _i < arguments.length; _i++) {
	                args[_i - 0] = arguments[_i];
	            }
	            var result = tryCatch_1$5.tryCatch(selector).apply(void 0, args);
	            if (result === errorObject_1$5.errorObject) {
	                subscriber.error(errorObject_1$5.errorObject.e);
	            }
	            else {
	                subscriber.next(result);
	            }
	        } : function (e) { return subscriber.next(e); };
	        FromEventObservable.setupSubscription(sourceObj, eventName, handler, subscriber, options);
	    };
	    return FromEventObservable;
	}(Observable_1$27.Observable));
	var FromEventObservable_2 = FromEventObservable;


	var FromEventObservable_1$1 = {
		FromEventObservable: FromEventObservable_2
	};

	var FromEventObservable_1 = FromEventObservable_1$1;
	var fromEvent_1$1 = FromEventObservable_1.FromEventObservable.create;


	var fromEvent$2 = {
		fromEvent: fromEvent_1$1
	};

	var Observable_1$26 = Observable_1$2;
	var fromEvent_1 = fromEvent$2;
	Observable_1$26.Observable.fromEvent = fromEvent_1.fromEvent;

	var __extends$24 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var isFunction_1$6 = isFunction_1$2;
	var Observable_1$29 = Observable_1$2;
	var Subscription_1$8 = Subscription_1$3;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var FromEventPatternObservable = (function (_super) {
	    __extends$24(FromEventPatternObservable, _super);
	    function FromEventPatternObservable(addHandler, removeHandler, selector) {
	        _super.call(this);
	        this.addHandler = addHandler;
	        this.removeHandler = removeHandler;
	        this.selector = selector;
	    }
	    /**
	     * Creates an Observable from an API based on addHandler/removeHandler
	     * functions.
	     *
	     * <span class="informal">Converts any addHandler/removeHandler API to an
	     * Observable.</span>
	     *
	     * <img src="./img/fromEventPattern.png" width="100%">
	     *
	     * Creates an Observable by using the `addHandler` and `removeHandler`
	     * functions to add and remove the handlers, with an optional selector
	     * function to project the event arguments to a result. The `addHandler` is
	     * called when the output Observable is subscribed, and `removeHandler` is
	     * called when the Subscription is unsubscribed.
	     *
	     * @example <caption>Emits clicks happening on the DOM document</caption>
	     * function addClickHandler(handler) {
	     *   document.addEventListener('click', handler);
	     * }
	     *
	     * function removeClickHandler(handler) {
	     *   document.removeEventListener('click', handler);
	     * }
	     *
	     * var clicks = Rx.Observable.fromEventPattern(
	     *   addClickHandler,
	     *   removeClickHandler
	     * );
	     * clicks.subscribe(x => console.log(x));
	     *
	     * @see {@link from}
	     * @see {@link fromEvent}
	     *
	     * @param {function(handler: Function): any} addHandler A function that takes
	     * a `handler` function as argument and attaches it somehow to the actual
	     * source of events.
	     * @param {function(handler: Function, signal?: any): void} [removeHandler] An optional function that
	     * takes a `handler` function as argument and removes it in case it was
	     * previously attached using `addHandler`. if addHandler returns signal to teardown when remove,
	     * removeHandler function will forward it.
	     * @param {function(...args: any): T} [selector] An optional function to
	     * post-process results. It takes the arguments from the event handler and
	     * should return a single value.
	     * @return {Observable<T>}
	     * @static true
	     * @name fromEventPattern
	     * @owner Observable
	     */
	    FromEventPatternObservable.create = function (addHandler, removeHandler, selector) {
	        return new FromEventPatternObservable(addHandler, removeHandler, selector);
	    };
	    FromEventPatternObservable.prototype._subscribe = function (subscriber) {
	        var _this = this;
	        var removeHandler = this.removeHandler;
	        var handler = !!this.selector ? function () {
	            var args = [];
	            for (var _i = 0; _i < arguments.length; _i++) {
	                args[_i - 0] = arguments[_i];
	            }
	            _this._callSelector(subscriber, args);
	        } : function (e) { subscriber.next(e); };
	        var retValue = this._callAddHandler(handler, subscriber);
	        if (!isFunction_1$6.isFunction(removeHandler)) {
	            return;
	        }
	        subscriber.add(new Subscription_1$8.Subscription(function () {
	            //TODO: determine whether or not to forward to error handler
	            removeHandler(handler, retValue);
	        }));
	    };
	    FromEventPatternObservable.prototype._callSelector = function (subscriber, args) {
	        try {
	            var result = this.selector.apply(this, args);
	            subscriber.next(result);
	        }
	        catch (e) {
	            subscriber.error(e);
	        }
	    };
	    FromEventPatternObservable.prototype._callAddHandler = function (handler, errorSubscriber) {
	        try {
	            return this.addHandler(handler) || null;
	        }
	        catch (e) {
	            errorSubscriber.error(e);
	        }
	    };
	    return FromEventPatternObservable;
	}(Observable_1$29.Observable));
	var FromEventPatternObservable_2 = FromEventPatternObservable;


	var FromEventPatternObservable_1$1 = {
		FromEventPatternObservable: FromEventPatternObservable_2
	};

	var FromEventPatternObservable_1 = FromEventPatternObservable_1$1;
	var fromEventPattern_1$1 = FromEventPatternObservable_1.FromEventPatternObservable.create;


	var fromEventPattern$2 = {
		fromEventPattern: fromEventPattern_1$1
	};

	var Observable_1$28 = Observable_1$2;
	var fromEventPattern_1 = fromEventPattern$2;
	Observable_1$28.Observable.fromEventPattern = fromEventPattern_1.fromEventPattern;

	var PromiseObservable_1$3 = PromiseObservable_1$1;
	var fromPromise_1$1 = PromiseObservable_1$3.PromiseObservable.create;


	var fromPromise$2 = {
		fromPromise: fromPromise_1$1
	};

	var Observable_1$30 = Observable_1$2;
	var fromPromise_1 = fromPromise$2;
	Observable_1$30.Observable.fromPromise = fromPromise_1.fromPromise;

	var __extends$25 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Observable_1$32 = Observable_1$2;
	var isScheduler_1$5 = isScheduler_1$1;
	var selfSelector = function (value) { return value; };
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var GenerateObservable = (function (_super) {
	    __extends$25(GenerateObservable, _super);
	    function GenerateObservable(initialState, condition, iterate, resultSelector, scheduler) {
	        _super.call(this);
	        this.initialState = initialState;
	        this.condition = condition;
	        this.iterate = iterate;
	        this.resultSelector = resultSelector;
	        this.scheduler = scheduler;
	    }
	    GenerateObservable.create = function (initialStateOrOptions, condition, iterate, resultSelectorOrObservable, scheduler) {
	        if (arguments.length == 1) {
	            return new GenerateObservable(initialStateOrOptions.initialState, initialStateOrOptions.condition, initialStateOrOptions.iterate, initialStateOrOptions.resultSelector || selfSelector, initialStateOrOptions.scheduler);
	        }
	        if (resultSelectorOrObservable === undefined || isScheduler_1$5.isScheduler(resultSelectorOrObservable)) {
	            return new GenerateObservable(initialStateOrOptions, condition, iterate, selfSelector, resultSelectorOrObservable);
	        }
	        return new GenerateObservable(initialStateOrOptions, condition, iterate, resultSelectorOrObservable, scheduler);
	    };
	    GenerateObservable.prototype._subscribe = function (subscriber) {
	        var state = this.initialState;
	        if (this.scheduler) {
	            return this.scheduler.schedule(GenerateObservable.dispatch, 0, {
	                subscriber: subscriber,
	                iterate: this.iterate,
	                condition: this.condition,
	                resultSelector: this.resultSelector,
	                state: state });
	        }
	        var _a = this, condition = _a.condition, resultSelector = _a.resultSelector, iterate = _a.iterate;
	        do {
	            if (condition) {
	                var conditionResult = void 0;
	                try {
	                    conditionResult = condition(state);
	                }
	                catch (err) {
	                    subscriber.error(err);
	                    return;
	                }
	                if (!conditionResult) {
	                    subscriber.complete();
	                    break;
	                }
	            }
	            var value = void 0;
	            try {
	                value = resultSelector(state);
	            }
	            catch (err) {
	                subscriber.error(err);
	                return;
	            }
	            subscriber.next(value);
	            if (subscriber.closed) {
	                break;
	            }
	            try {
	                state = iterate(state);
	            }
	            catch (err) {
	                subscriber.error(err);
	                return;
	            }
	        } while (true);
	    };
	    GenerateObservable.dispatch = function (state) {
	        var subscriber = state.subscriber, condition = state.condition;
	        if (subscriber.closed) {
	            return;
	        }
	        if (state.needIterate) {
	            try {
	                state.state = state.iterate(state.state);
	            }
	            catch (err) {
	                subscriber.error(err);
	                return;
	            }
	        }
	        else {
	            state.needIterate = true;
	        }
	        if (condition) {
	            var conditionResult = void 0;
	            try {
	                conditionResult = condition(state.state);
	            }
	            catch (err) {
	                subscriber.error(err);
	                return;
	            }
	            if (!conditionResult) {
	                subscriber.complete();
	                return;
	            }
	            if (subscriber.closed) {
	                return;
	            }
	        }
	        var value;
	        try {
	            value = state.resultSelector(state.state);
	        }
	        catch (err) {
	            subscriber.error(err);
	            return;
	        }
	        if (subscriber.closed) {
	            return;
	        }
	        subscriber.next(value);
	        if (subscriber.closed) {
	            return;
	        }
	        return this.schedule(state);
	    };
	    return GenerateObservable;
	}(Observable_1$32.Observable));
	var GenerateObservable_2 = GenerateObservable;


	var GenerateObservable_1$1 = {
		GenerateObservable: GenerateObservable_2
	};

	var Observable_1$31 = Observable_1$2;
	var GenerateObservable_1 = GenerateObservable_1$1;
	Observable_1$31.Observable.generate = GenerateObservable_1.GenerateObservable.create;

	var __extends$26 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Observable_1$34 = Observable_1$2;
	var subscribeToResult_1$6 = subscribeToResult_1$1;
	var OuterSubscriber_1$6 = OuterSubscriber_1$1;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var IfObservable = (function (_super) {
	    __extends$26(IfObservable, _super);
	    function IfObservable(condition, thenSource, elseSource) {
	        _super.call(this);
	        this.condition = condition;
	        this.thenSource = thenSource;
	        this.elseSource = elseSource;
	    }
	    IfObservable.create = function (condition, thenSource, elseSource) {
	        return new IfObservable(condition, thenSource, elseSource);
	    };
	    IfObservable.prototype._subscribe = function (subscriber) {
	        var _a = this, condition = _a.condition, thenSource = _a.thenSource, elseSource = _a.elseSource;
	        return new IfSubscriber(subscriber, condition, thenSource, elseSource);
	    };
	    return IfObservable;
	}(Observable_1$34.Observable));
	var IfObservable_2 = IfObservable;
	var IfSubscriber = (function (_super) {
	    __extends$26(IfSubscriber, _super);
	    function IfSubscriber(destination, condition, thenSource, elseSource) {
	        _super.call(this, destination);
	        this.condition = condition;
	        this.thenSource = thenSource;
	        this.elseSource = elseSource;
	        this.tryIf();
	    }
	    IfSubscriber.prototype.tryIf = function () {
	        var _a = this, condition = _a.condition, thenSource = _a.thenSource, elseSource = _a.elseSource;
	        var result;
	        try {
	            result = condition();
	            var source = result ? thenSource : elseSource;
	            if (source) {
	                this.add(subscribeToResult_1$6.subscribeToResult(this, source));
	            }
	            else {
	                this._complete();
	            }
	        }
	        catch (err) {
	            this._error(err);
	        }
	    };
	    return IfSubscriber;
	}(OuterSubscriber_1$6.OuterSubscriber));


	var IfObservable_1$1 = {
		IfObservable: IfObservable_2
	};

	var IfObservable_1 = IfObservable_1$1;
	var _if_1 = IfObservable_1.IfObservable.create;


	var _if$2 = {
		_if: _if_1
	};

	var Observable_1$33 = Observable_1$2;
	var if_1 = _if$2;
	Observable_1$33.Observable.if = if_1._if;

	var isArray_1$7 = isArray$1;
	function isNumeric(val) {
	    // parseFloat NaNs numeric-cast false positives (null|true|false|"")
	    // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
	    // subtraction forces infinities to NaN
	    // adding 1 corrects loss of precision from parseFloat (#15100)
	    return !isArray_1$7.isArray(val) && (val - parseFloat(val) + 1) >= 0;
	}
	var isNumeric_2 = isNumeric;



	var isNumeric_1$1 = {
		isNumeric: isNumeric_2
	};

	var __extends$29 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscription_1$9 = Subscription_1$3;
	/**
	 * A unit of work to be executed in a {@link Scheduler}. An action is typically
	 * created from within a Scheduler and an RxJS user does not need to concern
	 * themselves about creating and manipulating an Action.
	 *
	 * ```ts
	 * class Action<T> extends Subscription {
	 *   new (scheduler: Scheduler, work: (state?: T) => void);
	 *   schedule(state?: T, delay: number = 0): Subscription;
	 * }
	 * ```
	 *
	 * @class Action<T>
	 */
	var Action = (function (_super) {
	    __extends$29(Action, _super);
	    function Action(scheduler, work) {
	        _super.call(this);
	    }
	    /**
	     * Schedules this action on its parent Scheduler for execution. May be passed
	     * some context object, `state`. May happen at some point in the future,
	     * according to the `delay` parameter, if specified.
	     * @param {T} [state] Some contextual data that the `work` function uses when
	     * called by the Scheduler.
	     * @param {number} [delay] Time to wait before executing the work, where the
	     * time unit is implicit and defined by the Scheduler.
	     * @return {void}
	     */
	    Action.prototype.schedule = function (state, delay) {
	        if (delay === void 0) { delay = 0; }
	        return this;
	    };
	    return Action;
	}(Subscription_1$9.Subscription));
	var Action_2 = Action;


	var Action_1$1 = {
		Action: Action_2
	};

	var __extends$28 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var root_1$5 = root$1;
	var Action_1 = Action_1$1;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var AsyncAction = (function (_super) {
	    __extends$28(AsyncAction, _super);
	    function AsyncAction(scheduler, work) {
	        _super.call(this, scheduler, work);
	        this.scheduler = scheduler;
	        this.work = work;
	        this.pending = false;
	    }
	    AsyncAction.prototype.schedule = function (state, delay) {
	        if (delay === void 0) { delay = 0; }
	        if (this.closed) {
	            return this;
	        }
	        // Always replace the current state with the new state.
	        this.state = state;
	        // Set the pending flag indicating that this action has been scheduled, or
	        // has recursively rescheduled itself.
	        this.pending = true;
	        var id = this.id;
	        var scheduler = this.scheduler;
	        //
	        // Important implementation note:
	        //
	        // Actions only execute once by default, unless rescheduled from within the
	        // scheduled callback. This allows us to implement single and repeat
	        // actions via the same code path, without adding API surface area, as well
	        // as mimic traditional recursion but across asynchronous boundaries.
	        //
	        // However, JS runtimes and timers distinguish between intervals achieved by
	        // serial `setTimeout` calls vs. a single `setInterval` call. An interval of
	        // serial `setTimeout` calls can be individually delayed, which delays
	        // scheduling the next `setTimeout`, and so on. `setInterval` attempts to
	        // guarantee the interval callback will be invoked more precisely to the
	        // interval period, regardless of load.
	        //
	        // Therefore, we use `setInterval` to schedule single and repeat actions.
	        // If the action reschedules itself with the same delay, the interval is not
	        // canceled. If the action doesn't reschedule, or reschedules with a
	        // different delay, the interval will be canceled after scheduled callback
	        // execution.
	        //
	        if (id != null) {
	            this.id = this.recycleAsyncId(scheduler, id, delay);
	        }
	        this.delay = delay;
	        // If this action has already an async Id, don't request a new one.
	        this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);
	        return this;
	    };
	    AsyncAction.prototype.requestAsyncId = function (scheduler, id, delay) {
	        if (delay === void 0) { delay = 0; }
	        return root_1$5.root.setInterval(scheduler.flush.bind(scheduler, this), delay);
	    };
	    AsyncAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
	        if (delay === void 0) { delay = 0; }
	        // If this action is rescheduled with the same delay time, don't clear the interval id.
	        if (delay !== null && this.delay === delay && this.pending === false) {
	            return id;
	        }
	        // Otherwise, if the action's delay time is different from the current delay,
	        // or the action has been rescheduled before it's executed, clear the interval id
	        return root_1$5.root.clearInterval(id) && undefined || undefined;
	    };
	    /**
	     * Immediately executes this action and the `work` it contains.
	     * @return {any}
	     */
	    AsyncAction.prototype.execute = function (state, delay) {
	        if (this.closed) {
	            return new Error('executing a cancelled action');
	        }
	        this.pending = false;
	        var error = this._execute(state, delay);
	        if (error) {
	            return error;
	        }
	        else if (this.pending === false && this.id != null) {
	            // Dequeue if the action didn't reschedule itself. Don't call
	            // unsubscribe(), because the action could reschedule later.
	            // For example:
	            // ```
	            // scheduler.schedule(function doWork(counter) {
	            //   /* ... I'm a busy worker bee ... */
	            //   var originalAction = this;
	            //   /* wait 100ms before rescheduling the action */
	            //   setTimeout(function () {
	            //     originalAction.schedule(counter + 1);
	            //   }, 100);
	            // }, 1000);
	            // ```
	            this.id = this.recycleAsyncId(this.scheduler, this.id, null);
	        }
	    };
	    AsyncAction.prototype._execute = function (state, delay) {
	        var errored = false;
	        var errorValue = undefined;
	        try {
	            this.work(state);
	        }
	        catch (e) {
	            errored = true;
	            errorValue = !!e && e || new Error(e);
	        }
	        if (errored) {
	            this.unsubscribe();
	            return errorValue;
	        }
	    };
	    AsyncAction.prototype._unsubscribe = function () {
	        var id = this.id;
	        var scheduler = this.scheduler;
	        var actions = scheduler.actions;
	        var index = actions.indexOf(this);
	        this.work = null;
	        this.delay = null;
	        this.state = null;
	        this.pending = false;
	        this.scheduler = null;
	        if (index !== -1) {
	            actions.splice(index, 1);
	        }
	        if (id != null) {
	            this.id = this.recycleAsyncId(scheduler, id, null);
	        }
	    };
	    return AsyncAction;
	}(Action_1.Action));
	var AsyncAction_2 = AsyncAction;


	var AsyncAction_1$1 = {
		AsyncAction: AsyncAction_2
	};

	/**
	 * An execution context and a data structure to order tasks and schedule their
	 * execution. Provides a notion of (potentially virtual) time, through the
	 * `now()` getter method.
	 *
	 * Each unit of work in a Scheduler is called an {@link Action}.
	 *
	 * ```ts
	 * class Scheduler {
	 *   now(): number;
	 *   schedule(work, delay?, state?): Subscription;
	 * }
	 * ```
	 *
	 * @class Scheduler
	 */
	var Scheduler$1 = (function () {
	    function Scheduler(SchedulerAction, now) {
	        if (now === void 0) { now = Scheduler.now; }
	        this.SchedulerAction = SchedulerAction;
	        this.now = now;
	    }
	    /**
	     * Schedules a function, `work`, for execution. May happen at some point in
	     * the future, according to the `delay` parameter, if specified. May be passed
	     * some context object, `state`, which will be passed to the `work` function.
	     *
	     * The given arguments will be processed an stored as an Action object in a
	     * queue of actions.
	     *
	     * @param {function(state: ?T): ?Subscription} work A function representing a
	     * task, or some unit of work to be executed by the Scheduler.
	     * @param {number} [delay] Time to wait before executing the work, where the
	     * time unit is implicit and defined by the Scheduler itself.
	     * @param {T} [state] Some contextual data that the `work` function uses when
	     * called by the Scheduler.
	     * @return {Subscription} A subscription in order to be able to unsubscribe
	     * the scheduled work.
	     */
	    Scheduler.prototype.schedule = function (work, delay, state) {
	        if (delay === void 0) { delay = 0; }
	        return new this.SchedulerAction(this, work).schedule(state, delay);
	    };
	    Scheduler.now = Date.now ? Date.now : function () { return +new Date(); };
	    return Scheduler;
	}());
	var Scheduler_2 = Scheduler$1;


	var Scheduler_1$2 = {
		Scheduler: Scheduler_2
	};

	var __extends$30 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Scheduler_1$1 = Scheduler_1$2;
	var AsyncScheduler = (function (_super) {
	    __extends$30(AsyncScheduler, _super);
	    function AsyncScheduler() {
	        _super.apply(this, arguments);
	        this.actions = [];
	        /**
	         * A flag to indicate whether the Scheduler is currently executing a batch of
	         * queued actions.
	         * @type {boolean}
	         */
	        this.active = false;
	        /**
	         * An internal ID used to track the latest asynchronous task such as those
	         * coming from `setTimeout`, `setInterval`, `requestAnimationFrame`, and
	         * others.
	         * @type {any}
	         */
	        this.scheduled = undefined;
	    }
	    AsyncScheduler.prototype.flush = function (action) {
	        var actions = this.actions;
	        if (this.active) {
	            actions.push(action);
	            return;
	        }
	        var error;
	        this.active = true;
	        do {
	            if (error = action.execute(action.state, action.delay)) {
	                break;
	            }
	        } while (action = actions.shift()); // exhaust the scheduler queue
	        this.active = false;
	        if (error) {
	            while (action = actions.shift()) {
	                action.unsubscribe();
	            }
	            throw error;
	        }
	    };
	    return AsyncScheduler;
	}(Scheduler_1$1.Scheduler));
	var AsyncScheduler_2 = AsyncScheduler;


	var AsyncScheduler_1$1 = {
		AsyncScheduler: AsyncScheduler_2
	};

	var AsyncAction_1 = AsyncAction_1$1;
	var AsyncScheduler_1 = AsyncScheduler_1$1;
	/**
	 *
	 * Async Scheduler
	 *
	 * <span class="informal">Schedule task as if you used setTimeout(task, duration)</span>
	 *
	 * `async` scheduler schedules tasks asynchronously, by putting them on the JavaScript
	 * event loop queue. It is best used to delay tasks in time or to schedule tasks repeating
	 * in intervals.
	 *
	 * If you just want to "defer" task, that is to perform it right after currently
	 * executing synchronous code ends (commonly achieved by `setTimeout(deferredTask, 0)`),
	 * better choice will be the {@link asap} scheduler.
	 *
	 * @example <caption>Use async scheduler to delay task</caption>
	 * const task = () => console.log('it works!');
	 *
	 * Rx.Scheduler.async.schedule(task, 2000);
	 *
	 * // After 2 seconds logs:
	 * // "it works!"
	 *
	 *
	 * @example <caption>Use async scheduler to repeat task in intervals</caption>
	 * function task(state) {
	 *   console.log(state);
	 *   this.schedule(state + 1, 1000); // `this` references currently executing Action,
	 *                                   // which we reschedule with new state and delay
	 * }
	 *
	 * Rx.Scheduler.async.schedule(task, 3000, 0);
	 *
	 * // Logs:
	 * // 0 after 3s
	 * // 1 after 4s
	 * // 2 after 5s
	 * // 3 after 6s
	 *
	 * @static true
	 * @name async
	 * @owner Scheduler
	 */
	var async_1$2 = new AsyncScheduler_1.AsyncScheduler(AsyncAction_1.AsyncAction);


	var async = {
		async: async_1$2
	};

	var __extends$27 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var isNumeric_1 = isNumeric_1$1;
	var Observable_1$36 = Observable_1$2;
	var async_1$1 = async;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var IntervalObservable = (function (_super) {
	    __extends$27(IntervalObservable, _super);
	    function IntervalObservable(period, scheduler) {
	        if (period === void 0) { period = 0; }
	        if (scheduler === void 0) { scheduler = async_1$1.async; }
	        _super.call(this);
	        this.period = period;
	        this.scheduler = scheduler;
	        if (!isNumeric_1.isNumeric(period) || period < 0) {
	            this.period = 0;
	        }
	        if (!scheduler || typeof scheduler.schedule !== 'function') {
	            this.scheduler = async_1$1.async;
	        }
	    }
	    /**
	     * Creates an Observable that emits sequential numbers every specified
	     * interval of time, on a specified IScheduler.
	     *
	     * <span class="informal">Emits incremental numbers periodically in time.
	     * </span>
	     *
	     * <img src="./img/interval.png" width="100%">
	     *
	     * `interval` returns an Observable that emits an infinite sequence of
	     * ascending integers, with a constant interval of time of your choosing
	     * between those emissions. The first emission is not sent immediately, but
	     * only after the first period has passed. By default, this operator uses the
	     * `async` IScheduler to provide a notion of time, but you may pass any
	     * IScheduler to it.
	     *
	     * @example <caption>Emits ascending numbers, one every second (1000ms)</caption>
	     * var numbers = Rx.Observable.interval(1000);
	     * numbers.subscribe(x => console.log(x));
	     *
	     * @see {@link timer}
	     * @see {@link delay}
	     *
	     * @param {number} [period=0] The interval size in milliseconds (by default)
	     * or the time unit determined by the scheduler's clock.
	     * @param {Scheduler} [scheduler=async] The IScheduler to use for scheduling
	     * the emission of values, and providing a notion of "time".
	     * @return {Observable} An Observable that emits a sequential number each time
	     * interval.
	     * @static true
	     * @name interval
	     * @owner Observable
	     */
	    IntervalObservable.create = function (period, scheduler) {
	        if (period === void 0) { period = 0; }
	        if (scheduler === void 0) { scheduler = async_1$1.async; }
	        return new IntervalObservable(period, scheduler);
	    };
	    IntervalObservable.dispatch = function (state) {
	        var index = state.index, subscriber = state.subscriber, period = state.period;
	        subscriber.next(index);
	        if (subscriber.closed) {
	            return;
	        }
	        state.index += 1;
	        this.schedule(state, period);
	    };
	    IntervalObservable.prototype._subscribe = function (subscriber) {
	        var index = 0;
	        var period = this.period;
	        var scheduler = this.scheduler;
	        subscriber.add(scheduler.schedule(IntervalObservable.dispatch, period, {
	            index: index, subscriber: subscriber, period: period
	        }));
	    };
	    return IntervalObservable;
	}(Observable_1$36.Observable));
	var IntervalObservable_2 = IntervalObservable;


	var IntervalObservable_1$1 = {
		IntervalObservable: IntervalObservable_2
	};

	var IntervalObservable_1 = IntervalObservable_1$1;
	var interval_1$1 = IntervalObservable_1.IntervalObservable.create;


	var interval$2 = {
		interval: interval_1$1
	};

	var Observable_1$35 = Observable_1$2;
	var interval_1 = interval$2;
	Observable_1$35.Observable.interval = interval_1.interval;

	var Observable_1$38 = Observable_1$2;
	var ArrayObservable_1$6 = ArrayObservable_1$1;
	var mergeAll_1$3 = mergeAll_1$1;
	var isScheduler_1$6 = isScheduler_1$1;
	/* tslint:enable:max-line-length */
	/**
	 * Creates an output Observable which concurrently emits all values from every
	 * given input Observable.
	 *
	 * <span class="informal">Flattens multiple Observables together by blending
	 * their values into one Observable.</span>
	 *
	 * <img src="./img/merge.png" width="100%">
	 *
	 * `merge` subscribes to each given input Observable (either the source or an
	 * Observable given as argument), and simply forwards (without doing any
	 * transformation) all the values from all the input Observables to the output
	 * Observable. The output Observable only completes once all input Observables
	 * have completed. Any error delivered by an input Observable will be immediately
	 * emitted on the output Observable.
	 *
	 * @example <caption>Merge together two Observables: 1s interval and clicks</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var timer = Rx.Observable.interval(1000);
	 * var clicksOrTimer = clicks.merge(timer);
	 * clicksOrTimer.subscribe(x => console.log(x));
	 *
	 * @example <caption>Merge together 3 Observables, but only 2 run concurrently</caption>
	 * var timer1 = Rx.Observable.interval(1000).take(10);
	 * var timer2 = Rx.Observable.interval(2000).take(6);
	 * var timer3 = Rx.Observable.interval(500).take(10);
	 * var concurrent = 2; // the argument
	 * var merged = timer1.merge(timer2, timer3, concurrent);
	 * merged.subscribe(x => console.log(x));
	 *
	 * @see {@link mergeAll}
	 * @see {@link mergeMap}
	 * @see {@link mergeMapTo}
	 * @see {@link mergeScan}
	 *
	 * @param {ObservableInput} other An input Observable to merge with the source
	 * Observable. More than one input Observables may be given as argument.
	 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
	 * Observables being subscribed to concurrently.
	 * @param {Scheduler} [scheduler=null] The IScheduler to use for managing
	 * concurrency of input Observables.
	 * @return {Observable} An Observable that emits items that are the result of
	 * every input Observable.
	 * @method merge
	 * @owner Observable
	 */
	function merge$5() {
	    var observables = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        observables[_i - 0] = arguments[_i];
	    }
	    return this.lift.call(mergeStatic.apply(void 0, [this].concat(observables)));
	}
	var merge_2$1 = merge$5;
	/* tslint:enable:max-line-length */
	/**
	 * Creates an output Observable which concurrently emits all values from every
	 * given input Observable.
	 *
	 * <span class="informal">Flattens multiple Observables together by blending
	 * their values into one Observable.</span>
	 *
	 * <img src="./img/merge.png" width="100%">
	 *
	 * `merge` subscribes to each given input Observable (as arguments), and simply
	 * forwards (without doing any transformation) all the values from all the input
	 * Observables to the output Observable. The output Observable only completes
	 * once all input Observables have completed. Any error delivered by an input
	 * Observable will be immediately emitted on the output Observable.
	 *
	 * @example <caption>Merge together two Observables: 1s interval and clicks</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var timer = Rx.Observable.interval(1000);
	 * var clicksOrTimer = Rx.Observable.merge(clicks, timer);
	 * clicksOrTimer.subscribe(x => console.log(x));
	 *
	 * // Results in the following:
	 * // timer will emit ascending values, one every second(1000ms) to console
	 * // clicks logs MouseEvents to console everytime the "document" is clicked
	 * // Since the two streams are merged you see these happening
	 * // as they occur.
	 *
	 * @example <caption>Merge together 3 Observables, but only 2 run concurrently</caption>
	 * var timer1 = Rx.Observable.interval(1000).take(10);
	 * var timer2 = Rx.Observable.interval(2000).take(6);
	 * var timer3 = Rx.Observable.interval(500).take(10);
	 * var concurrent = 2; // the argument
	 * var merged = Rx.Observable.merge(timer1, timer2, timer3, concurrent);
	 * merged.subscribe(x => console.log(x));
	 *
	 * // Results in the following:
	 * // - First timer1 and timer2 will run concurrently
	 * // - timer1 will emit a value every 1000ms for 10 iterations
	 * // - timer2 will emit a value every 2000ms for 6 iterations
	 * // - after timer1 hits it's max iteration, timer2 will
	 * //   continue, and timer3 will start to run concurrently with timer2
	 * // - when timer2 hits it's max iteration it terminates, and
	 * //   timer3 will continue to emit a value every 500ms until it is complete
	 *
	 * @see {@link mergeAll}
	 * @see {@link mergeMap}
	 * @see {@link mergeMapTo}
	 * @see {@link mergeScan}
	 *
	 * @param {...ObservableInput} observables Input Observables to merge together.
	 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
	 * Observables being subscribed to concurrently.
	 * @param {Scheduler} [scheduler=null] The IScheduler to use for managing
	 * concurrency of input Observables.
	 * @return {Observable} an Observable that emits items that are the result of
	 * every input Observable.
	 * @static true
	 * @name merge
	 * @owner Observable
	 */
	function mergeStatic() {
	    var observables = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        observables[_i - 0] = arguments[_i];
	    }
	    var concurrent = Number.POSITIVE_INFINITY;
	    var scheduler = null;
	    var last = observables[observables.length - 1];
	    if (isScheduler_1$6.isScheduler(last)) {
	        scheduler = observables.pop();
	        if (observables.length > 1 && typeof observables[observables.length - 1] === 'number') {
	            concurrent = observables.pop();
	        }
	    }
	    else if (typeof last === 'number') {
	        concurrent = observables.pop();
	    }
	    if (scheduler === null && observables.length === 1 && observables[0] instanceof Observable_1$38.Observable) {
	        return observables[0];
	    }
	    return new ArrayObservable_1$6.ArrayObservable(observables, scheduler).lift(new mergeAll_1$3.MergeAllOperator(concurrent));
	}
	var mergeStatic_1 = mergeStatic;


	var merge_1$3 = {
		merge: merge_2$1,
		mergeStatic: mergeStatic_1
	};

	var merge_1$2 = merge_1$3;
	var merge_2 = merge_1$2.mergeStatic;


	var merge$3 = {
		merge: merge_2
	};

	var Observable_1$37 = Observable_1$2;
	var merge_1$1 = merge$3;
	Observable_1$37.Observable.merge = merge_1$1.merge;

	var __extends$31 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var isArray_1$8 = isArray$1;
	var ArrayObservable_1$7 = ArrayObservable_1$1;
	var OuterSubscriber_1$7 = OuterSubscriber_1$1;
	var subscribeToResult_1$7 = subscribeToResult_1$1;
	/* tslint:enable:max-line-length */
	/**
	 * Returns an Observable that mirrors the first source Observable to emit an item
	 * from the combination of this Observable and supplied Observables.
	 * @param {...Observables} ...observables Sources used to race for which Observable emits first.
	 * @return {Observable} An Observable that mirrors the output of the first Observable to emit an item.
	 * @method race
	 * @owner Observable
	 */
	function race$2() {
	    var observables = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        observables[_i - 0] = arguments[_i];
	    }
	    // if the only argument is an array, it was most likely called with
	    // `pair([obs1, obs2, ...])`
	    if (observables.length === 1 && isArray_1$8.isArray(observables[0])) {
	        observables = observables[0];
	    }
	    return this.lift.call(raceStatic.apply(void 0, [this].concat(observables)));
	}
	var race_2 = race$2;
	function raceStatic() {
	    var observables = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        observables[_i - 0] = arguments[_i];
	    }
	    // if the only argument is an array, it was most likely called with
	    // `race([obs1, obs2, ...])`
	    if (observables.length === 1) {
	        if (isArray_1$8.isArray(observables[0])) {
	            observables = observables[0];
	        }
	        else {
	            return observables[0];
	        }
	    }
	    return new ArrayObservable_1$7.ArrayObservable(observables).lift(new RaceOperator());
	}
	var raceStatic_1 = raceStatic;
	var RaceOperator = (function () {
	    function RaceOperator() {
	    }
	    RaceOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new RaceSubscriber(subscriber));
	    };
	    return RaceOperator;
	}());
	var RaceOperator_1 = RaceOperator;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var RaceSubscriber = (function (_super) {
	    __extends$31(RaceSubscriber, _super);
	    function RaceSubscriber(destination) {
	        _super.call(this, destination);
	        this.hasFirst = false;
	        this.observables = [];
	        this.subscriptions = [];
	    }
	    RaceSubscriber.prototype._next = function (observable) {
	        this.observables.push(observable);
	    };
	    RaceSubscriber.prototype._complete = function () {
	        var observables = this.observables;
	        var len = observables.length;
	        if (len === 0) {
	            this.destination.complete();
	        }
	        else {
	            for (var i = 0; i < len && !this.hasFirst; i++) {
	                var observable = observables[i];
	                var subscription = subscribeToResult_1$7.subscribeToResult(this, observable, observable, i);
	                if (this.subscriptions) {
	                    this.subscriptions.push(subscription);
	                }
	                this.add(subscription);
	            }
	            this.observables = null;
	        }
	    };
	    RaceSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        if (!this.hasFirst) {
	            this.hasFirst = true;
	            for (var i = 0; i < this.subscriptions.length; i++) {
	                if (i !== outerIndex) {
	                    var subscription = this.subscriptions[i];
	                    subscription.unsubscribe();
	                    this.remove(subscription);
	                }
	            }
	            this.subscriptions = null;
	        }
	        this.destination.next(innerValue);
	    };
	    return RaceSubscriber;
	}(OuterSubscriber_1$7.OuterSubscriber));
	var RaceSubscriber_1 = RaceSubscriber;


	var race_1$1 = {
		race: race_2,
		raceStatic: raceStatic_1,
		RaceOperator: RaceOperator_1,
		RaceSubscriber: RaceSubscriber_1
	};

	var Observable_1$39 = Observable_1$2;
	var race_1 = race_1$1;
	Observable_1$39.Observable.race = race_1.raceStatic;

	/* tslint:disable:no-empty */
	function noop$1() { }
	var noop_2 = noop$1;


	var noop_1$2 = {
		noop: noop_2
	};

	var __extends$32 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Observable_1$41 = Observable_1$2;
	var noop_1$1 = noop_1$2;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var NeverObservable = (function (_super) {
	    __extends$32(NeverObservable, _super);
	    function NeverObservable() {
	        _super.call(this);
	    }
	    /**
	     * Creates an Observable that emits no items to the Observer.
	     *
	     * <span class="informal">An Observable that never emits anything.</span>
	     *
	     * <img src="./img/never.png" width="100%">
	     *
	     * This static operator is useful for creating a simple Observable that emits
	     * neither values nor errors nor the completion notification. It can be used
	     * for testing purposes or for composing with other Observables. Please not
	     * that by never emitting a complete notification, this Observable keeps the
	     * subscription from being disposed automatically. Subscriptions need to be
	     * manually disposed.
	     *
	     * @example <caption>Emit the number 7, then never emit anything else (not even complete).</caption>
	     * function info() {
	     *   console.log('Will not be called');
	     * }
	     * var result = Rx.Observable.never().startWith(7);
	     * result.subscribe(x => console.log(x), info, info);
	     *
	     * @see {@link create}
	     * @see {@link empty}
	     * @see {@link of}
	     * @see {@link throw}
	     *
	     * @return {Observable} A "never" Observable: never emits anything.
	     * @static true
	     * @name never
	     * @owner Observable
	     */
	    NeverObservable.create = function () {
	        return new NeverObservable();
	    };
	    NeverObservable.prototype._subscribe = function (subscriber) {
	        noop_1$1.noop();
	    };
	    return NeverObservable;
	}(Observable_1$41.Observable));
	var NeverObservable_2 = NeverObservable;


	var NeverObservable_1$1 = {
		NeverObservable: NeverObservable_2
	};

	var NeverObservable_1 = NeverObservable_1$1;
	var never_1$1 = NeverObservable_1.NeverObservable.create;


	var never$2 = {
		never: never_1$1
	};

	var Observable_1$40 = Observable_1$2;
	var never_1 = never$2;
	Observable_1$40.Observable.never = never_1.never;

	var ArrayObservable_1$8 = ArrayObservable_1$1;
	var of_1$1 = ArrayObservable_1$8.ArrayObservable.of;


	var of$2 = {
		of: of_1$1
	};

	var Observable_1$42 = Observable_1$2;
	var of_1 = of$2;
	Observable_1$42.Observable.of = of_1.of;

	var __extends$33 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var FromObservable_1$3 = FromObservable_1$1;
	var isArray_1$9 = isArray$1;
	var OuterSubscriber_1$8 = OuterSubscriber_1$1;
	var subscribeToResult_1$8 = subscribeToResult_1$1;
	/* tslint:enable:max-line-length */
	/**
	 * When any of the provided Observable emits an complete or error notification, it immediately subscribes to the next one
	 * that was passed.
	 *
	 * <span class="informal">Execute series of Observables no matter what, even if it means swallowing errors.</span>
	 *
	 * <img src="./img/onErrorResumeNext.png" width="100%">
	 *
	 * `onErrorResumeNext` is an operator that accepts a series of Observables, provided either directly as
	 * arguments or as an array. If no single Observable is provided, returned Observable will simply behave the same
	 * as the source.
	 *
	 * `onErrorResumeNext` returns an Observable that starts by subscribing and re-emitting values from the source Observable.
	 * When its stream of values ends - no matter if Observable completed or emitted an error - `onErrorResumeNext`
	 * will subscribe to the first Observable that was passed as an argument to the method. It will start re-emitting
	 * its values as well and - again - when that stream ends, `onErrorResumeNext` will proceed to subscribing yet another
	 * Observable in provided series, no matter if previous Observable completed or ended with an error. This will
	 * be happening until there is no more Observables left in the series, at which point returned Observable will
	 * complete - even if the last subscribed stream ended with an error.
	 *
	 * `onErrorResumeNext` can be therefore though of as version of {@link concat} operator, which is more permissive
	 * when it comes to the errors emitted by its input Observables. While `concat` subscribes to the next Observable
	 * in series only if previous one successfully completed, `onErrorResumeNext` subscribes even if it ended with
	 * an error.
	 *
	 * Note that you do not get any access to errors emitted by the Observables. In particular do not
	 * expect these errors to appear in error callback passed to {@link subscribe}. If you want to take
	 * specific actions based on what error was emitted by an Observable, you should try out {@link catch} instead.
	 *
	 *
	 * @example <caption>Subscribe to the next Observable after map fails</caption>
	 * Rx.Observable.of(1, 2, 3, 0)
	 *   .map(x => {
	 *       if (x === 0) { throw Error(); }
	         return 10 / x;
	 *   })
	 *   .onErrorResumeNext(Rx.Observable.of(1, 2, 3))
	 *   .subscribe(
	 *     val => console.log(val),
	 *     err => console.log(err),          // Will never be called.
	 *     () => console.log('that\'s it!')
	 *   );
	 *
	 * // Logs:
	 * // 10
	 * // 5
	 * // 3.3333333333333335
	 * // 1
	 * // 2
	 * // 3
	 * // "that's it!"
	 *
	 * @see {@link concat}
	 * @see {@link catch}
	 *
	 * @param {...ObservableInput} observables Observables passed either directly or as an array.
	 * @return {Observable} An Observable that emits values from source Observable, but - if it errors - subscribes
	 * to the next passed Observable and so on, until it completes or runs out of Observables.
	 * @method onErrorResumeNext
	 * @owner Observable
	 */
	function onErrorResumeNext$2() {
	    var nextSources = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        nextSources[_i - 0] = arguments[_i];
	    }
	    if (nextSources.length === 1 && isArray_1$9.isArray(nextSources[0])) {
	        nextSources = nextSources[0];
	    }
	    return this.lift(new OnErrorResumeNextOperator(nextSources));
	}
	var onErrorResumeNext_2 = onErrorResumeNext$2;
	/* tslint:enable:max-line-length */
	function onErrorResumeNextStatic() {
	    var nextSources = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        nextSources[_i - 0] = arguments[_i];
	    }
	    var source = null;
	    if (nextSources.length === 1 && isArray_1$9.isArray(nextSources[0])) {
	        nextSources = nextSources[0];
	    }
	    source = nextSources.shift();
	    return new FromObservable_1$3.FromObservable(source, null).lift(new OnErrorResumeNextOperator(nextSources));
	}
	var onErrorResumeNextStatic_1 = onErrorResumeNextStatic;
	var OnErrorResumeNextOperator = (function () {
	    function OnErrorResumeNextOperator(nextSources) {
	        this.nextSources = nextSources;
	    }
	    OnErrorResumeNextOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new OnErrorResumeNextSubscriber(subscriber, this.nextSources));
	    };
	    return OnErrorResumeNextOperator;
	}());
	var OnErrorResumeNextSubscriber = (function (_super) {
	    __extends$33(OnErrorResumeNextSubscriber, _super);
	    function OnErrorResumeNextSubscriber(destination, nextSources) {
	        _super.call(this, destination);
	        this.destination = destination;
	        this.nextSources = nextSources;
	    }
	    OnErrorResumeNextSubscriber.prototype.notifyError = function (error, innerSub) {
	        this.subscribeToNextSource();
	    };
	    OnErrorResumeNextSubscriber.prototype.notifyComplete = function (innerSub) {
	        this.subscribeToNextSource();
	    };
	    OnErrorResumeNextSubscriber.prototype._error = function (err) {
	        this.subscribeToNextSource();
	    };
	    OnErrorResumeNextSubscriber.prototype._complete = function () {
	        this.subscribeToNextSource();
	    };
	    OnErrorResumeNextSubscriber.prototype.subscribeToNextSource = function () {
	        var next = this.nextSources.shift();
	        if (next) {
	            this.add(subscribeToResult_1$8.subscribeToResult(this, next));
	        }
	        else {
	            this.destination.complete();
	        }
	    };
	    return OnErrorResumeNextSubscriber;
	}(OuterSubscriber_1$8.OuterSubscriber));


	var onErrorResumeNext_1$1 = {
		onErrorResumeNext: onErrorResumeNext_2,
		onErrorResumeNextStatic: onErrorResumeNextStatic_1
	};

	var Observable_1$43 = Observable_1$2;
	var onErrorResumeNext_1 = onErrorResumeNext_1$1;
	Observable_1$43.Observable.onErrorResumeNext = onErrorResumeNext_1.onErrorResumeNextStatic;

	var __extends$34 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Observable_1$45 = Observable_1$2;
	function dispatch$1(state) {
	    var obj = state.obj, keys = state.keys, length = state.length, index = state.index, subscriber = state.subscriber;
	    if (index === length) {
	        subscriber.complete();
	        return;
	    }
	    var key = keys[index];
	    subscriber.next([key, obj[key]]);
	    state.index = index + 1;
	    this.schedule(state);
	}
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var PairsObservable = (function (_super) {
	    __extends$34(PairsObservable, _super);
	    function PairsObservable(obj, scheduler) {
	        _super.call(this);
	        this.obj = obj;
	        this.scheduler = scheduler;
	        this.keys = Object.keys(obj);
	    }
	    /**
	     * Convert an object into an observable sequence of [key, value] pairs
	     * using an optional IScheduler to enumerate the object.
	     *
	     * @example <caption>Converts a javascript object to an Observable</caption>
	     * var obj = {
	     *   foo: 42,
	     *   bar: 56,
	     *   baz: 78
	     * };
	     *
	     * var source = Rx.Observable.pairs(obj);
	     *
	     * var subscription = source.subscribe(
	     *   function (x) {
	     *     console.log('Next: %s', x);
	     *   },
	     *   function (err) {
	     *     console.log('Error: %s', err);
	     *   },
	     *   function () {
	     *     console.log('Completed');
	     *   });
	     *
	     * @param {Object} obj The object to inspect and turn into an
	     * Observable sequence.
	     * @param {Scheduler} [scheduler] An optional IScheduler to run the
	     * enumeration of the input sequence on.
	     * @returns {(Observable<Array<string | T>>)} An observable sequence of
	     * [key, value] pairs from the object.
	     */
	    PairsObservable.create = function (obj, scheduler) {
	        return new PairsObservable(obj, scheduler);
	    };
	    PairsObservable.prototype._subscribe = function (subscriber) {
	        var _a = this, keys = _a.keys, scheduler = _a.scheduler;
	        var length = keys.length;
	        if (scheduler) {
	            return scheduler.schedule(dispatch$1, 0, {
	                obj: this.obj, keys: keys, length: length, index: 0, subscriber: subscriber
	            });
	        }
	        else {
	            for (var idx = 0; idx < length; idx++) {
	                var key = keys[idx];
	                subscriber.next([key, this.obj[key]]);
	            }
	            subscriber.complete();
	        }
	    };
	    return PairsObservable;
	}(Observable_1$45.Observable));
	var PairsObservable_2 = PairsObservable;


	var PairsObservable_1$1 = {
		PairsObservable: PairsObservable_2
	};

	var PairsObservable_1 = PairsObservable_1$1;
	var pairs_1$1 = PairsObservable_1.PairsObservable.create;


	var pairs$2 = {
		pairs: pairs_1$1
	};

	var Observable_1$44 = Observable_1$2;
	var pairs_1 = pairs$2;
	Observable_1$44.Observable.pairs = pairs_1.pairs;

	var __extends$35 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Observable_1$47 = Observable_1$2;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var RangeObservable = (function (_super) {
	    __extends$35(RangeObservable, _super);
	    function RangeObservable(start, count, scheduler) {
	        _super.call(this);
	        this.start = start;
	        this._count = count;
	        this.scheduler = scheduler;
	    }
	    /**
	     * Creates an Observable that emits a sequence of numbers within a specified
	     * range.
	     *
	     * <span class="informal">Emits a sequence of numbers in a range.</span>
	     *
	     * <img src="./img/range.png" width="100%">
	     *
	     * `range` operator emits a range of sequential integers, in order, where you
	     * select the `start` of the range and its `length`. By default, uses no
	     * IScheduler and just delivers the notifications synchronously, but may use
	     * an optional IScheduler to regulate those deliveries.
	     *
	     * @example <caption>Emits the numbers 1 to 10</caption>
	     * var numbers = Rx.Observable.range(1, 10);
	     * numbers.subscribe(x => console.log(x));
	     *
	     * @see {@link timer}
	     * @see {@link interval}
	     *
	     * @param {number} [start=0] The value of the first integer in the sequence.
	     * @param {number} [count=0] The number of sequential integers to generate.
	     * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling
	     * the emissions of the notifications.
	     * @return {Observable} An Observable of numbers that emits a finite range of
	     * sequential integers.
	     * @static true
	     * @name range
	     * @owner Observable
	     */
	    RangeObservable.create = function (start, count, scheduler) {
	        if (start === void 0) { start = 0; }
	        if (count === void 0) { count = 0; }
	        return new RangeObservable(start, count, scheduler);
	    };
	    RangeObservable.dispatch = function (state) {
	        var start = state.start, index = state.index, count = state.count, subscriber = state.subscriber;
	        if (index >= count) {
	            subscriber.complete();
	            return;
	        }
	        subscriber.next(start);
	        if (subscriber.closed) {
	            return;
	        }
	        state.index = index + 1;
	        state.start = start + 1;
	        this.schedule(state);
	    };
	    RangeObservable.prototype._subscribe = function (subscriber) {
	        var index = 0;
	        var start = this.start;
	        var count = this._count;
	        var scheduler = this.scheduler;
	        if (scheduler) {
	            return scheduler.schedule(RangeObservable.dispatch, 0, {
	                index: index, count: count, start: start, subscriber: subscriber
	            });
	        }
	        else {
	            do {
	                if (index++ >= count) {
	                    subscriber.complete();
	                    break;
	                }
	                subscriber.next(start++);
	                if (subscriber.closed) {
	                    break;
	                }
	            } while (true);
	        }
	    };
	    return RangeObservable;
	}(Observable_1$47.Observable));
	var RangeObservable_2 = RangeObservable;


	var RangeObservable_1$1 = {
		RangeObservable: RangeObservable_2
	};

	var RangeObservable_1 = RangeObservable_1$1;
	var range_1$2 = RangeObservable_1.RangeObservable.create;


	var range$3 = {
		range: range_1$2
	};

	var Observable_1$46 = Observable_1$2;
	var range_1$1 = range$3;
	Observable_1$46.Observable.range = range_1$1.range;

	var __extends$36 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Observable_1$49 = Observable_1$2;
	var subscribeToResult_1$9 = subscribeToResult_1$1;
	var OuterSubscriber_1$9 = OuterSubscriber_1$1;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var UsingObservable = (function (_super) {
	    __extends$36(UsingObservable, _super);
	    function UsingObservable(resourceFactory, observableFactory) {
	        _super.call(this);
	        this.resourceFactory = resourceFactory;
	        this.observableFactory = observableFactory;
	    }
	    UsingObservable.create = function (resourceFactory, observableFactory) {
	        return new UsingObservable(resourceFactory, observableFactory);
	    };
	    UsingObservable.prototype._subscribe = function (subscriber) {
	        var _a = this, resourceFactory = _a.resourceFactory, observableFactory = _a.observableFactory;
	        var resource;
	        try {
	            resource = resourceFactory();
	            return new UsingSubscriber(subscriber, resource, observableFactory);
	        }
	        catch (err) {
	            subscriber.error(err);
	        }
	    };
	    return UsingObservable;
	}(Observable_1$49.Observable));
	var UsingObservable_2 = UsingObservable;
	var UsingSubscriber = (function (_super) {
	    __extends$36(UsingSubscriber, _super);
	    function UsingSubscriber(destination, resource, observableFactory) {
	        _super.call(this, destination);
	        this.resource = resource;
	        this.observableFactory = observableFactory;
	        destination.add(resource);
	        this.tryUse();
	    }
	    UsingSubscriber.prototype.tryUse = function () {
	        try {
	            var source = this.observableFactory.call(this, this.resource);
	            if (source) {
	                this.add(subscribeToResult_1$9.subscribeToResult(this, source));
	            }
	        }
	        catch (err) {
	            this._error(err);
	        }
	    };
	    return UsingSubscriber;
	}(OuterSubscriber_1$9.OuterSubscriber));


	var UsingObservable_1$1 = {
		UsingObservable: UsingObservable_2
	};

	var UsingObservable_1 = UsingObservable_1$1;
	var using_1$1 = UsingObservable_1.UsingObservable.create;


	var using$2 = {
		using: using_1$1
	};

	var Observable_1$48 = Observable_1$2;
	var using_1 = using$2;
	Observable_1$48.Observable.using = using_1.using;

	var __extends$37 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Observable_1$51 = Observable_1$2;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var ErrorObservable = (function (_super) {
	    __extends$37(ErrorObservable, _super);
	    function ErrorObservable(error, scheduler) {
	        _super.call(this);
	        this.error = error;
	        this.scheduler = scheduler;
	    }
	    /**
	     * Creates an Observable that emits no items to the Observer and immediately
	     * emits an error notification.
	     *
	     * <span class="informal">Just emits 'error', and nothing else.
	     * </span>
	     *
	     * <img src="./img/throw.png" width="100%">
	     *
	     * This static operator is useful for creating a simple Observable that only
	     * emits the error notification. It can be used for composing with other
	     * Observables, such as in a {@link mergeMap}.
	     *
	     * @example <caption>Emit the number 7, then emit an error.</caption>
	     * var result = Rx.Observable.throw(new Error('oops!')).startWith(7);
	     * result.subscribe(x => console.log(x), e => console.error(e));
	     *
	     * @example <caption>Map and flatten numbers to the sequence 'a', 'b', 'c', but throw an error for 13</caption>
	     * var interval = Rx.Observable.interval(1000);
	     * var result = interval.mergeMap(x =>
	     *   x === 13 ?
	     *     Rx.Observable.throw('Thirteens are bad') :
	     *     Rx.Observable.of('a', 'b', 'c')
	     * );
	     * result.subscribe(x => console.log(x), e => console.error(e));
	     *
	     * @see {@link create}
	     * @see {@link empty}
	     * @see {@link never}
	     * @see {@link of}
	     *
	     * @param {any} error The particular Error to pass to the error notification.
	     * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling
	     * the emission of the error notification.
	     * @return {Observable} An error Observable: emits only the error notification
	     * using the given error argument.
	     * @static true
	     * @name throw
	     * @owner Observable
	     */
	    ErrorObservable.create = function (error, scheduler) {
	        return new ErrorObservable(error, scheduler);
	    };
	    ErrorObservable.dispatch = function (arg) {
	        var error = arg.error, subscriber = arg.subscriber;
	        subscriber.error(error);
	    };
	    ErrorObservable.prototype._subscribe = function (subscriber) {
	        var error = this.error;
	        var scheduler = this.scheduler;
	        if (scheduler) {
	            return scheduler.schedule(ErrorObservable.dispatch, 0, {
	                error: error, subscriber: subscriber
	            });
	        }
	        else {
	            subscriber.error(error);
	        }
	    };
	    return ErrorObservable;
	}(Observable_1$51.Observable));
	var ErrorObservable_2 = ErrorObservable;


	var ErrorObservable_1$1 = {
		ErrorObservable: ErrorObservable_2
	};

	var ErrorObservable_1 = ErrorObservable_1$1;
	var _throw_1 = ErrorObservable_1.ErrorObservable.create;


	var _throw$2 = {
		_throw: _throw_1
	};

	var Observable_1$50 = Observable_1$2;
	var throw_1 = _throw$2;
	Observable_1$50.Observable.throw = throw_1._throw;

	function isDate$1(value) {
	    return value instanceof Date && !isNaN(+value);
	}
	var isDate_2 = isDate$1;


	var isDate_1$2 = {
		isDate: isDate_2
	};

	var __extends$38 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var isNumeric_1$3 = isNumeric_1$1;
	var Observable_1$53 = Observable_1$2;
	var async_1$3 = async;
	var isScheduler_1$7 = isScheduler_1$1;
	var isDate_1$1 = isDate_1$2;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var TimerObservable = (function (_super) {
	    __extends$38(TimerObservable, _super);
	    function TimerObservable(dueTime, period, scheduler) {
	        if (dueTime === void 0) { dueTime = 0; }
	        _super.call(this);
	        this.period = -1;
	        this.dueTime = 0;
	        if (isNumeric_1$3.isNumeric(period)) {
	            this.period = Number(period) < 1 && 1 || Number(period);
	        }
	        else if (isScheduler_1$7.isScheduler(period)) {
	            scheduler = period;
	        }
	        if (!isScheduler_1$7.isScheduler(scheduler)) {
	            scheduler = async_1$3.async;
	        }
	        this.scheduler = scheduler;
	        this.dueTime = isDate_1$1.isDate(dueTime) ?
	            (+dueTime - this.scheduler.now()) :
	            dueTime;
	    }
	    /**
	     * Creates an Observable that starts emitting after an `initialDelay` and
	     * emits ever increasing numbers after each `period` of time thereafter.
	     *
	     * <span class="informal">Its like {@link interval}, but you can specify when
	     * should the emissions start.</span>
	     *
	     * <img src="./img/timer.png" width="100%">
	     *
	     * `timer` returns an Observable that emits an infinite sequence of ascending
	     * integers, with a constant interval of time, `period` of your choosing
	     * between those emissions. The first emission happens after the specified
	     * `initialDelay`. The initial delay may be a {@link Date}. By default, this
	     * operator uses the `async` IScheduler to provide a notion of time, but you
	     * may pass any IScheduler to it. If `period` is not specified, the output
	     * Observable emits only one value, `0`. Otherwise, it emits an infinite
	     * sequence.
	     *
	     * @example <caption>Emits ascending numbers, one every second (1000ms), starting after 3 seconds</caption>
	     * var numbers = Rx.Observable.timer(3000, 1000);
	     * numbers.subscribe(x => console.log(x));
	     *
	     * @example <caption>Emits one number after five seconds</caption>
	     * var numbers = Rx.Observable.timer(5000);
	     * numbers.subscribe(x => console.log(x));
	     *
	     * @see {@link interval}
	     * @see {@link delay}
	     *
	     * @param {number|Date} initialDelay The initial delay time to wait before
	     * emitting the first value of `0`.
	     * @param {number} [period] The period of time between emissions of the
	     * subsequent numbers.
	     * @param {Scheduler} [scheduler=async] The IScheduler to use for scheduling
	     * the emission of values, and providing a notion of "time".
	     * @return {Observable} An Observable that emits a `0` after the
	     * `initialDelay` and ever increasing numbers after each `period` of time
	     * thereafter.
	     * @static true
	     * @name timer
	     * @owner Observable
	     */
	    TimerObservable.create = function (initialDelay, period, scheduler) {
	        if (initialDelay === void 0) { initialDelay = 0; }
	        return new TimerObservable(initialDelay, period, scheduler);
	    };
	    TimerObservable.dispatch = function (state) {
	        var index = state.index, period = state.period, subscriber = state.subscriber;
	        var action = this;
	        subscriber.next(index);
	        if (subscriber.closed) {
	            return;
	        }
	        else if (period === -1) {
	            return subscriber.complete();
	        }
	        state.index = index + 1;
	        action.schedule(state, period);
	    };
	    TimerObservable.prototype._subscribe = function (subscriber) {
	        var index = 0;
	        var _a = this, period = _a.period, dueTime = _a.dueTime, scheduler = _a.scheduler;
	        return scheduler.schedule(TimerObservable.dispatch, dueTime, {
	            index: index, period: period, subscriber: subscriber
	        });
	    };
	    return TimerObservable;
	}(Observable_1$53.Observable));
	var TimerObservable_2 = TimerObservable;


	var TimerObservable_1$1 = {
		TimerObservable: TimerObservable_2
	};

	var TimerObservable_1 = TimerObservable_1$1;
	var timer_1$1 = TimerObservable_1.TimerObservable.create;


	var timer$2 = {
		timer: timer_1$1
	};

	var Observable_1$52 = Observable_1$2;
	var timer_1 = timer$2;
	Observable_1$52.Observable.timer = timer_1.timer;

	var __extends$39 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ArrayObservable_1$9 = ArrayObservable_1$1;
	var isArray_1$10 = isArray$1;
	var Subscriber_1$8 = Subscriber_1$3;
	var OuterSubscriber_1$10 = OuterSubscriber_1$1;
	var subscribeToResult_1$10 = subscribeToResult_1$1;
	var iterator_1$5 = iterator;
	/* tslint:enable:max-line-length */
	/**
	 * @param observables
	 * @return {Observable<R>}
	 * @method zip
	 * @owner Observable
	 */
	function zipProto() {
	    var observables = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        observables[_i - 0] = arguments[_i];
	    }
	    return this.lift.call(zipStatic.apply(void 0, [this].concat(observables)));
	}
	var zipProto_1 = zipProto;
	/* tslint:enable:max-line-length */
	/**
	 * Combines multiple Observables to create an Observable whose values are calculated from the values, in order, of each
	 * of its input Observables.
	 *
	 * If the latest parameter is a function, this function is used to compute the created value from the input values.
	 * Otherwise, an array of the input values is returned.
	 *
	 * @example <caption>Combine age and name from different sources</caption>
	 *
	 * let age$ = Observable.of<number>(27, 25, 29);
	 * let name$ = Observable.of<string>('Foo', 'Bar', 'Beer');
	 * let isDev$ = Observable.of<boolean>(true, true, false);
	 *
	 * Observable
	 *     .zip(age$,
	 *          name$,
	 *          isDev$,
	 *          (age: number, name: string, isDev: boolean) => ({ age, name, isDev }))
	 *     .subscribe(x => console.log(x));
	 *
	 * // outputs
	 * // { age: 27, name: 'Foo', isDev: true }
	 * // { age: 25, name: 'Bar', isDev: true }
	 * // { age: 29, name: 'Beer', isDev: false }
	 *
	 * @param observables
	 * @return {Observable<R>}
	 * @static true
	 * @name zip
	 * @owner Observable
	 */
	function zipStatic() {
	    var observables = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        observables[_i - 0] = arguments[_i];
	    }
	    var project = observables[observables.length - 1];
	    if (typeof project === 'function') {
	        observables.pop();
	    }
	    return new ArrayObservable_1$9.ArrayObservable(observables).lift(new ZipOperator(project));
	}
	var zipStatic_1 = zipStatic;
	var ZipOperator = (function () {
	    function ZipOperator(project) {
	        this.project = project;
	    }
	    ZipOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new ZipSubscriber(subscriber, this.project));
	    };
	    return ZipOperator;
	}());
	var ZipOperator_1 = ZipOperator;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var ZipSubscriber = (function (_super) {
	    __extends$39(ZipSubscriber, _super);
	    function ZipSubscriber(destination, project, values) {
	        if (values === void 0) { values = Object.create(null); }
	        _super.call(this, destination);
	        this.iterators = [];
	        this.active = 0;
	        this.project = (typeof project === 'function') ? project : null;
	        this.values = values;
	    }
	    ZipSubscriber.prototype._next = function (value) {
	        var iterators = this.iterators;
	        if (isArray_1$10.isArray(value)) {
	            iterators.push(new StaticArrayIterator(value));
	        }
	        else if (typeof value[iterator_1$5.iterator] === 'function') {
	            iterators.push(new StaticIterator(value[iterator_1$5.iterator]()));
	        }
	        else {
	            iterators.push(new ZipBufferIterator(this.destination, this, value));
	        }
	    };
	    ZipSubscriber.prototype._complete = function () {
	        var iterators = this.iterators;
	        var len = iterators.length;
	        if (len === 0) {
	            this.destination.complete();
	            return;
	        }
	        this.active = len;
	        for (var i = 0; i < len; i++) {
	            var iterator$$1 = iterators[i];
	            if (iterator$$1.stillUnsubscribed) {
	                this.add(iterator$$1.subscribe(iterator$$1, i));
	            }
	            else {
	                this.active--; // not an observable
	            }
	        }
	    };
	    ZipSubscriber.prototype.notifyInactive = function () {
	        this.active--;
	        if (this.active === 0) {
	            this.destination.complete();
	        }
	    };
	    ZipSubscriber.prototype.checkIterators = function () {
	        var iterators = this.iterators;
	        var len = iterators.length;
	        var destination = this.destination;
	        // abort if not all of them have values
	        for (var i = 0; i < len; i++) {
	            var iterator$$1 = iterators[i];
	            if (typeof iterator$$1.hasValue === 'function' && !iterator$$1.hasValue()) {
	                return;
	            }
	        }
	        var shouldComplete = false;
	        var args = [];
	        for (var i = 0; i < len; i++) {
	            var iterator$$1 = iterators[i];
	            var result = iterator$$1.next();
	            // check to see if it's completed now that you've gotten
	            // the next value.
	            if (iterator$$1.hasCompleted()) {
	                shouldComplete = true;
	            }
	            if (result.done) {
	                destination.complete();
	                return;
	            }
	            args.push(result.value);
	        }
	        if (this.project) {
	            this._tryProject(args);
	        }
	        else {
	            destination.next(args);
	        }
	        if (shouldComplete) {
	            destination.complete();
	        }
	    };
	    ZipSubscriber.prototype._tryProject = function (args) {
	        var result;
	        try {
	            result = this.project.apply(this, args);
	        }
	        catch (err) {
	            this.destination.error(err);
	            return;
	        }
	        this.destination.next(result);
	    };
	    return ZipSubscriber;
	}(Subscriber_1$8.Subscriber));
	var ZipSubscriber_1 = ZipSubscriber;
	var StaticIterator = (function () {
	    function StaticIterator(iterator$$1) {
	        this.iterator = iterator$$1;
	        this.nextResult = iterator$$1.next();
	    }
	    StaticIterator.prototype.hasValue = function () {
	        return true;
	    };
	    StaticIterator.prototype.next = function () {
	        var result = this.nextResult;
	        this.nextResult = this.iterator.next();
	        return result;
	    };
	    StaticIterator.prototype.hasCompleted = function () {
	        var nextResult = this.nextResult;
	        return nextResult && nextResult.done;
	    };
	    return StaticIterator;
	}());
	var StaticArrayIterator = (function () {
	    function StaticArrayIterator(array) {
	        this.array = array;
	        this.index = 0;
	        this.length = 0;
	        this.length = array.length;
	    }
	    StaticArrayIterator.prototype[iterator_1$5.iterator] = function () {
	        return this;
	    };
	    StaticArrayIterator.prototype.next = function (value) {
	        var i = this.index++;
	        var array = this.array;
	        return i < this.length ? { value: array[i], done: false } : { value: null, done: true };
	    };
	    StaticArrayIterator.prototype.hasValue = function () {
	        return this.array.length > this.index;
	    };
	    StaticArrayIterator.prototype.hasCompleted = function () {
	        return this.array.length === this.index;
	    };
	    return StaticArrayIterator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var ZipBufferIterator = (function (_super) {
	    __extends$39(ZipBufferIterator, _super);
	    function ZipBufferIterator(destination, parent, observable) {
	        _super.call(this, destination);
	        this.parent = parent;
	        this.observable = observable;
	        this.stillUnsubscribed = true;
	        this.buffer = [];
	        this.isComplete = false;
	    }
	    ZipBufferIterator.prototype[iterator_1$5.iterator] = function () {
	        return this;
	    };
	    // NOTE: there is actually a name collision here with Subscriber.next and Iterator.next
	    //    this is legit because `next()` will never be called by a subscription in this case.
	    ZipBufferIterator.prototype.next = function () {
	        var buffer = this.buffer;
	        if (buffer.length === 0 && this.isComplete) {
	            return { value: null, done: true };
	        }
	        else {
	            return { value: buffer.shift(), done: false };
	        }
	    };
	    ZipBufferIterator.prototype.hasValue = function () {
	        return this.buffer.length > 0;
	    };
	    ZipBufferIterator.prototype.hasCompleted = function () {
	        return this.buffer.length === 0 && this.isComplete;
	    };
	    ZipBufferIterator.prototype.notifyComplete = function () {
	        if (this.buffer.length > 0) {
	            this.isComplete = true;
	            this.parent.notifyInactive();
	        }
	        else {
	            this.destination.complete();
	        }
	    };
	    ZipBufferIterator.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        this.buffer.push(innerValue);
	        this.parent.checkIterators();
	    };
	    ZipBufferIterator.prototype.subscribe = function (value, index) {
	        return subscribeToResult_1$10.subscribeToResult(this, this.observable, this, index);
	    };
	    return ZipBufferIterator;
	}(OuterSubscriber_1$10.OuterSubscriber));


	var zip$5 = {
		zipProto: zipProto_1,
		zipStatic: zipStatic_1,
		ZipOperator: ZipOperator_1,
		ZipSubscriber: ZipSubscriber_1
	};

	var zip_1$2 = zip$5;
	var zip_2 = zip_1$2.zipStatic;


	var zip$3 = {
		zip: zip_2
	};

	var Observable_1$54 = Observable_1$2;
	var zip_1$1 = zip$3;
	Observable_1$54.Observable.zip = zip_1$1.zip;

	var __extends$41 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1$10 = Subscriber_1$3;
	/**
	 * Applies a given `project` function to each value emitted by the source
	 * Observable, and emits the resulting values as an Observable.
	 *
	 * <span class="informal">Like [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map),
	 * it passes each source value through a transformation function to get
	 * corresponding output values.</span>
	 *
	 * <img src="./img/map.png" width="100%">
	 *
	 * Similar to the well known `Array.prototype.map` function, this operator
	 * applies a projection to each value and emits that projection in the output
	 * Observable.
	 *
	 * @example <caption>Map every click to the clientX position of that click</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var positions = clicks.map(ev => ev.clientX);
	 * positions.subscribe(x => console.log(x));
	 *
	 * @see {@link mapTo}
	 * @see {@link pluck}
	 *
	 * @param {function(value: T, index: number): R} project The function to apply
	 * to each `value` emitted by the source Observable. The `index` parameter is
	 * the number `i` for the i-th emission that has happened since the
	 * subscription, starting from the number `0`.
	 * @param {any} [thisArg] An optional argument to define what `this` is in the
	 * `project` function.
	 * @return {Observable<R>} An Observable that emits the values from the source
	 * Observable transformed by the given `project` function.
	 * @method map
	 * @owner Observable
	 */
	function map$2(project, thisArg) {
	    if (typeof project !== 'function') {
	        throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');
	    }
	    return this.lift(new MapOperator(project, thisArg));
	}
	var map_2 = map$2;
	var MapOperator = (function () {
	    function MapOperator(project, thisArg) {
	        this.project = project;
	        this.thisArg = thisArg;
	    }
	    MapOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));
	    };
	    return MapOperator;
	}());
	var MapOperator_1 = MapOperator;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var MapSubscriber = (function (_super) {
	    __extends$41(MapSubscriber, _super);
	    function MapSubscriber(destination, project, thisArg) {
	        _super.call(this, destination);
	        this.project = project;
	        this.count = 0;
	        this.thisArg = thisArg || this;
	    }
	    // NOTE: This looks unoptimized, but it's actually purposefully NOT
	    // using try/catch optimizations.
	    MapSubscriber.prototype._next = function (value) {
	        var result;
	        try {
	            result = this.project.call(this.thisArg, value, this.count++);
	        }
	        catch (err) {
	            this.destination.error(err);
	            return;
	        }
	        this.destination.next(result);
	    };
	    return MapSubscriber;
	}(Subscriber_1$10.Subscriber));


	var map_1$2 = {
		map: map_2,
		MapOperator: MapOperator_1
	};

	var __extends$40 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var root_1$6 = root$1;
	var tryCatch_1$6 = tryCatch_1$1;
	var errorObject_1$6 = errorObject;
	var Observable_1$56 = Observable_1$2;
	var Subscriber_1$9 = Subscriber_1$3;
	var map_1$1 = map_1$2;
	function getCORSRequest() {
	    if (root_1$6.root.XMLHttpRequest) {
	        return new root_1$6.root.XMLHttpRequest();
	    }
	    else if (!!root_1$6.root.XDomainRequest) {
	        return new root_1$6.root.XDomainRequest();
	    }
	    else {
	        throw new Error('CORS is not supported by your browser');
	    }
	}
	function getXMLHttpRequest() {
	    if (root_1$6.root.XMLHttpRequest) {
	        return new root_1$6.root.XMLHttpRequest();
	    }
	    else {
	        var progId = void 0;
	        try {
	            var progIds = ['Msxml2.XMLHTTP', 'Microsoft.XMLHTTP', 'Msxml2.XMLHTTP.4.0'];
	            for (var i = 0; i < 3; i++) {
	                try {
	                    progId = progIds[i];
	                    if (new root_1$6.root.ActiveXObject(progId)) {
	                        break;
	                    }
	                }
	                catch (e) {
	                }
	            }
	            return new root_1$6.root.ActiveXObject(progId);
	        }
	        catch (e) {
	            throw new Error('XMLHttpRequest is not supported by your browser');
	        }
	    }
	}
	function ajaxGet(url, headers) {
	    if (headers === void 0) { headers = null; }
	    return new AjaxObservable({ method: 'GET', url: url, headers: headers });
	}
	var ajaxGet_1 = ajaxGet;

	function ajaxPost(url, body, headers) {
	    return new AjaxObservable({ method: 'POST', url: url, body: body, headers: headers });
	}
	var ajaxPost_1 = ajaxPost;

	function ajaxDelete(url, headers) {
	    return new AjaxObservable({ method: 'DELETE', url: url, headers: headers });
	}
	var ajaxDelete_1 = ajaxDelete;

	function ajaxPut(url, body, headers) {
	    return new AjaxObservable({ method: 'PUT', url: url, body: body, headers: headers });
	}
	var ajaxPut_1 = ajaxPut;

	function ajaxPatch(url, body, headers) {
	    return new AjaxObservable({ method: 'PATCH', url: url, body: body, headers: headers });
	}
	var ajaxPatch_1 = ajaxPatch;

	function ajaxGetJSON(url, headers) {
	    return new AjaxObservable({ method: 'GET', url: url, responseType: 'json', headers: headers })
	        .lift(new map_1$1.MapOperator(function (x, index) { return x.response; }, null));
	}
	var ajaxGetJSON_1 = ajaxGetJSON;

	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var AjaxObservable = (function (_super) {
	    __extends$40(AjaxObservable, _super);
	    function AjaxObservable(urlOrRequest) {
	        _super.call(this);
	        var request = {
	            async: true,
	            createXHR: function () {
	                return this.crossDomain ? getCORSRequest.call(this) : getXMLHttpRequest();
	            },
	            crossDomain: false,
	            withCredentials: false,
	            headers: {},
	            method: 'GET',
	            responseType: 'json',
	            timeout: 0
	        };
	        if (typeof urlOrRequest === 'string') {
	            request.url = urlOrRequest;
	        }
	        else {
	            for (var prop in urlOrRequest) {
	                if (urlOrRequest.hasOwnProperty(prop)) {
	                    request[prop] = urlOrRequest[prop];
	                }
	            }
	        }
	        this.request = request;
	    }
	    AjaxObservable.prototype._subscribe = function (subscriber) {
	        return new AjaxSubscriber(subscriber, this.request);
	    };
	    /**
	     * Creates an observable for an Ajax request with either a request object with
	     * url, headers, etc or a string for a URL.
	     *
	     * @example
	     * source = Rx.Observable.ajax('/products');
	     * source = Rx.Observable.ajax({ url: 'products', method: 'GET' });
	     *
	     * @param {string|Object} request Can be one of the following:
	     *   A string of the URL to make the Ajax call.
	     *   An object with the following properties
	     *   - url: URL of the request
	     *   - body: The body of the request
	     *   - method: Method of the request, such as GET, POST, PUT, PATCH, DELETE
	     *   - async: Whether the request is async
	     *   - headers: Optional headers
	     *   - crossDomain: true if a cross domain request, else false
	     *   - createXHR: a function to override if you need to use an alternate
	     *   XMLHttpRequest implementation.
	     *   - resultSelector: a function to use to alter the output value type of
	     *   the Observable. Gets {@link AjaxResponse} as an argument.
	     * @return {Observable} An observable sequence containing the XMLHttpRequest.
	     * @static true
	     * @name ajax
	     * @owner Observable
	    */
	    AjaxObservable.create = (function () {
	        var create = function (urlOrRequest) {
	            return new AjaxObservable(urlOrRequest);
	        };
	        create.get = ajaxGet;
	        create.post = ajaxPost;
	        create.delete = ajaxDelete;
	        create.put = ajaxPut;
	        create.patch = ajaxPatch;
	        create.getJSON = ajaxGetJSON;
	        return create;
	    })();
	    return AjaxObservable;
	}(Observable_1$56.Observable));
	var AjaxObservable_2 = AjaxObservable;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var AjaxSubscriber = (function (_super) {
	    __extends$40(AjaxSubscriber, _super);
	    function AjaxSubscriber(destination, request) {
	        _super.call(this, destination);
	        this.request = request;
	        this.done = false;
	        var headers = request.headers = request.headers || {};
	        // force CORS if requested
	        if (!request.crossDomain && !headers['X-Requested-With']) {
	            headers['X-Requested-With'] = 'XMLHttpRequest';
	        }
	        // ensure content type is set
	        if (!('Content-Type' in headers) && !(root_1$6.root.FormData && request.body instanceof root_1$6.root.FormData) && typeof request.body !== 'undefined') {
	            headers['Content-Type'] = 'application/x-www-form-urlencoded; charset=UTF-8';
	        }
	        // properly serialize body
	        request.body = this.serializeBody(request.body, request.headers['Content-Type']);
	        this.send();
	    }
	    AjaxSubscriber.prototype.next = function (e) {
	        this.done = true;
	        var _a = this, xhr = _a.xhr, request = _a.request, destination = _a.destination;
	        var response = new AjaxResponse$1(e, xhr, request);
	        destination.next(response);
	    };
	    AjaxSubscriber.prototype.send = function () {
	        var _a = this, request = _a.request, _b = _a.request, user = _b.user, method = _b.method, url = _b.url, async = _b.async, password = _b.password, headers = _b.headers, body = _b.body;
	        var createXHR = request.createXHR;
	        var xhr = tryCatch_1$6.tryCatch(createXHR).call(request);
	        if (xhr === errorObject_1$6.errorObject) {
	            this.error(errorObject_1$6.errorObject.e);
	        }
	        else {
	            this.xhr = xhr;
	            // set up the events before open XHR
	            // https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest
	            // You need to add the event listeners before calling open() on the request.
	            // Otherwise the progress events will not fire.
	            this.setupEvents(xhr, request);
	            // open XHR
	            var result = void 0;
	            if (user) {
	                result = tryCatch_1$6.tryCatch(xhr.open).call(xhr, method, url, async, user, password);
	            }
	            else {
	                result = tryCatch_1$6.tryCatch(xhr.open).call(xhr, method, url, async);
	            }
	            if (result === errorObject_1$6.errorObject) {
	                this.error(errorObject_1$6.errorObject.e);
	                return null;
	            }
	            // timeout, responseType and withCredentials can be set once the XHR is open
	            xhr.timeout = request.timeout;
	            xhr.responseType = request.responseType;
	            if ('withCredentials' in xhr) {
	                xhr.withCredentials = !!request.withCredentials;
	            }
	            // set headers
	            this.setHeaders(xhr, headers);
	            // finally send the request
	            result = body ? tryCatch_1$6.tryCatch(xhr.send).call(xhr, body) : tryCatch_1$6.tryCatch(xhr.send).call(xhr);
	            if (result === errorObject_1$6.errorObject) {
	                this.error(errorObject_1$6.errorObject.e);
	                return null;
	            }
	        }
	        return xhr;
	    };
	    AjaxSubscriber.prototype.serializeBody = function (body, contentType) {
	        if (!body || typeof body === 'string') {
	            return body;
	        }
	        else if (root_1$6.root.FormData && body instanceof root_1$6.root.FormData) {
	            return body;
	        }
	        if (contentType) {
	            var splitIndex = contentType.indexOf(';');
	            if (splitIndex !== -1) {
	                contentType = contentType.substring(0, splitIndex);
	            }
	        }
	        switch (contentType) {
	            case 'application/x-www-form-urlencoded':
	                return Object.keys(body).map(function (key) { return (encodeURI(key) + "=" + encodeURI(body[key])); }).join('&');
	            case 'application/json':
	                return JSON.stringify(body);
	            default:
	                return body;
	        }
	    };
	    AjaxSubscriber.prototype.setHeaders = function (xhr, headers) {
	        for (var key in headers) {
	            if (headers.hasOwnProperty(key)) {
	                xhr.setRequestHeader(key, headers[key]);
	            }
	        }
	    };
	    AjaxSubscriber.prototype.setupEvents = function (xhr, request) {
	        var progressSubscriber = request.progressSubscriber;
	        function xhrTimeout(e) {
	            var _a = xhrTimeout, subscriber = _a.subscriber, progressSubscriber = _a.progressSubscriber, request = _a.request;
	            if (progressSubscriber) {
	                progressSubscriber.error(e);
	            }
	            subscriber.error(new AjaxTimeoutError$1(this, request)); //TODO: Make betterer.
	        }
	        
	        xhr.ontimeout = xhrTimeout;
	        xhrTimeout.request = request;
	        xhrTimeout.subscriber = this;
	        xhrTimeout.progressSubscriber = progressSubscriber;
	        if (xhr.upload && 'withCredentials' in xhr) {
	            if (progressSubscriber) {
	                var xhrProgress_1;
	                xhrProgress_1 = function (e) {
	                    var progressSubscriber = xhrProgress_1.progressSubscriber;
	                    progressSubscriber.next(e);
	                };
	                if (root_1$6.root.XDomainRequest) {
	                    xhr.onprogress = xhrProgress_1;
	                }
	                else {
	                    xhr.upload.onprogress = xhrProgress_1;
	                }
	                xhrProgress_1.progressSubscriber = progressSubscriber;
	            }
	            var xhrError_1;
	            xhrError_1 = function (e) {
	                var _a = xhrError_1, progressSubscriber = _a.progressSubscriber, subscriber = _a.subscriber, request = _a.request;
	                if (progressSubscriber) {
	                    progressSubscriber.error(e);
	                }
	                subscriber.error(new AjaxError$1('ajax error', this, request));
	            };
	            xhr.onerror = xhrError_1;
	            xhrError_1.request = request;
	            xhrError_1.subscriber = this;
	            xhrError_1.progressSubscriber = progressSubscriber;
	        }
	        function xhrReadyStateChange(e) {
	            var _a = xhrReadyStateChange, subscriber = _a.subscriber, progressSubscriber = _a.progressSubscriber, request = _a.request;
	            if (this.readyState === 4) {
	                // normalize IE9 bug (http://bugs.jquery.com/ticket/1450)
	                var status_1 = this.status === 1223 ? 204 : this.status;
	                var response = (this.responseType === 'text' ? (this.response || this.responseText) : this.response);
	                // fix status code when it is 0 (0 status is undocumented).
	                // Occurs when accessing file resources or on Android 4.1 stock browser
	                // while retrieving files from application cache.
	                if (status_1 === 0) {
	                    status_1 = response ? 200 : 0;
	                }
	                if (200 <= status_1 && status_1 < 300) {
	                    if (progressSubscriber) {
	                        progressSubscriber.complete();
	                    }
	                    subscriber.next(e);
	                    subscriber.complete();
	                }
	                else {
	                    if (progressSubscriber) {
	                        progressSubscriber.error(e);
	                    }
	                    subscriber.error(new AjaxError$1('ajax error ' + status_1, this, request));
	                }
	            }
	        }
	        
	        xhr.onreadystatechange = xhrReadyStateChange;
	        xhrReadyStateChange.subscriber = this;
	        xhrReadyStateChange.progressSubscriber = progressSubscriber;
	        xhrReadyStateChange.request = request;
	    };
	    AjaxSubscriber.prototype.unsubscribe = function () {
	        var _a = this, done = _a.done, xhr = _a.xhr;
	        if (!done && xhr && xhr.readyState !== 4 && typeof xhr.abort === 'function') {
	            xhr.abort();
	        }
	        _super.prototype.unsubscribe.call(this);
	    };
	    return AjaxSubscriber;
	}(Subscriber_1$9.Subscriber));
	var AjaxSubscriber_1 = AjaxSubscriber;
	/**
	 * A normalized AJAX response.
	 *
	 * @see {@link ajax}
	 *
	 * @class AjaxResponse
	 */
	var AjaxResponse$1 = (function () {
	    function AjaxResponse(originalEvent, xhr, request) {
	        this.originalEvent = originalEvent;
	        this.xhr = xhr;
	        this.request = request;
	        this.status = xhr.status;
	        this.responseType = xhr.responseType || request.responseType;
	        switch (this.responseType) {
	            case 'json':
	                if ('response' in xhr) {
	                    //IE does not support json as responseType, parse it internally
	                    this.response = xhr.responseType ? xhr.response : JSON.parse(xhr.response || xhr.responseText || 'null');
	                }
	                else {
	                    this.response = JSON.parse(xhr.responseText || 'null');
	                }
	                break;
	            case 'xml':
	                this.response = xhr.responseXML;
	                break;
	            case 'text':
	            default:
	                this.response = ('response' in xhr) ? xhr.response : xhr.responseText;
	                break;
	        }
	    }
	    return AjaxResponse;
	}());
	var AjaxResponse_1 = AjaxResponse$1;
	/**
	 * A normalized AJAX error.
	 *
	 * @see {@link ajax}
	 *
	 * @class AjaxError
	 */
	var AjaxError$1 = (function (_super) {
	    __extends$40(AjaxError, _super);
	    function AjaxError(message, xhr, request) {
	        _super.call(this, message);
	        this.message = message;
	        this.xhr = xhr;
	        this.request = request;
	        this.status = xhr.status;
	    }
	    return AjaxError;
	}(Error));
	var AjaxError_1 = AjaxError$1;
	/**
	 * @see {@link ajax}
	 *
	 * @class AjaxTimeoutError
	 */
	var AjaxTimeoutError$1 = (function (_super) {
	    __extends$40(AjaxTimeoutError, _super);
	    function AjaxTimeoutError(xhr, request) {
	        _super.call(this, 'ajax timeout', xhr, request);
	    }
	    return AjaxTimeoutError;
	}(AjaxError$1));
	var AjaxTimeoutError_1 = AjaxTimeoutError$1;


	var AjaxObservable_1$2 = {
		ajaxGet: ajaxGet_1,
		ajaxPost: ajaxPost_1,
		ajaxDelete: ajaxDelete_1,
		ajaxPut: ajaxPut_1,
		ajaxPatch: ajaxPatch_1,
		ajaxGetJSON: ajaxGetJSON_1,
		AjaxObservable: AjaxObservable_2,
		AjaxSubscriber: AjaxSubscriber_1,
		AjaxResponse: AjaxResponse_1,
		AjaxError: AjaxError_1,
		AjaxTimeoutError: AjaxTimeoutError_1
	};

	var AjaxObservable_1$1 = AjaxObservable_1$2;
	var ajax_1$1 = AjaxObservable_1$1.AjaxObservable.create;


	var ajax$2 = {
		ajax: ajax_1$1
	};

	var Observable_1$55 = Observable_1$2;
	var ajax_1 = ajax$2;
	Observable_1$55.Observable.ajax = ajax_1.ajax;

	var __extends$44 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AsyncAction_1$3 = AsyncAction_1$1;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var QueueAction = (function (_super) {
	    __extends$44(QueueAction, _super);
	    function QueueAction(scheduler, work) {
	        _super.call(this, scheduler, work);
	        this.scheduler = scheduler;
	        this.work = work;
	    }
	    QueueAction.prototype.schedule = function (state, delay) {
	        if (delay === void 0) { delay = 0; }
	        if (delay > 0) {
	            return _super.prototype.schedule.call(this, state, delay);
	        }
	        this.delay = delay;
	        this.state = state;
	        this.scheduler.flush(this);
	        return this;
	    };
	    QueueAction.prototype.execute = function (state, delay) {
	        return (delay > 0 || this.closed) ?
	            _super.prototype.execute.call(this, state, delay) :
	            this._execute(state, delay);
	    };
	    QueueAction.prototype.requestAsyncId = function (scheduler, id, delay) {
	        if (delay === void 0) { delay = 0; }
	        // If delay exists and is greater than 0, or if the delay is null (the
	        // action wasn't rescheduled) but was originally scheduled as an async
	        // action, then recycle as an async action.
	        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
	            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
	        }
	        // Otherwise flush the scheduler starting with this action.
	        return scheduler.flush(this);
	    };
	    return QueueAction;
	}(AsyncAction_1$3.AsyncAction));
	var QueueAction_2 = QueueAction;


	var QueueAction_1$1 = {
		QueueAction: QueueAction_2
	};

	var __extends$45 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AsyncScheduler_1$3 = AsyncScheduler_1$1;
	var QueueScheduler = (function (_super) {
	    __extends$45(QueueScheduler, _super);
	    function QueueScheduler() {
	        _super.apply(this, arguments);
	    }
	    return QueueScheduler;
	}(AsyncScheduler_1$3.AsyncScheduler));
	var QueueScheduler_2 = QueueScheduler;


	var QueueScheduler_1$1 = {
		QueueScheduler: QueueScheduler_2
	};

	var QueueAction_1 = QueueAction_1$1;
	var QueueScheduler_1 = QueueScheduler_1$1;
	/**
	 *
	 * Queue Scheduler
	 *
	 * <span class="informal">Put every next task on a queue, instead of executing it immediately</span>
	 *
	 * `queue` scheduler, when used with delay, behaves the same as {@link async} scheduler.
	 *
	 * When used without delay, it schedules given task synchronously - executes it right when
	 * it is scheduled. However when called recursively, that is when inside the scheduled task,
	 * another task is scheduled with queue scheduler, instead of executing immediately as well,
	 * that task will be put on a queue and wait for current one to finish.
	 *
	 * This means that when you execute task with `queue` scheduler, you are sure it will end
	 * before any other task scheduled with that scheduler will start.
	 *
	 * @examples <caption>Schedule recursively first, then do something</caption>
	 *
	 * Rx.Scheduler.queue.schedule(() => {
	 *   Rx.Scheduler.queue.schedule(() => console.log('second')); // will not happen now, but will be put on a queue
	 *
	 *   console.log('first');
	 * });
	 *
	 * // Logs:
	 * // "first"
	 * // "second"
	 *
	 *
	 * @example <caption>Reschedule itself recursively</caption>
	 *
	 * Rx.Scheduler.queue.schedule(function(state) {
	 *   if (state !== 0) {
	 *     console.log('before', state);
	 *     this.schedule(state - 1); // `this` references currently executing Action,
	 *                               // which we reschedule with new state
	 *     console.log('after', state);
	 *   }
	 * }, 0, 3);
	 *
	 * // In scheduler that runs recursively, you would expect:
	 * // "before", 3
	 * // "before", 2
	 * // "before", 1
	 * // "after", 1
	 * // "after", 2
	 * // "after", 3
	 *
	 * // But with queue it logs:
	 * // "before", 3
	 * // "after", 3
	 * // "before", 2
	 * // "after", 2
	 * // "before", 1
	 * // "after", 1
	 *
	 *
	 * @static true
	 * @name queue
	 * @owner Scheduler
	 */
	var queue_1$2 = new QueueScheduler_1.QueueScheduler(QueueAction_1.QueueAction);


	var queue = {
		queue: queue_1$2
	};

	var __extends$43 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subject_1$5 = Subject_1$1;
	var queue_1$1 = queue;
	var Subscription_1$11 = Subscription_1$3;
	var observeOn_1$3 = observeOn_1$1;
	var ObjectUnsubscribedError_1$4 = ObjectUnsubscribedError_1$2;
	var SubjectSubscription_1$3 = SubjectSubscription_1$1;
	/**
	 * @class ReplaySubject<T>
	 */
	var ReplaySubject$1 = (function (_super) {
	    __extends$43(ReplaySubject, _super);
	    function ReplaySubject(bufferSize, windowTime, scheduler) {
	        if (bufferSize === void 0) { bufferSize = Number.POSITIVE_INFINITY; }
	        if (windowTime === void 0) { windowTime = Number.POSITIVE_INFINITY; }
	        _super.call(this);
	        this.scheduler = scheduler;
	        this._events = [];
	        this._bufferSize = bufferSize < 1 ? 1 : bufferSize;
	        this._windowTime = windowTime < 1 ? 1 : windowTime;
	    }
	    ReplaySubject.prototype.next = function (value) {
	        var now = this._getNow();
	        this._events.push(new ReplayEvent(now, value));
	        this._trimBufferThenGetEvents();
	        _super.prototype.next.call(this, value);
	    };
	    ReplaySubject.prototype._subscribe = function (subscriber) {
	        var _events = this._trimBufferThenGetEvents();
	        var scheduler = this.scheduler;
	        var subscription;
	        if (this.closed) {
	            throw new ObjectUnsubscribedError_1$4.ObjectUnsubscribedError();
	        }
	        else if (this.hasError) {
	            subscription = Subscription_1$11.Subscription.EMPTY;
	        }
	        else if (this.isStopped) {
	            subscription = Subscription_1$11.Subscription.EMPTY;
	        }
	        else {
	            this.observers.push(subscriber);
	            subscription = new SubjectSubscription_1$3.SubjectSubscription(this, subscriber);
	        }
	        if (scheduler) {
	            subscriber.add(subscriber = new observeOn_1$3.ObserveOnSubscriber(subscriber, scheduler));
	        }
	        var len = _events.length;
	        for (var i = 0; i < len && !subscriber.closed; i++) {
	            subscriber.next(_events[i].value);
	        }
	        if (this.hasError) {
	            subscriber.error(this.thrownError);
	        }
	        else if (this.isStopped) {
	            subscriber.complete();
	        }
	        return subscription;
	    };
	    ReplaySubject.prototype._getNow = function () {
	        return (this.scheduler || queue_1$1.queue).now();
	    };
	    ReplaySubject.prototype._trimBufferThenGetEvents = function () {
	        var now = this._getNow();
	        var _bufferSize = this._bufferSize;
	        var _windowTime = this._windowTime;
	        var _events = this._events;
	        var eventsCount = _events.length;
	        var spliceCount = 0;
	        // Trim events that fall out of the time window.
	        // Start at the front of the list. Break early once
	        // we encounter an event that falls within the window.
	        while (spliceCount < eventsCount) {
	            if ((now - _events[spliceCount].time) < _windowTime) {
	                break;
	            }
	            spliceCount++;
	        }
	        if (eventsCount > _bufferSize) {
	            spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);
	        }
	        if (spliceCount > 0) {
	            _events.splice(0, spliceCount);
	        }
	        return _events;
	    };
	    return ReplaySubject;
	}(Subject_1$5.Subject));
	var ReplaySubject_2 = ReplaySubject$1;
	var ReplayEvent = (function () {
	    function ReplayEvent(time, value) {
	        this.time = time;
	        this.value = value;
	    }
	    return ReplayEvent;
	}());


	var ReplaySubject_1$2 = {
		ReplaySubject: ReplaySubject_2
	};

	var root_1$8 = root$1;
	function assignImpl(target) {
	    var sources = [];
	    for (var _i = 1; _i < arguments.length; _i++) {
	        sources[_i - 1] = arguments[_i];
	    }
	    var len = sources.length;
	    for (var i = 0; i < len; i++) {
	        var source = sources[i];
	        for (var k in source) {
	            if (source.hasOwnProperty(k)) {
	                target[k] = source[k];
	            }
	        }
	    }
	    return target;
	}
	var assignImpl_1 = assignImpl;

	function getAssign(root) {
	    return root.Object.assign || assignImpl;
	}
	var getAssign_1 = getAssign;
	var assign_1$2 = getAssign(root_1$8.root);


	var assign$1 = {
		assignImpl: assignImpl_1,
		getAssign: getAssign_1,
		assign: assign_1$2
	};

	var __extends$42 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subject_1$4 = Subject_1$1;
	var Subscriber_1$11 = Subscriber_1$3;
	var Observable_1$58 = Observable_1$2;
	var Subscription_1$10 = Subscription_1$3;
	var root_1$7 = root$1;
	var ReplaySubject_1$1 = ReplaySubject_1$2;
	var tryCatch_1$7 = tryCatch_1$1;
	var errorObject_1$7 = errorObject;
	var assign_1$1 = assign$1;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var WebSocketSubject = (function (_super) {
	    __extends$42(WebSocketSubject, _super);
	    function WebSocketSubject(urlConfigOrSource, destination) {
	        if (urlConfigOrSource instanceof Observable_1$58.Observable) {
	            _super.call(this, destination, urlConfigOrSource);
	        }
	        else {
	            _super.call(this);
	            this.WebSocketCtor = root_1$7.root.WebSocket;
	            this._output = new Subject_1$4.Subject();
	            if (typeof urlConfigOrSource === 'string') {
	                this.url = urlConfigOrSource;
	            }
	            else {
	                // WARNING: config object could override important members here.
	                assign_1$1.assign(this, urlConfigOrSource);
	            }
	            if (!this.WebSocketCtor) {
	                throw new Error('no WebSocket constructor can be found');
	            }
	            this.destination = new ReplaySubject_1$1.ReplaySubject();
	        }
	    }
	    WebSocketSubject.prototype.resultSelector = function (e) {
	        return JSON.parse(e.data);
	    };
	    /**
	     * Wrapper around the w3c-compatible WebSocket object provided by the browser.
	     *
	     * @example <caption>Wraps browser WebSocket</caption>
	     *
	     * let socket$ = Observable.webSocket('ws://localhost:8081');
	     *
	     * socket$.subscribe(
	     *    (msg) => console.log('message received: ' + msg),
	     *    (err) => console.log(err),
	     *    () => console.log('complete')
	     *  );
	     *
	     * socket$.next(JSON.stringify({ op: 'hello' }));
	     *
	     * @example <caption>Wraps WebSocket from nodejs-websocket (using node.js)</caption>
	     *
	     * import { w3cwebsocket } from 'websocket';
	     *
	     * let socket$ = Observable.webSocket({
	     *   url: 'ws://localhost:8081',
	     *   WebSocketCtor: w3cwebsocket
	     * });
	     *
	     * socket$.subscribe(
	     *    (msg) => console.log('message received: ' + msg),
	     *    (err) => console.log(err),
	     *    () => console.log('complete')
	     *  );
	     *
	     * socket$.next(JSON.stringify({ op: 'hello' }));
	     *
	     * @param {string | WebSocketSubjectConfig} urlConfigOrSource the source of the websocket as an url or a structure defining the websocket object
	     * @return {WebSocketSubject}
	     * @static true
	     * @name webSocket
	     * @owner Observable
	     */
	    WebSocketSubject.create = function (urlConfigOrSource) {
	        return new WebSocketSubject(urlConfigOrSource);
	    };
	    WebSocketSubject.prototype.lift = function (operator) {
	        var sock = new WebSocketSubject(this, this.destination);
	        sock.operator = operator;
	        return sock;
	    };
	    WebSocketSubject.prototype._resetState = function () {
	        this.socket = null;
	        if (!this.source) {
	            this.destination = new ReplaySubject_1$1.ReplaySubject();
	        }
	        this._output = new Subject_1$4.Subject();
	    };
	    // TODO: factor this out to be a proper Operator/Subscriber implementation and eliminate closures
	    WebSocketSubject.prototype.multiplex = function (subMsg, unsubMsg, messageFilter) {
	        var self = this;
	        return new Observable_1$58.Observable(function (observer) {
	            var result = tryCatch_1$7.tryCatch(subMsg)();
	            if (result === errorObject_1$7.errorObject) {
	                observer.error(errorObject_1$7.errorObject.e);
	            }
	            else {
	                self.next(result);
	            }
	            var subscription = self.subscribe(function (x) {
	                var result = tryCatch_1$7.tryCatch(messageFilter)(x);
	                if (result === errorObject_1$7.errorObject) {
	                    observer.error(errorObject_1$7.errorObject.e);
	                }
	                else if (result) {
	                    observer.next(x);
	                }
	            }, function (err) { return observer.error(err); }, function () { return observer.complete(); });
	            return function () {
	                var result = tryCatch_1$7.tryCatch(unsubMsg)();
	                if (result === errorObject_1$7.errorObject) {
	                    observer.error(errorObject_1$7.errorObject.e);
	                }
	                else {
	                    self.next(result);
	                }
	                subscription.unsubscribe();
	            };
	        });
	    };
	    WebSocketSubject.prototype._connectSocket = function () {
	        var _this = this;
	        var WebSocketCtor = this.WebSocketCtor;
	        var observer = this._output;
	        var socket = null;
	        try {
	            socket = this.protocol ?
	                new WebSocketCtor(this.url, this.protocol) :
	                new WebSocketCtor(this.url);
	            this.socket = socket;
	            if (this.binaryType) {
	                this.socket.binaryType = this.binaryType;
	            }
	        }
	        catch (e) {
	            observer.error(e);
	            return;
	        }
	        var subscription = new Subscription_1$10.Subscription(function () {
	            _this.socket = null;
	            if (socket && socket.readyState === 1) {
	                socket.close();
	            }
	        });
	        socket.onopen = function (e) {
	            var openObserver = _this.openObserver;
	            if (openObserver) {
	                openObserver.next(e);
	            }
	            var queue = _this.destination;
	            _this.destination = Subscriber_1$11.Subscriber.create(function (x) { return socket.readyState === 1 && socket.send(x); }, function (e) {
	                var closingObserver = _this.closingObserver;
	                if (closingObserver) {
	                    closingObserver.next(undefined);
	                }
	                if (e && e.code) {
	                    socket.close(e.code, e.reason);
	                }
	                else {
	                    observer.error(new TypeError('WebSocketSubject.error must be called with an object with an error code, ' +
	                        'and an optional reason: { code: number, reason: string }'));
	                }
	                _this._resetState();
	            }, function () {
	                var closingObserver = _this.closingObserver;
	                if (closingObserver) {
	                    closingObserver.next(undefined);
	                }
	                socket.close();
	                _this._resetState();
	            });
	            if (queue && queue instanceof ReplaySubject_1$1.ReplaySubject) {
	                subscription.add(queue.subscribe(_this.destination));
	            }
	        };
	        socket.onerror = function (e) {
	            _this._resetState();
	            observer.error(e);
	        };
	        socket.onclose = function (e) {
	            _this._resetState();
	            var closeObserver = _this.closeObserver;
	            if (closeObserver) {
	                closeObserver.next(e);
	            }
	            if (e.wasClean) {
	                observer.complete();
	            }
	            else {
	                observer.error(e);
	            }
	        };
	        socket.onmessage = function (e) {
	            var result = tryCatch_1$7.tryCatch(_this.resultSelector)(e);
	            if (result === errorObject_1$7.errorObject) {
	                observer.error(errorObject_1$7.errorObject.e);
	            }
	            else {
	                observer.next(result);
	            }
	        };
	    };
	    WebSocketSubject.prototype._subscribe = function (subscriber) {
	        var _this = this;
	        var source = this.source;
	        if (source) {
	            return source.subscribe(subscriber);
	        }
	        if (!this.socket) {
	            this._connectSocket();
	        }
	        var subscription = new Subscription_1$10.Subscription();
	        subscription.add(this._output.subscribe(subscriber));
	        subscription.add(function () {
	            var socket = _this.socket;
	            if (_this._output.observers.length === 0) {
	                if (socket && socket.readyState === 1) {
	                    socket.close();
	                }
	                _this._resetState();
	            }
	        });
	        return subscription;
	    };
	    WebSocketSubject.prototype.unsubscribe = function () {
	        var _a = this, source = _a.source, socket = _a.socket;
	        if (socket && socket.readyState === 1) {
	            socket.close();
	            this._resetState();
	        }
	        _super.prototype.unsubscribe.call(this);
	        if (!source) {
	            this.destination = new ReplaySubject_1$1.ReplaySubject();
	        }
	    };
	    return WebSocketSubject;
	}(Subject_1$4.AnonymousSubject));
	var WebSocketSubject_2 = WebSocketSubject;


	var WebSocketSubject_1$1 = {
		WebSocketSubject: WebSocketSubject_2
	};

	var WebSocketSubject_1 = WebSocketSubject_1$1;
	var webSocket_1$1 = WebSocketSubject_1.WebSocketSubject.create;


	var webSocket$2 = {
		webSocket: webSocket_1$1
	};

	var Observable_1$57 = Observable_1$2;
	var webSocket_1 = webSocket$2;
	Observable_1$57.Observable.webSocket = webSocket_1.webSocket;

	var __extends$46 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var OuterSubscriber_1$11 = OuterSubscriber_1$1;
	var subscribeToResult_1$11 = subscribeToResult_1$1;
	/**
	 * Buffers the source Observable values until `closingNotifier` emits.
	 *
	 * <span class="informal">Collects values from the past as an array, and emits
	 * that array only when another Observable emits.</span>
	 *
	 * <img src="./img/buffer.png" width="100%">
	 *
	 * Buffers the incoming Observable values until the given `closingNotifier`
	 * Observable emits a value, at which point it emits the buffer on the output
	 * Observable and starts a new buffer internally, awaiting the next time
	 * `closingNotifier` emits.
	 *
	 * @example <caption>On every click, emit array of most recent interval events</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var interval = Rx.Observable.interval(1000);
	 * var buffered = interval.buffer(clicks);
	 * buffered.subscribe(x => console.log(x));
	 *
	 * @see {@link bufferCount}
	 * @see {@link bufferTime}
	 * @see {@link bufferToggle}
	 * @see {@link bufferWhen}
	 * @see {@link window}
	 *
	 * @param {Observable<any>} closingNotifier An Observable that signals the
	 * buffer to be emitted on the output Observable.
	 * @return {Observable<T[]>} An Observable of buffers, which are arrays of
	 * values.
	 * @method buffer
	 * @owner Observable
	 */
	function buffer$2(closingNotifier) {
	    return this.lift(new BufferOperator(closingNotifier));
	}
	var buffer_2 = buffer$2;
	var BufferOperator = (function () {
	    function BufferOperator(closingNotifier) {
	        this.closingNotifier = closingNotifier;
	    }
	    BufferOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new BufferSubscriber(subscriber, this.closingNotifier));
	    };
	    return BufferOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var BufferSubscriber = (function (_super) {
	    __extends$46(BufferSubscriber, _super);
	    function BufferSubscriber(destination, closingNotifier) {
	        _super.call(this, destination);
	        this.buffer = [];
	        this.add(subscribeToResult_1$11.subscribeToResult(this, closingNotifier));
	    }
	    BufferSubscriber.prototype._next = function (value) {
	        this.buffer.push(value);
	    };
	    BufferSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        var buffer = this.buffer;
	        this.buffer = [];
	        this.destination.next(buffer);
	    };
	    return BufferSubscriber;
	}(OuterSubscriber_1$11.OuterSubscriber));


	var buffer_1$1 = {
		buffer: buffer_2
	};

	var Observable_1$59 = Observable_1$2;
	var buffer_1 = buffer_1$1;
	Observable_1$59.Observable.prototype.buffer = buffer_1.buffer;

	var __extends$47 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1$12 = Subscriber_1$3;
	/**
	 * Buffers the source Observable values until the size hits the maximum
	 * `bufferSize` given.
	 *
	 * <span class="informal">Collects values from the past as an array, and emits
	 * that array only when its size reaches `bufferSize`.</span>
	 *
	 * <img src="./img/bufferCount.png" width="100%">
	 *
	 * Buffers a number of values from the source Observable by `bufferSize` then
	 * emits the buffer and clears it, and starts a new buffer each
	 * `startBufferEvery` values. If `startBufferEvery` is not provided or is
	 * `null`, then new buffers are started immediately at the start of the source
	 * and when each buffer closes and is emitted.
	 *
	 * @example <caption>Emit the last two click events as an array</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var buffered = clicks.bufferCount(2);
	 * buffered.subscribe(x => console.log(x));
	 *
	 * @example <caption>On every click, emit the last two click events as an array</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var buffered = clicks.bufferCount(2, 1);
	 * buffered.subscribe(x => console.log(x));
	 *
	 * @see {@link buffer}
	 * @see {@link bufferTime}
	 * @see {@link bufferToggle}
	 * @see {@link bufferWhen}
	 * @see {@link pairwise}
	 * @see {@link windowCount}
	 *
	 * @param {number} bufferSize The maximum size of the buffer emitted.
	 * @param {number} [startBufferEvery] Interval at which to start a new buffer.
	 * For example if `startBufferEvery` is `2`, then a new buffer will be started
	 * on every other value from the source. A new buffer is started at the
	 * beginning of the source by default.
	 * @return {Observable<T[]>} An Observable of arrays of buffered values.
	 * @method bufferCount
	 * @owner Observable
	 */
	function bufferCount$2(bufferSize, startBufferEvery) {
	    if (startBufferEvery === void 0) { startBufferEvery = null; }
	    return this.lift(new BufferCountOperator(bufferSize, startBufferEvery));
	}
	var bufferCount_2 = bufferCount$2;
	var BufferCountOperator = (function () {
	    function BufferCountOperator(bufferSize, startBufferEvery) {
	        this.bufferSize = bufferSize;
	        this.startBufferEvery = startBufferEvery;
	        if (!startBufferEvery || bufferSize === startBufferEvery) {
	            this.subscriberClass = BufferCountSubscriber;
	        }
	        else {
	            this.subscriberClass = BufferSkipCountSubscriber;
	        }
	    }
	    BufferCountOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new this.subscriberClass(subscriber, this.bufferSize, this.startBufferEvery));
	    };
	    return BufferCountOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var BufferCountSubscriber = (function (_super) {
	    __extends$47(BufferCountSubscriber, _super);
	    function BufferCountSubscriber(destination, bufferSize) {
	        _super.call(this, destination);
	        this.bufferSize = bufferSize;
	        this.buffer = [];
	    }
	    BufferCountSubscriber.prototype._next = function (value) {
	        var buffer = this.buffer;
	        buffer.push(value);
	        if (buffer.length == this.bufferSize) {
	            this.destination.next(buffer);
	            this.buffer = [];
	        }
	    };
	    BufferCountSubscriber.prototype._complete = function () {
	        var buffer = this.buffer;
	        if (buffer.length > 0) {
	            this.destination.next(buffer);
	        }
	        _super.prototype._complete.call(this);
	    };
	    return BufferCountSubscriber;
	}(Subscriber_1$12.Subscriber));
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var BufferSkipCountSubscriber = (function (_super) {
	    __extends$47(BufferSkipCountSubscriber, _super);
	    function BufferSkipCountSubscriber(destination, bufferSize, startBufferEvery) {
	        _super.call(this, destination);
	        this.bufferSize = bufferSize;
	        this.startBufferEvery = startBufferEvery;
	        this.buffers = [];
	        this.count = 0;
	    }
	    BufferSkipCountSubscriber.prototype._next = function (value) {
	        var _a = this, bufferSize = _a.bufferSize, startBufferEvery = _a.startBufferEvery, buffers = _a.buffers, count = _a.count;
	        this.count++;
	        if (count % startBufferEvery === 0) {
	            buffers.push([]);
	        }
	        for (var i = buffers.length; i--;) {
	            var buffer = buffers[i];
	            buffer.push(value);
	            if (buffer.length === bufferSize) {
	                buffers.splice(i, 1);
	                this.destination.next(buffer);
	            }
	        }
	    };
	    BufferSkipCountSubscriber.prototype._complete = function () {
	        var _a = this, buffers = _a.buffers, destination = _a.destination;
	        while (buffers.length > 0) {
	            var buffer = buffers.shift();
	            if (buffer.length > 0) {
	                destination.next(buffer);
	            }
	        }
	        _super.prototype._complete.call(this);
	    };
	    return BufferSkipCountSubscriber;
	}(Subscriber_1$12.Subscriber));


	var bufferCount_1$1 = {
		bufferCount: bufferCount_2
	};

	var Observable_1$60 = Observable_1$2;
	var bufferCount_1 = bufferCount_1$1;
	Observable_1$60.Observable.prototype.bufferCount = bufferCount_1.bufferCount;

	var __extends$48 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var async_1$4 = async;
	var Subscriber_1$13 = Subscriber_1$3;
	var isScheduler_1$8 = isScheduler_1$1;
	/* tslint:enable:max-line-length */
	/**
	 * Buffers the source Observable values for a specific time period.
	 *
	 * <span class="informal">Collects values from the past as an array, and emits
	 * those arrays periodically in time.</span>
	 *
	 * <img src="./img/bufferTime.png" width="100%">
	 *
	 * Buffers values from the source for a specific time duration `bufferTimeSpan`.
	 * Unless the optional argument `bufferCreationInterval` is given, it emits and
	 * resets the buffer every `bufferTimeSpan` milliseconds. If
	 * `bufferCreationInterval` is given, this operator opens the buffer every
	 * `bufferCreationInterval` milliseconds and closes (emits and resets) the
	 * buffer every `bufferTimeSpan` milliseconds. When the optional argument
	 * `maxBufferSize` is specified, the buffer will be closed either after
	 * `bufferTimeSpan` milliseconds or when it contains `maxBufferSize` elements.
	 *
	 * @example <caption>Every second, emit an array of the recent click events</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var buffered = clicks.bufferTime(1000);
	 * buffered.subscribe(x => console.log(x));
	 *
	 * @example <caption>Every 5 seconds, emit the click events from the next 2 seconds</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var buffered = clicks.bufferTime(2000, 5000);
	 * buffered.subscribe(x => console.log(x));
	 *
	 * @see {@link buffer}
	 * @see {@link bufferCount}
	 * @see {@link bufferToggle}
	 * @see {@link bufferWhen}
	 * @see {@link windowTime}
	 *
	 * @param {number} bufferTimeSpan The amount of time to fill each buffer array.
	 * @param {number} [bufferCreationInterval] The interval at which to start new
	 * buffers.
	 * @param {number} [maxBufferSize] The maximum buffer size.
	 * @param {Scheduler} [scheduler=async] The scheduler on which to schedule the
	 * intervals that determine buffer boundaries.
	 * @return {Observable<T[]>} An observable of arrays of buffered values.
	 * @method bufferTime
	 * @owner Observable
	 */
	function bufferTime$2(bufferTimeSpan) {
	    var length = arguments.length;
	    var scheduler = async_1$4.async;
	    if (isScheduler_1$8.isScheduler(arguments[arguments.length - 1])) {
	        scheduler = arguments[arguments.length - 1];
	        length--;
	    }
	    var bufferCreationInterval = null;
	    if (length >= 2) {
	        bufferCreationInterval = arguments[1];
	    }
	    var maxBufferSize = Number.POSITIVE_INFINITY;
	    if (length >= 3) {
	        maxBufferSize = arguments[2];
	    }
	    return this.lift(new BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler));
	}
	var bufferTime_2 = bufferTime$2;
	var BufferTimeOperator = (function () {
	    function BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {
	        this.bufferTimeSpan = bufferTimeSpan;
	        this.bufferCreationInterval = bufferCreationInterval;
	        this.maxBufferSize = maxBufferSize;
	        this.scheduler = scheduler;
	    }
	    BufferTimeOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new BufferTimeSubscriber(subscriber, this.bufferTimeSpan, this.bufferCreationInterval, this.maxBufferSize, this.scheduler));
	    };
	    return BufferTimeOperator;
	}());
	var Context = (function () {
	    function Context() {
	        this.buffer = [];
	    }
	    return Context;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var BufferTimeSubscriber = (function (_super) {
	    __extends$48(BufferTimeSubscriber, _super);
	    function BufferTimeSubscriber(destination, bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {
	        _super.call(this, destination);
	        this.bufferTimeSpan = bufferTimeSpan;
	        this.bufferCreationInterval = bufferCreationInterval;
	        this.maxBufferSize = maxBufferSize;
	        this.scheduler = scheduler;
	        this.contexts = [];
	        var context = this.openContext();
	        this.timespanOnly = bufferCreationInterval == null || bufferCreationInterval < 0;
	        if (this.timespanOnly) {
	            var timeSpanOnlyState = { subscriber: this, context: context, bufferTimeSpan: bufferTimeSpan };
	            this.add(context.closeAction = scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));
	        }
	        else {
	            var closeState = { subscriber: this, context: context };
	            var creationState = { bufferTimeSpan: bufferTimeSpan, bufferCreationInterval: bufferCreationInterval, subscriber: this, scheduler: scheduler };
	            this.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, closeState));
	            this.add(scheduler.schedule(dispatchBufferCreation, bufferCreationInterval, creationState));
	        }
	    }
	    BufferTimeSubscriber.prototype._next = function (value) {
	        var contexts = this.contexts;
	        var len = contexts.length;
	        var filledBufferContext;
	        for (var i = 0; i < len; i++) {
	            var context = contexts[i];
	            var buffer = context.buffer;
	            buffer.push(value);
	            if (buffer.length == this.maxBufferSize) {
	                filledBufferContext = context;
	            }
	        }
	        if (filledBufferContext) {
	            this.onBufferFull(filledBufferContext);
	        }
	    };
	    BufferTimeSubscriber.prototype._error = function (err) {
	        this.contexts.length = 0;
	        _super.prototype._error.call(this, err);
	    };
	    BufferTimeSubscriber.prototype._complete = function () {
	        var _a = this, contexts = _a.contexts, destination = _a.destination;
	        while (contexts.length > 0) {
	            var context = contexts.shift();
	            destination.next(context.buffer);
	        }
	        _super.prototype._complete.call(this);
	    };
	    BufferTimeSubscriber.prototype._unsubscribe = function () {
	        this.contexts = null;
	    };
	    BufferTimeSubscriber.prototype.onBufferFull = function (context) {
	        this.closeContext(context);
	        var closeAction = context.closeAction;
	        closeAction.unsubscribe();
	        this.remove(closeAction);
	        if (!this.closed && this.timespanOnly) {
	            context = this.openContext();
	            var bufferTimeSpan = this.bufferTimeSpan;
	            var timeSpanOnlyState = { subscriber: this, context: context, bufferTimeSpan: bufferTimeSpan };
	            this.add(context.closeAction = this.scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));
	        }
	    };
	    BufferTimeSubscriber.prototype.openContext = function () {
	        var context = new Context();
	        this.contexts.push(context);
	        return context;
	    };
	    BufferTimeSubscriber.prototype.closeContext = function (context) {
	        this.destination.next(context.buffer);
	        var contexts = this.contexts;
	        var spliceIndex = contexts ? contexts.indexOf(context) : -1;
	        if (spliceIndex >= 0) {
	            contexts.splice(contexts.indexOf(context), 1);
	        }
	    };
	    return BufferTimeSubscriber;
	}(Subscriber_1$13.Subscriber));
	function dispatchBufferTimeSpanOnly(state) {
	    var subscriber = state.subscriber;
	    var prevContext = state.context;
	    if (prevContext) {
	        subscriber.closeContext(prevContext);
	    }
	    if (!subscriber.closed) {
	        state.context = subscriber.openContext();
	        state.context.closeAction = this.schedule(state, state.bufferTimeSpan);
	    }
	}
	function dispatchBufferCreation(state) {
	    var bufferCreationInterval = state.bufferCreationInterval, bufferTimeSpan = state.bufferTimeSpan, subscriber = state.subscriber, scheduler = state.scheduler;
	    var context = subscriber.openContext();
	    var action = this;
	    if (!subscriber.closed) {
	        subscriber.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, { subscriber: subscriber, context: context }));
	        action.schedule(state, bufferCreationInterval);
	    }
	}
	function dispatchBufferClose(arg) {
	    var subscriber = arg.subscriber, context = arg.context;
	    subscriber.closeContext(context);
	}


	var bufferTime_1$1 = {
		bufferTime: bufferTime_2
	};

	var Observable_1$61 = Observable_1$2;
	var bufferTime_1 = bufferTime_1$1;
	Observable_1$61.Observable.prototype.bufferTime = bufferTime_1.bufferTime;

	var __extends$49 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscription_1$12 = Subscription_1$3;
	var subscribeToResult_1$12 = subscribeToResult_1$1;
	var OuterSubscriber_1$12 = OuterSubscriber_1$1;
	/**
	 * Buffers the source Observable values starting from an emission from
	 * `openings` and ending when the output of `closingSelector` emits.
	 *
	 * <span class="informal">Collects values from the past as an array. Starts
	 * collecting only when `opening` emits, and calls the `closingSelector`
	 * function to get an Observable that tells when to close the buffer.</span>
	 *
	 * <img src="./img/bufferToggle.png" width="100%">
	 *
	 * Buffers values from the source by opening the buffer via signals from an
	 * Observable provided to `openings`, and closing and sending the buffers when
	 * a Subscribable or Promise returned by the `closingSelector` function emits.
	 *
	 * @example <caption>Every other second, emit the click events from the next 500ms</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var openings = Rx.Observable.interval(1000);
	 * var buffered = clicks.bufferToggle(openings, i =>
	 *   i % 2 ? Rx.Observable.interval(500) : Rx.Observable.empty()
	 * );
	 * buffered.subscribe(x => console.log(x));
	 *
	 * @see {@link buffer}
	 * @see {@link bufferCount}
	 * @see {@link bufferTime}
	 * @see {@link bufferWhen}
	 * @see {@link windowToggle}
	 *
	 * @param {SubscribableOrPromise<O>} openings A Subscribable or Promise of notifications to start new
	 * buffers.
	 * @param {function(value: O): SubscribableOrPromise} closingSelector A function that takes
	 * the value emitted by the `openings` observable and returns a Subscribable or Promise,
	 * which, when it emits, signals that the associated buffer should be emitted
	 * and cleared.
	 * @return {Observable<T[]>} An observable of arrays of buffered values.
	 * @method bufferToggle
	 * @owner Observable
	 */
	function bufferToggle$2(openings, closingSelector) {
	    return this.lift(new BufferToggleOperator(openings, closingSelector));
	}
	var bufferToggle_2 = bufferToggle$2;
	var BufferToggleOperator = (function () {
	    function BufferToggleOperator(openings, closingSelector) {
	        this.openings = openings;
	        this.closingSelector = closingSelector;
	    }
	    BufferToggleOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new BufferToggleSubscriber(subscriber, this.openings, this.closingSelector));
	    };
	    return BufferToggleOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var BufferToggleSubscriber = (function (_super) {
	    __extends$49(BufferToggleSubscriber, _super);
	    function BufferToggleSubscriber(destination, openings, closingSelector) {
	        _super.call(this, destination);
	        this.openings = openings;
	        this.closingSelector = closingSelector;
	        this.contexts = [];
	        this.add(subscribeToResult_1$12.subscribeToResult(this, openings));
	    }
	    BufferToggleSubscriber.prototype._next = function (value) {
	        var contexts = this.contexts;
	        var len = contexts.length;
	        for (var i = 0; i < len; i++) {
	            contexts[i].buffer.push(value);
	        }
	    };
	    BufferToggleSubscriber.prototype._error = function (err) {
	        var contexts = this.contexts;
	        while (contexts.length > 0) {
	            var context = contexts.shift();
	            context.subscription.unsubscribe();
	            context.buffer = null;
	            context.subscription = null;
	        }
	        this.contexts = null;
	        _super.prototype._error.call(this, err);
	    };
	    BufferToggleSubscriber.prototype._complete = function () {
	        var contexts = this.contexts;
	        while (contexts.length > 0) {
	            var context = contexts.shift();
	            this.destination.next(context.buffer);
	            context.subscription.unsubscribe();
	            context.buffer = null;
	            context.subscription = null;
	        }
	        this.contexts = null;
	        _super.prototype._complete.call(this);
	    };
	    BufferToggleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        outerValue ? this.closeBuffer(outerValue) : this.openBuffer(innerValue);
	    };
	    BufferToggleSubscriber.prototype.notifyComplete = function (innerSub) {
	        this.closeBuffer(innerSub.context);
	    };
	    BufferToggleSubscriber.prototype.openBuffer = function (value) {
	        try {
	            var closingSelector = this.closingSelector;
	            var closingNotifier = closingSelector.call(this, value);
	            if (closingNotifier) {
	                this.trySubscribe(closingNotifier);
	            }
	        }
	        catch (err) {
	            this._error(err);
	        }
	    };
	    BufferToggleSubscriber.prototype.closeBuffer = function (context) {
	        var contexts = this.contexts;
	        if (contexts && context) {
	            var buffer = context.buffer, subscription = context.subscription;
	            this.destination.next(buffer);
	            contexts.splice(contexts.indexOf(context), 1);
	            this.remove(subscription);
	            subscription.unsubscribe();
	        }
	    };
	    BufferToggleSubscriber.prototype.trySubscribe = function (closingNotifier) {
	        var contexts = this.contexts;
	        var buffer = [];
	        var subscription = new Subscription_1$12.Subscription();
	        var context = { buffer: buffer, subscription: subscription };
	        contexts.push(context);
	        var innerSubscription = subscribeToResult_1$12.subscribeToResult(this, closingNotifier, context);
	        if (!innerSubscription || innerSubscription.closed) {
	            this.closeBuffer(context);
	        }
	        else {
	            innerSubscription.context = context;
	            this.add(innerSubscription);
	            subscription.add(innerSubscription);
	        }
	    };
	    return BufferToggleSubscriber;
	}(OuterSubscriber_1$12.OuterSubscriber));


	var bufferToggle_1$1 = {
		bufferToggle: bufferToggle_2
	};

	var Observable_1$62 = Observable_1$2;
	var bufferToggle_1 = bufferToggle_1$1;
	Observable_1$62.Observable.prototype.bufferToggle = bufferToggle_1.bufferToggle;

	var __extends$50 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscription_1$13 = Subscription_1$3;
	var tryCatch_1$8 = tryCatch_1$1;
	var errorObject_1$8 = errorObject;
	var OuterSubscriber_1$13 = OuterSubscriber_1$1;
	var subscribeToResult_1$13 = subscribeToResult_1$1;
	/**
	 * Buffers the source Observable values, using a factory function of closing
	 * Observables to determine when to close, emit, and reset the buffer.
	 *
	 * <span class="informal">Collects values from the past as an array. When it
	 * starts collecting values, it calls a function that returns an Observable that
	 * tells when to close the buffer and restart collecting.</span>
	 *
	 * <img src="./img/bufferWhen.png" width="100%">
	 *
	 * Opens a buffer immediately, then closes the buffer when the observable
	 * returned by calling `closingSelector` function emits a value. When it closes
	 * the buffer, it immediately opens a new buffer and repeats the process.
	 *
	 * @example <caption>Emit an array of the last clicks every [1-5] random seconds</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var buffered = clicks.bufferWhen(() =>
	 *   Rx.Observable.interval(1000 + Math.random() * 4000)
	 * );
	 * buffered.subscribe(x => console.log(x));
	 *
	 * @see {@link buffer}
	 * @see {@link bufferCount}
	 * @see {@link bufferTime}
	 * @see {@link bufferToggle}
	 * @see {@link windowWhen}
	 *
	 * @param {function(): Observable} closingSelector A function that takes no
	 * arguments and returns an Observable that signals buffer closure.
	 * @return {Observable<T[]>} An observable of arrays of buffered values.
	 * @method bufferWhen
	 * @owner Observable
	 */
	function bufferWhen$2(closingSelector) {
	    return this.lift(new BufferWhenOperator(closingSelector));
	}
	var bufferWhen_2 = bufferWhen$2;
	var BufferWhenOperator = (function () {
	    function BufferWhenOperator(closingSelector) {
	        this.closingSelector = closingSelector;
	    }
	    BufferWhenOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new BufferWhenSubscriber(subscriber, this.closingSelector));
	    };
	    return BufferWhenOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var BufferWhenSubscriber = (function (_super) {
	    __extends$50(BufferWhenSubscriber, _super);
	    function BufferWhenSubscriber(destination, closingSelector) {
	        _super.call(this, destination);
	        this.closingSelector = closingSelector;
	        this.subscribing = false;
	        this.openBuffer();
	    }
	    BufferWhenSubscriber.prototype._next = function (value) {
	        this.buffer.push(value);
	    };
	    BufferWhenSubscriber.prototype._complete = function () {
	        var buffer = this.buffer;
	        if (buffer) {
	            this.destination.next(buffer);
	        }
	        _super.prototype._complete.call(this);
	    };
	    BufferWhenSubscriber.prototype._unsubscribe = function () {
	        this.buffer = null;
	        this.subscribing = false;
	    };
	    BufferWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        this.openBuffer();
	    };
	    BufferWhenSubscriber.prototype.notifyComplete = function () {
	        if (this.subscribing) {
	            this.complete();
	        }
	        else {
	            this.openBuffer();
	        }
	    };
	    BufferWhenSubscriber.prototype.openBuffer = function () {
	        var closingSubscription = this.closingSubscription;
	        if (closingSubscription) {
	            this.remove(closingSubscription);
	            closingSubscription.unsubscribe();
	        }
	        var buffer = this.buffer;
	        if (this.buffer) {
	            this.destination.next(buffer);
	        }
	        this.buffer = [];
	        var closingNotifier = tryCatch_1$8.tryCatch(this.closingSelector)();
	        if (closingNotifier === errorObject_1$8.errorObject) {
	            this.error(errorObject_1$8.errorObject.e);
	        }
	        else {
	            closingSubscription = new Subscription_1$13.Subscription();
	            this.closingSubscription = closingSubscription;
	            this.add(closingSubscription);
	            this.subscribing = true;
	            closingSubscription.add(subscribeToResult_1$13.subscribeToResult(this, closingNotifier));
	            this.subscribing = false;
	        }
	    };
	    return BufferWhenSubscriber;
	}(OuterSubscriber_1$13.OuterSubscriber));


	var bufferWhen_1$1 = {
		bufferWhen: bufferWhen_2
	};

	var Observable_1$63 = Observable_1$2;
	var bufferWhen_1 = bufferWhen_1$1;
	Observable_1$63.Observable.prototype.bufferWhen = bufferWhen_1.bufferWhen;

	var __extends$51 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var OuterSubscriber_1$14 = OuterSubscriber_1$1;
	var subscribeToResult_1$14 = subscribeToResult_1$1;
	/**
	 * Catches errors on the observable to be handled by returning a new observable or throwing an error.
	 *
	 * <img src="./img/catch.png" width="100%">
	 *
	 * @example <caption>Continues with a different Observable when there's an error</caption>
	 *
	 * Observable.of(1, 2, 3, 4, 5)
	 *   .map(n => {
	 * 	   if (n == 4) {
	 * 	     throw 'four!';
	 *     }
	 *	   return n;
	 *   })
	 *   .catch(err => Observable.of('I', 'II', 'III', 'IV', 'V'))
	 *   .subscribe(x => console.log(x));
	 *   // 1, 2, 3, I, II, III, IV, V
	 *
	 * @example <caption>Retries the caught source Observable again in case of error, similar to retry() operator</caption>
	 *
	 * Observable.of(1, 2, 3, 4, 5)
	 *   .map(n => {
	 * 	   if (n === 4) {
	 * 	     throw 'four!';
	 *     }
	 * 	   return n;
	 *   })
	 *   .catch((err, caught) => caught)
	 *   .take(30)
	 *   .subscribe(x => console.log(x));
	 *   // 1, 2, 3, 1, 2, 3, ...
	 *
	 * @example <caption>Throws a new error when the source Observable throws an error</caption>
	 *
	 * Observable.of(1, 2, 3, 4, 5)
	 *   .map(n => {
	 *     if (n == 4) {
	 *       throw 'four!';
	 *     }
	 *     return n;
	 *   })
	 *   .catch(err => {
	 *     throw 'error in source. Details: ' + err;
	 *   })
	 *   .subscribe(
	 *     x => console.log(x),
	 *     err => console.log(err)
	 *   );
	 *   // 1, 2, 3, error in source. Details: four!
	 *
	 * @param {function} selector a function that takes as arguments `err`, which is the error, and `caught`, which
	 *  is the source observable, in case you'd like to "retry" that observable by returning it again. Whatever observable
	 *  is returned by the `selector` will be used to continue the observable chain.
	 * @return {Observable} An observable that originates from either the source or the observable returned by the
	 *  catch `selector` function.
	 * @method catch
	 * @name catch
	 * @owner Observable
	 */
	function _catch$2(selector) {
	    var operator = new CatchOperator(selector);
	    var caught = this.lift(operator);
	    return (operator.caught = caught);
	}
	var _catch_2 = _catch$2;
	var CatchOperator = (function () {
	    function CatchOperator(selector) {
	        this.selector = selector;
	    }
	    CatchOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new CatchSubscriber(subscriber, this.selector, this.caught));
	    };
	    return CatchOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var CatchSubscriber = (function (_super) {
	    __extends$51(CatchSubscriber, _super);
	    function CatchSubscriber(destination, selector, caught) {
	        _super.call(this, destination);
	        this.selector = selector;
	        this.caught = caught;
	    }
	    // NOTE: overriding `error` instead of `_error` because we don't want
	    // to have this flag this subscriber as `isStopped`. We can mimic the
	    // behavior of the RetrySubscriber (from the `retry` operator), where
	    // we unsubscribe from our source chain, reset our Subscriber flags,
	    // then subscribe to the selector result.
	    CatchSubscriber.prototype.error = function (err) {
	        if (!this.isStopped) {
	            var result = void 0;
	            try {
	                result = this.selector(err, this.caught);
	            }
	            catch (err2) {
	                _super.prototype.error.call(this, err2);
	                return;
	            }
	            this._unsubscribeAndRecycle();
	            this.add(subscribeToResult_1$14.subscribeToResult(this, result));
	        }
	    };
	    return CatchSubscriber;
	}(OuterSubscriber_1$14.OuterSubscriber));


	var _catch_1 = {
		_catch: _catch_2
	};

	var Observable_1$64 = Observable_1$2;
	var catch_1 = _catch_1;
	Observable_1$64.Observable.prototype.catch = catch_1._catch;
	Observable_1$64.Observable.prototype._catch = catch_1._catch;

	var combineLatest_1$4 = combineLatest_1$2;
	/**
	 * Converts a higher-order Observable into a first-order Observable by waiting
	 * for the outer Observable to complete, then applying {@link combineLatest}.
	 *
	 * <span class="informal">Flattens an Observable-of-Observables by applying
	 * {@link combineLatest} when the Observable-of-Observables completes.</span>
	 *
	 * <img src="./img/combineAll.png" width="100%">
	 *
	 * Takes an Observable of Observables, and collects all Observables from it.
	 * Once the outer Observable completes, it subscribes to all collected
	 * Observables and combines their values using the {@link combineLatest}
	 * strategy, such that:
	 * - Every time an inner Observable emits, the output Observable emits.
	 * - When the returned observable emits, it emits all of the latest values by:
	 *   - If a `project` function is provided, it is called with each recent value
	 *     from each inner Observable in whatever order they arrived, and the result
	 *     of the `project` function is what is emitted by the output Observable.
	 *   - If there is no `project` function, an array of all of the most recent
	 *     values is emitted by the output Observable.
	 *
	 * @example <caption>Map two click events to a finite interval Observable, then apply combineAll</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var higherOrder = clicks.map(ev =>
	 *   Rx.Observable.interval(Math.random()*2000).take(3)
	 * ).take(2);
	 * var result = higherOrder.combineAll();
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link combineLatest}
	 * @see {@link mergeAll}
	 *
	 * @param {function} [project] An optional function to map the most recent
	 * values from each inner Observable into a new result. Takes each of the most
	 * recent values from each collected inner Observable as arguments, in order.
	 * @return {Observable} An Observable of projected results or arrays of recent
	 * values.
	 * @method combineAll
	 * @owner Observable
	 */
	function combineAll$2(project) {
	    return this.lift(new combineLatest_1$4.CombineLatestOperator(project));
	}
	var combineAll_2 = combineAll$2;


	var combineAll_1$1 = {
		combineAll: combineAll_2
	};

	var Observable_1$65 = Observable_1$2;
	var combineAll_1 = combineAll_1$1;
	Observable_1$65.Observable.prototype.combineAll = combineAll_1.combineAll;

	var Observable_1$66 = Observable_1$2;
	var combineLatest_1$5 = combineLatest_1$2;
	Observable_1$66.Observable.prototype.combineLatest = combineLatest_1$5.combineLatest;

	var Observable_1$67 = Observable_1$2;
	var concat_1$5 = concat_1$3;
	Observable_1$67.Observable.prototype.concat = concat_1$5.concat;

	var mergeAll_1$4 = mergeAll_1$1;
	/* tslint:enable:max-line-length */
	/**
	 * Converts a higher-order Observable into a first-order Observable by
	 * concatenating the inner Observables in order.
	 *
	 * <span class="informal">Flattens an Observable-of-Observables by putting one
	 * inner Observable after the other.</span>
	 *
	 * <img src="./img/concatAll.png" width="100%">
	 *
	 * Joins every Observable emitted by the source (a higher-order Observable), in
	 * a serial fashion. It subscribes to each inner Observable only after the
	 * previous inner Observable has completed, and merges all of their values into
	 * the returned observable.
	 *
	 * __Warning:__ If the source Observable emits Observables quickly and
	 * endlessly, and the inner Observables it emits generally complete slower than
	 * the source emits, you can run into memory issues as the incoming Observables
	 * collect in an unbounded buffer.
	 *
	 * Note: `concatAll` is equivalent to `mergeAll` with concurrency parameter set
	 * to `1`.
	 *
	 * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var higherOrder = clicks.map(ev => Rx.Observable.interval(1000).take(4));
	 * var firstOrder = higherOrder.concatAll();
	 * firstOrder.subscribe(x => console.log(x));
	 *
	 * // Results in the following:
	 * // (results are not concurrent)
	 * // For every click on the "document" it will emit values 0 to 3 spaced
	 * // on a 1000ms interval
	 * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3
	 *
	 * @see {@link combineAll}
	 * @see {@link concat}
	 * @see {@link concatMap}
	 * @see {@link concatMapTo}
	 * @see {@link exhaust}
	 * @see {@link mergeAll}
	 * @see {@link switch}
	 * @see {@link zipAll}
	 *
	 * @return {Observable} An Observable emitting values from all the inner
	 * Observables concatenated.
	 * @method concatAll
	 * @owner Observable
	 */
	function concatAll$2() {
	    return this.lift(new mergeAll_1$4.MergeAllOperator(1));
	}
	var concatAll_2 = concatAll$2;


	var concatAll_1$1 = {
		concatAll: concatAll_2
	};

	var Observable_1$68 = Observable_1$2;
	var concatAll_1 = concatAll_1$1;
	Observable_1$68.Observable.prototype.concatAll = concatAll_1.concatAll;

	var __extends$52 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var subscribeToResult_1$15 = subscribeToResult_1$1;
	var OuterSubscriber_1$15 = OuterSubscriber_1$1;
	/* tslint:enable:max-line-length */
	/**
	 * Projects each source value to an Observable which is merged in the output
	 * Observable.
	 *
	 * <span class="informal">Maps each value to an Observable, then flattens all of
	 * these inner Observables using {@link mergeAll}.</span>
	 *
	 * <img src="./img/mergeMap.png" width="100%">
	 *
	 * Returns an Observable that emits items based on applying a function that you
	 * supply to each item emitted by the source Observable, where that function
	 * returns an Observable, and then merging those resulting Observables and
	 * emitting the results of this merger.
	 *
	 * @example <caption>Map and flatten each letter to an Observable ticking every 1 second</caption>
	 * var letters = Rx.Observable.of('a', 'b', 'c');
	 * var result = letters.mergeMap(x =>
	 *   Rx.Observable.interval(1000).map(i => x+i)
	 * );
	 * result.subscribe(x => console.log(x));
	 *
	 * // Results in the following:
	 * // a0
	 * // b0
	 * // c0
	 * // a1
	 * // b1
	 * // c1
	 * // continues to list a,b,c with respective ascending integers
	 *
	 * @see {@link concatMap}
	 * @see {@link exhaustMap}
	 * @see {@link merge}
	 * @see {@link mergeAll}
	 * @see {@link mergeMapTo}
	 * @see {@link mergeScan}
	 * @see {@link switchMap}
	 *
	 * @param {function(value: T, ?index: number): ObservableInput} project A function
	 * that, when applied to an item emitted by the source Observable, returns an
	 * Observable.
	 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
	 * A function to produce the value on the output Observable based on the values
	 * and the indices of the source (outer) emission and the inner Observable
	 * emission. The arguments passed to this function are:
	 * - `outerValue`: the value that came from the source
	 * - `innerValue`: the value that came from the projected Observable
	 * - `outerIndex`: the "index" of the value that came from the source
	 * - `innerIndex`: the "index" of the value from the projected Observable
	 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
	 * Observables being subscribed to concurrently.
	 * @return {Observable} An Observable that emits the result of applying the
	 * projection function (and the optional `resultSelector`) to each item emitted
	 * by the source Observable and merging the results of the Observables obtained
	 * from this transformation.
	 * @method mergeMap
	 * @owner Observable
	 */
	function mergeMap(project, resultSelector, concurrent) {
	    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
	    if (typeof resultSelector === 'number') {
	        concurrent = resultSelector;
	        resultSelector = null;
	    }
	    return this.lift(new MergeMapOperator(project, resultSelector, concurrent));
	}
	var mergeMap_2 = mergeMap;
	var MergeMapOperator = (function () {
	    function MergeMapOperator(project, resultSelector, concurrent) {
	        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
	        this.project = project;
	        this.resultSelector = resultSelector;
	        this.concurrent = concurrent;
	    }
	    MergeMapOperator.prototype.call = function (observer, source) {
	        return source.subscribe(new MergeMapSubscriber(observer, this.project, this.resultSelector, this.concurrent));
	    };
	    return MergeMapOperator;
	}());
	var MergeMapOperator_1 = MergeMapOperator;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var MergeMapSubscriber = (function (_super) {
	    __extends$52(MergeMapSubscriber, _super);
	    function MergeMapSubscriber(destination, project, resultSelector, concurrent) {
	        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
	        _super.call(this, destination);
	        this.project = project;
	        this.resultSelector = resultSelector;
	        this.concurrent = concurrent;
	        this.hasCompleted = false;
	        this.buffer = [];
	        this.active = 0;
	        this.index = 0;
	    }
	    MergeMapSubscriber.prototype._next = function (value) {
	        if (this.active < this.concurrent) {
	            this._tryNext(value);
	        }
	        else {
	            this.buffer.push(value);
	        }
	    };
	    MergeMapSubscriber.prototype._tryNext = function (value) {
	        var result;
	        var index = this.index++;
	        try {
	            result = this.project(value, index);
	        }
	        catch (err) {
	            this.destination.error(err);
	            return;
	        }
	        this.active++;
	        this._innerSub(result, value, index);
	    };
	    MergeMapSubscriber.prototype._innerSub = function (ish, value, index) {
	        this.add(subscribeToResult_1$15.subscribeToResult(this, ish, value, index));
	    };
	    MergeMapSubscriber.prototype._complete = function () {
	        this.hasCompleted = true;
	        if (this.active === 0 && this.buffer.length === 0) {
	            this.destination.complete();
	        }
	    };
	    MergeMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        if (this.resultSelector) {
	            this._notifyResultSelector(outerValue, innerValue, outerIndex, innerIndex);
	        }
	        else {
	            this.destination.next(innerValue);
	        }
	    };
	    MergeMapSubscriber.prototype._notifyResultSelector = function (outerValue, innerValue, outerIndex, innerIndex) {
	        var result;
	        try {
	            result = this.resultSelector(outerValue, innerValue, outerIndex, innerIndex);
	        }
	        catch (err) {
	            this.destination.error(err);
	            return;
	        }
	        this.destination.next(result);
	    };
	    MergeMapSubscriber.prototype.notifyComplete = function (innerSub) {
	        var buffer = this.buffer;
	        this.remove(innerSub);
	        this.active--;
	        if (buffer.length > 0) {
	            this._next(buffer.shift());
	        }
	        else if (this.active === 0 && this.hasCompleted) {
	            this.destination.complete();
	        }
	    };
	    return MergeMapSubscriber;
	}(OuterSubscriber_1$15.OuterSubscriber));
	var MergeMapSubscriber_1 = MergeMapSubscriber;


	var mergeMap_1$1 = {
		mergeMap: mergeMap_2,
		MergeMapOperator: MergeMapOperator_1,
		MergeMapSubscriber: MergeMapSubscriber_1
	};

	var mergeMap_1 = mergeMap_1$1;
	/* tslint:enable:max-line-length */
	/**
	 * Projects each source value to an Observable which is merged in the output
	 * Observable, in a serialized fashion waiting for each one to complete before
	 * merging the next.
	 *
	 * <span class="informal">Maps each value to an Observable, then flattens all of
	 * these inner Observables using {@link concatAll}.</span>
	 *
	 * <img src="./img/concatMap.png" width="100%">
	 *
	 * Returns an Observable that emits items based on applying a function that you
	 * supply to each item emitted by the source Observable, where that function
	 * returns an (so-called "inner") Observable. Each new inner Observable is
	 * concatenated with the previous inner Observable.
	 *
	 * __Warning:__ if source values arrive endlessly and faster than their
	 * corresponding inner Observables can complete, it will result in memory issues
	 * as inner Observables amass in an unbounded buffer waiting for their turn to
	 * be subscribed to.
	 *
	 * Note: `concatMap` is equivalent to `mergeMap` with concurrency parameter set
	 * to `1`.
	 *
	 * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = clicks.concatMap(ev => Rx.Observable.interval(1000).take(4));
	 * result.subscribe(x => console.log(x));
	 *
	 * // Results in the following:
	 * // (results are not concurrent)
	 * // For every click on the "document" it will emit values 0 to 3 spaced
	 * // on a 1000ms interval
	 * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3
	 *
	 * @see {@link concat}
	 * @see {@link concatAll}
	 * @see {@link concatMapTo}
	 * @see {@link exhaustMap}
	 * @see {@link mergeMap}
	 * @see {@link switchMap}
	 *
	 * @param {function(value: T, ?index: number): ObservableInput} project A function
	 * that, when applied to an item emitted by the source Observable, returns an
	 * Observable.
	 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
	 * A function to produce the value on the output Observable based on the values
	 * and the indices of the source (outer) emission and the inner Observable
	 * emission. The arguments passed to this function are:
	 * - `outerValue`: the value that came from the source
	 * - `innerValue`: the value that came from the projected Observable
	 * - `outerIndex`: the "index" of the value that came from the source
	 * - `innerIndex`: the "index" of the value from the projected Observable
	 * @return {Observable} An observable of values merged from the projected
	 * Observables as they were subscribed to, one at a time. Optionally, these
	 * values may have been projected from a passed `projectResult` argument.
	 * @return {Observable} An Observable that emits the result of applying the
	 * projection function (and the optional `resultSelector`) to each item emitted
	 * by the source Observable and taking values from each projected inner
	 * Observable sequentially.
	 * @method concatMap
	 * @owner Observable
	 */
	function concatMap$2(project, resultSelector) {
	    return this.lift(new mergeMap_1.MergeMapOperator(project, resultSelector, 1));
	}
	var concatMap_2 = concatMap$2;


	var concatMap_1$1 = {
		concatMap: concatMap_2
	};

	var Observable_1$69 = Observable_1$2;
	var concatMap_1 = concatMap_1$1;
	Observable_1$69.Observable.prototype.concatMap = concatMap_1.concatMap;

	var __extends$53 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var OuterSubscriber_1$16 = OuterSubscriber_1$1;
	var subscribeToResult_1$16 = subscribeToResult_1$1;
	/* tslint:enable:max-line-length */
	/**
	 * Projects each source value to the same Observable which is merged multiple
	 * times in the output Observable.
	 *
	 * <span class="informal">It's like {@link mergeMap}, but maps each value always
	 * to the same inner Observable.</span>
	 *
	 * <img src="./img/mergeMapTo.png" width="100%">
	 *
	 * Maps each source value to the given Observable `innerObservable` regardless
	 * of the source value, and then merges those resulting Observables into one
	 * single Observable, which is the output Observable.
	 *
	 * @example <caption>For each click event, start an interval Observable ticking every 1 second</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = clicks.mergeMapTo(Rx.Observable.interval(1000));
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link concatMapTo}
	 * @see {@link merge}
	 * @see {@link mergeAll}
	 * @see {@link mergeMap}
	 * @see {@link mergeScan}
	 * @see {@link switchMapTo}
	 *
	 * @param {ObservableInput} innerObservable An Observable to replace each value from
	 * the source Observable.
	 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
	 * A function to produce the value on the output Observable based on the values
	 * and the indices of the source (outer) emission and the inner Observable
	 * emission. The arguments passed to this function are:
	 * - `outerValue`: the value that came from the source
	 * - `innerValue`: the value that came from the projected Observable
	 * - `outerIndex`: the "index" of the value that came from the source
	 * - `innerIndex`: the "index" of the value from the projected Observable
	 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
	 * Observables being subscribed to concurrently.
	 * @return {Observable} An Observable that emits items from the given
	 * `innerObservable` (and optionally transformed through `resultSelector`) every
	 * time a value is emitted on the source Observable.
	 * @method mergeMapTo
	 * @owner Observable
	 */
	function mergeMapTo(innerObservable, resultSelector, concurrent) {
	    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
	    if (typeof resultSelector === 'number') {
	        concurrent = resultSelector;
	        resultSelector = null;
	    }
	    return this.lift(new MergeMapToOperator(innerObservable, resultSelector, concurrent));
	}
	var mergeMapTo_2 = mergeMapTo;
	// TODO: Figure out correct signature here: an Operator<Observable<T>, R>
	//       needs to implement call(observer: Subscriber<R>): Subscriber<Observable<T>>
	var MergeMapToOperator = (function () {
	    function MergeMapToOperator(ish, resultSelector, concurrent) {
	        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
	        this.ish = ish;
	        this.resultSelector = resultSelector;
	        this.concurrent = concurrent;
	    }
	    MergeMapToOperator.prototype.call = function (observer, source) {
	        return source.subscribe(new MergeMapToSubscriber(observer, this.ish, this.resultSelector, this.concurrent));
	    };
	    return MergeMapToOperator;
	}());
	var MergeMapToOperator_1 = MergeMapToOperator;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var MergeMapToSubscriber = (function (_super) {
	    __extends$53(MergeMapToSubscriber, _super);
	    function MergeMapToSubscriber(destination, ish, resultSelector, concurrent) {
	        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
	        _super.call(this, destination);
	        this.ish = ish;
	        this.resultSelector = resultSelector;
	        this.concurrent = concurrent;
	        this.hasCompleted = false;
	        this.buffer = [];
	        this.active = 0;
	        this.index = 0;
	    }
	    MergeMapToSubscriber.prototype._next = function (value) {
	        if (this.active < this.concurrent) {
	            var resultSelector = this.resultSelector;
	            var index = this.index++;
	            var ish = this.ish;
	            var destination = this.destination;
	            this.active++;
	            this._innerSub(ish, destination, resultSelector, value, index);
	        }
	        else {
	            this.buffer.push(value);
	        }
	    };
	    MergeMapToSubscriber.prototype._innerSub = function (ish, destination, resultSelector, value, index) {
	        this.add(subscribeToResult_1$16.subscribeToResult(this, ish, value, index));
	    };
	    MergeMapToSubscriber.prototype._complete = function () {
	        this.hasCompleted = true;
	        if (this.active === 0 && this.buffer.length === 0) {
	            this.destination.complete();
	        }
	    };
	    MergeMapToSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;
	        if (resultSelector) {
	            this.trySelectResult(outerValue, innerValue, outerIndex, innerIndex);
	        }
	        else {
	            destination.next(innerValue);
	        }
	    };
	    MergeMapToSubscriber.prototype.trySelectResult = function (outerValue, innerValue, outerIndex, innerIndex) {
	        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;
	        var result;
	        try {
	            result = resultSelector(outerValue, innerValue, outerIndex, innerIndex);
	        }
	        catch (err) {
	            destination.error(err);
	            return;
	        }
	        destination.next(result);
	    };
	    MergeMapToSubscriber.prototype.notifyError = function (err) {
	        this.destination.error(err);
	    };
	    MergeMapToSubscriber.prototype.notifyComplete = function (innerSub) {
	        var buffer = this.buffer;
	        this.remove(innerSub);
	        this.active--;
	        if (buffer.length > 0) {
	            this._next(buffer.shift());
	        }
	        else if (this.active === 0 && this.hasCompleted) {
	            this.destination.complete();
	        }
	    };
	    return MergeMapToSubscriber;
	}(OuterSubscriber_1$16.OuterSubscriber));
	var MergeMapToSubscriber_1 = MergeMapToSubscriber;


	var mergeMapTo_1$1 = {
		mergeMapTo: mergeMapTo_2,
		MergeMapToOperator: MergeMapToOperator_1,
		MergeMapToSubscriber: MergeMapToSubscriber_1
	};

	var mergeMapTo_1 = mergeMapTo_1$1;
	/* tslint:enable:max-line-length */
	/**
	 * Projects each source value to the same Observable which is merged multiple
	 * times in a serialized fashion on the output Observable.
	 *
	 * <span class="informal">It's like {@link concatMap}, but maps each value
	 * always to the same inner Observable.</span>
	 *
	 * <img src="./img/concatMapTo.png" width="100%">
	 *
	 * Maps each source value to the given Observable `innerObservable` regardless
	 * of the source value, and then flattens those resulting Observables into one
	 * single Observable, which is the output Observable. Each new `innerObservable`
	 * instance emitted on the output Observable is concatenated with the previous
	 * `innerObservable` instance.
	 *
	 * __Warning:__ if source values arrive endlessly and faster than their
	 * corresponding inner Observables can complete, it will result in memory issues
	 * as inner Observables amass in an unbounded buffer waiting for their turn to
	 * be subscribed to.
	 *
	 * Note: `concatMapTo` is equivalent to `mergeMapTo` with concurrency parameter
	 * set to `1`.
	 *
	 * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = clicks.concatMapTo(Rx.Observable.interval(1000).take(4));
	 * result.subscribe(x => console.log(x));
	 *
	 * // Results in the following:
	 * // (results are not concurrent)
	 * // For every click on the "document" it will emit values 0 to 3 spaced
	 * // on a 1000ms interval
	 * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3
	 *
	 * @see {@link concat}
	 * @see {@link concatAll}
	 * @see {@link concatMap}
	 * @see {@link mergeMapTo}
	 * @see {@link switchMapTo}
	 *
	 * @param {ObservableInput} innerObservable An Observable to replace each value from
	 * the source Observable.
	 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
	 * A function to produce the value on the output Observable based on the values
	 * and the indices of the source (outer) emission and the inner Observable
	 * emission. The arguments passed to this function are:
	 * - `outerValue`: the value that came from the source
	 * - `innerValue`: the value that came from the projected Observable
	 * - `outerIndex`: the "index" of the value that came from the source
	 * - `innerIndex`: the "index" of the value from the projected Observable
	 * @return {Observable} An observable of values merged together by joining the
	 * passed observable with itself, one after the other, for each value emitted
	 * from the source.
	 * @method concatMapTo
	 * @owner Observable
	 */
	function concatMapTo$2(innerObservable, resultSelector) {
	    return this.lift(new mergeMapTo_1.MergeMapToOperator(innerObservable, resultSelector, 1));
	}
	var concatMapTo_2 = concatMapTo$2;


	var concatMapTo_1$1 = {
		concatMapTo: concatMapTo_2
	};

	var Observable_1$70 = Observable_1$2;
	var concatMapTo_1 = concatMapTo_1$1;
	Observable_1$70.Observable.prototype.concatMapTo = concatMapTo_1.concatMapTo;

	var __extends$54 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1$14 = Subscriber_1$3;
	/**
	 * Counts the number of emissions on the source and emits that number when the
	 * source completes.
	 *
	 * <span class="informal">Tells how many values were emitted, when the source
	 * completes.</span>
	 *
	 * <img src="./img/count.png" width="100%">
	 *
	 * `count` transforms an Observable that emits values into an Observable that
	 * emits a single value that represents the number of values emitted by the
	 * source Observable. If the source Observable terminates with an error, `count`
	 * will pass this error notification along without emitting a value first. If
	 * the source Observable does not terminate at all, `count` will neither emit
	 * a value nor terminate. This operator takes an optional `predicate` function
	 * as argument, in which case the output emission will represent the number of
	 * source values that matched `true` with the `predicate`.
	 *
	 * @example <caption>Counts how many seconds have passed before the first click happened</caption>
	 * var seconds = Rx.Observable.interval(1000);
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var secondsBeforeClick = seconds.takeUntil(clicks);
	 * var result = secondsBeforeClick.count();
	 * result.subscribe(x => console.log(x));
	 *
	 * @example <caption>Counts how many odd numbers are there between 1 and 7</caption>
	 * var numbers = Rx.Observable.range(1, 7);
	 * var result = numbers.count(i => i % 2 === 1);
	 * result.subscribe(x => console.log(x));
	 *
	 * // Results in:
	 * // 4
	 *
	 * @see {@link max}
	 * @see {@link min}
	 * @see {@link reduce}
	 *
	 * @param {function(value: T, i: number, source: Observable<T>): boolean} [predicate] A
	 * boolean function to select what values are to be counted. It is provided with
	 * arguments of:
	 * - `value`: the value from the source Observable.
	 * - `index`: the (zero-based) "index" of the value from the source Observable.
	 * - `source`: the source Observable instance itself.
	 * @return {Observable} An Observable of one number that represents the count as
	 * described above.
	 * @method count
	 * @owner Observable
	 */
	function count$2(predicate) {
	    return this.lift(new CountOperator(predicate, this));
	}
	var count_2 = count$2;
	var CountOperator = (function () {
	    function CountOperator(predicate, source) {
	        this.predicate = predicate;
	        this.source = source;
	    }
	    CountOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new CountSubscriber(subscriber, this.predicate, this.source));
	    };
	    return CountOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var CountSubscriber = (function (_super) {
	    __extends$54(CountSubscriber, _super);
	    function CountSubscriber(destination, predicate, source) {
	        _super.call(this, destination);
	        this.predicate = predicate;
	        this.source = source;
	        this.count = 0;
	        this.index = 0;
	    }
	    CountSubscriber.prototype._next = function (value) {
	        if (this.predicate) {
	            this._tryPredicate(value);
	        }
	        else {
	            this.count++;
	        }
	    };
	    CountSubscriber.prototype._tryPredicate = function (value) {
	        var result;
	        try {
	            result = this.predicate(value, this.index++, this.source);
	        }
	        catch (err) {
	            this.destination.error(err);
	            return;
	        }
	        if (result) {
	            this.count++;
	        }
	    };
	    CountSubscriber.prototype._complete = function () {
	        this.destination.next(this.count);
	        this.destination.complete();
	    };
	    return CountSubscriber;
	}(Subscriber_1$14.Subscriber));


	var count_1$1 = {
		count: count_2
	};

	var Observable_1$71 = Observable_1$2;
	var count_1 = count_1$1;
	Observable_1$71.Observable.prototype.count = count_1.count;

	var __extends$55 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1$15 = Subscriber_1$3;
	/**
	 * Converts an Observable of {@link Notification} objects into the emissions
	 * that they represent.
	 *
	 * <span class="informal">Unwraps {@link Notification} objects as actual `next`,
	 * `error` and `complete` emissions. The opposite of {@link materialize}.</span>
	 *
	 * <img src="./img/dematerialize.png" width="100%">
	 *
	 * `dematerialize` is assumed to operate an Observable that only emits
	 * {@link Notification} objects as `next` emissions, and does not emit any
	 * `error`. Such Observable is the output of a `materialize` operation. Those
	 * notifications are then unwrapped using the metadata they contain, and emitted
	 * as `next`, `error`, and `complete` on the output Observable.
	 *
	 * Use this operator in conjunction with {@link materialize}.
	 *
	 * @example <caption>Convert an Observable of Notifications to an actual Observable</caption>
	 * var notifA = new Rx.Notification('N', 'A');
	 * var notifB = new Rx.Notification('N', 'B');
	 * var notifE = new Rx.Notification('E', void 0,
	 *   new TypeError('x.toUpperCase is not a function')
	 * );
	 * var materialized = Rx.Observable.of(notifA, notifB, notifE);
	 * var upperCase = materialized.dematerialize();
	 * upperCase.subscribe(x => console.log(x), e => console.error(e));
	 *
	 * // Results in:
	 * // A
	 * // B
	 * // TypeError: x.toUpperCase is not a function
	 *
	 * @see {@link Notification}
	 * @see {@link materialize}
	 *
	 * @return {Observable} An Observable that emits items and notifications
	 * embedded in Notification objects emitted by the source Observable.
	 * @method dematerialize
	 * @owner Observable
	 */
	function dematerialize$2() {
	    return this.lift(new DeMaterializeOperator());
	}
	var dematerialize_2 = dematerialize$2;
	var DeMaterializeOperator = (function () {
	    function DeMaterializeOperator() {
	    }
	    DeMaterializeOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new DeMaterializeSubscriber(subscriber));
	    };
	    return DeMaterializeOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var DeMaterializeSubscriber = (function (_super) {
	    __extends$55(DeMaterializeSubscriber, _super);
	    function DeMaterializeSubscriber(destination) {
	        _super.call(this, destination);
	    }
	    DeMaterializeSubscriber.prototype._next = function (value) {
	        value.observe(this.destination);
	    };
	    return DeMaterializeSubscriber;
	}(Subscriber_1$15.Subscriber));


	var dematerialize_1$1 = {
		dematerialize: dematerialize_2
	};

	var Observable_1$72 = Observable_1$2;
	var dematerialize_1 = dematerialize_1$1;
	Observable_1$72.Observable.prototype.dematerialize = dematerialize_1.dematerialize;

	var __extends$56 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var OuterSubscriber_1$17 = OuterSubscriber_1$1;
	var subscribeToResult_1$17 = subscribeToResult_1$1;
	/**
	 * Emits a value from the source Observable only after a particular time span
	 * determined by another Observable has passed without another source emission.
	 *
	 * <span class="informal">It's like {@link debounceTime}, but the time span of
	 * emission silence is determined by a second Observable.</span>
	 *
	 * <img src="./img/debounce.png" width="100%">
	 *
	 * `debounce` delays values emitted by the source Observable, but drops previous
	 * pending delayed emissions if a new value arrives on the source Observable.
	 * This operator keeps track of the most recent value from the source
	 * Observable, and spawns a duration Observable by calling the
	 * `durationSelector` function. The value is emitted only when the duration
	 * Observable emits a value or completes, and if no other value was emitted on
	 * the source Observable since the duration Observable was spawned. If a new
	 * value appears before the duration Observable emits, the previous value will
	 * be dropped and will not be emitted on the output Observable.
	 *
	 * Like {@link debounceTime}, this is a rate-limiting operator, and also a
	 * delay-like operator since output emissions do not necessarily occur at the
	 * same time as they did on the source Observable.
	 *
	 * @example <caption>Emit the most recent click after a burst of clicks</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = clicks.debounce(() => Rx.Observable.interval(1000));
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link audit}
	 * @see {@link debounceTime}
	 * @see {@link delayWhen}
	 * @see {@link throttle}
	 *
	 * @param {function(value: T): SubscribableOrPromise} durationSelector A function
	 * that receives a value from the source Observable, for computing the timeout
	 * duration for each source value, returned as an Observable or a Promise.
	 * @return {Observable} An Observable that delays the emissions of the source
	 * Observable by the specified duration Observable returned by
	 * `durationSelector`, and may drop some values if they occur too frequently.
	 * @method debounce
	 * @owner Observable
	 */
	function debounce$3(durationSelector) {
	    return this.lift(new DebounceOperator(durationSelector));
	}
	var debounce_2 = debounce$3;
	var DebounceOperator = (function () {
	    function DebounceOperator(durationSelector) {
	        this.durationSelector = durationSelector;
	    }
	    DebounceOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new DebounceSubscriber(subscriber, this.durationSelector));
	    };
	    return DebounceOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var DebounceSubscriber = (function (_super) {
	    __extends$56(DebounceSubscriber, _super);
	    function DebounceSubscriber(destination, durationSelector) {
	        _super.call(this, destination);
	        this.durationSelector = durationSelector;
	        this.hasValue = false;
	        this.durationSubscription = null;
	    }
	    DebounceSubscriber.prototype._next = function (value) {
	        try {
	            var result = this.durationSelector.call(this, value);
	            if (result) {
	                this._tryNext(value, result);
	            }
	        }
	        catch (err) {
	            this.destination.error(err);
	        }
	    };
	    DebounceSubscriber.prototype._complete = function () {
	        this.emitValue();
	        this.destination.complete();
	    };
	    DebounceSubscriber.prototype._tryNext = function (value, duration) {
	        var subscription = this.durationSubscription;
	        this.value = value;
	        this.hasValue = true;
	        if (subscription) {
	            subscription.unsubscribe();
	            this.remove(subscription);
	        }
	        subscription = subscribeToResult_1$17.subscribeToResult(this, duration);
	        if (!subscription.closed) {
	            this.add(this.durationSubscription = subscription);
	        }
	    };
	    DebounceSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        this.emitValue();
	    };
	    DebounceSubscriber.prototype.notifyComplete = function () {
	        this.emitValue();
	    };
	    DebounceSubscriber.prototype.emitValue = function () {
	        if (this.hasValue) {
	            var value = this.value;
	            var subscription = this.durationSubscription;
	            if (subscription) {
	                this.durationSubscription = null;
	                subscription.unsubscribe();
	                this.remove(subscription);
	            }
	            this.value = null;
	            this.hasValue = false;
	            _super.prototype._next.call(this, value);
	        }
	    };
	    return DebounceSubscriber;
	}(OuterSubscriber_1$17.OuterSubscriber));


	var debounce_1$2 = {
		debounce: debounce_2
	};

	var Observable_1$73 = Observable_1$2;
	var debounce_1$1 = debounce_1$2;
	Observable_1$73.Observable.prototype.debounce = debounce_1$1.debounce;

	var __extends$57 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1$16 = Subscriber_1$3;
	var async_1$5 = async;
	/**
	 * Emits a value from the source Observable only after a particular time span
	 * has passed without another source emission.
	 *
	 * <span class="informal">It's like {@link delay}, but passes only the most
	 * recent value from each burst of emissions.</span>
	 *
	 * <img src="./img/debounceTime.png" width="100%">
	 *
	 * `debounceTime` delays values emitted by the source Observable, but drops
	 * previous pending delayed emissions if a new value arrives on the source
	 * Observable. This operator keeps track of the most recent value from the
	 * source Observable, and emits that only when `dueTime` enough time has passed
	 * without any other value appearing on the source Observable. If a new value
	 * appears before `dueTime` silence occurs, the previous value will be dropped
	 * and will not be emitted on the output Observable.
	 *
	 * This is a rate-limiting operator, because it is impossible for more than one
	 * value to be emitted in any time window of duration `dueTime`, but it is also
	 * a delay-like operator since output emissions do not occur at the same time as
	 * they did on the source Observable. Optionally takes a {@link IScheduler} for
	 * managing timers.
	 *
	 * @example <caption>Emit the most recent click after a burst of clicks</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = clicks.debounceTime(1000);
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link auditTime}
	 * @see {@link debounce}
	 * @see {@link delay}
	 * @see {@link sampleTime}
	 * @see {@link throttleTime}
	 *
	 * @param {number} dueTime The timeout duration in milliseconds (or the time
	 * unit determined internally by the optional `scheduler`) for the window of
	 * time required to wait for emission silence before emitting the most recent
	 * source value.
	 * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for
	 * managing the timers that handle the timeout for each value.
	 * @return {Observable} An Observable that delays the emissions of the source
	 * Observable by the specified `dueTime`, and may drop some values if they occur
	 * too frequently.
	 * @method debounceTime
	 * @owner Observable
	 */
	function debounceTime$2(dueTime, scheduler) {
	    if (scheduler === void 0) { scheduler = async_1$5.async; }
	    return this.lift(new DebounceTimeOperator(dueTime, scheduler));
	}
	var debounceTime_2 = debounceTime$2;
	var DebounceTimeOperator = (function () {
	    function DebounceTimeOperator(dueTime, scheduler) {
	        this.dueTime = dueTime;
	        this.scheduler = scheduler;
	    }
	    DebounceTimeOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));
	    };
	    return DebounceTimeOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var DebounceTimeSubscriber = (function (_super) {
	    __extends$57(DebounceTimeSubscriber, _super);
	    function DebounceTimeSubscriber(destination, dueTime, scheduler) {
	        _super.call(this, destination);
	        this.dueTime = dueTime;
	        this.scheduler = scheduler;
	        this.debouncedSubscription = null;
	        this.lastValue = null;
	        this.hasValue = false;
	    }
	    DebounceTimeSubscriber.prototype._next = function (value) {
	        this.clearDebounce();
	        this.lastValue = value;
	        this.hasValue = true;
	        this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext$3, this.dueTime, this));
	    };
	    DebounceTimeSubscriber.prototype._complete = function () {
	        this.debouncedNext();
	        this.destination.complete();
	    };
	    DebounceTimeSubscriber.prototype.debouncedNext = function () {
	        this.clearDebounce();
	        if (this.hasValue) {
	            this.destination.next(this.lastValue);
	            this.lastValue = null;
	            this.hasValue = false;
	        }
	    };
	    DebounceTimeSubscriber.prototype.clearDebounce = function () {
	        var debouncedSubscription = this.debouncedSubscription;
	        if (debouncedSubscription !== null) {
	            this.remove(debouncedSubscription);
	            debouncedSubscription.unsubscribe();
	            this.debouncedSubscription = null;
	        }
	    };
	    return DebounceTimeSubscriber;
	}(Subscriber_1$16.Subscriber));
	function dispatchNext$3(subscriber) {
	    subscriber.debouncedNext();
	}


	var debounceTime_1$1 = {
		debounceTime: debounceTime_2
	};

	var Observable_1$74 = Observable_1$2;
	var debounceTime_1 = debounceTime_1$1;
	Observable_1$74.Observable.prototype.debounceTime = debounceTime_1.debounceTime;

	var __extends$58 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1$17 = Subscriber_1$3;
	/* tslint:enable:max-line-length */
	/**
	 * Emits a given value if the source Observable completes without emitting any
	 * `next` value, otherwise mirrors the source Observable.
	 *
	 * <span class="informal">If the source Observable turns out to be empty, then
	 * this operator will emit a default value.</span>
	 *
	 * <img src="./img/defaultIfEmpty.png" width="100%">
	 *
	 * `defaultIfEmpty` emits the values emitted by the source Observable or a
	 * specified default value if the source Observable is empty (completes without
	 * having emitted any `next` value).
	 *
	 * @example <caption>If no clicks happen in 5 seconds, then emit "no clicks"</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var clicksBeforeFive = clicks.takeUntil(Rx.Observable.interval(5000));
	 * var result = clicksBeforeFive.defaultIfEmpty('no clicks');
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link empty}
	 * @see {@link last}
	 *
	 * @param {any} [defaultValue=null] The default value used if the source
	 * Observable is empty.
	 * @return {Observable} An Observable that emits either the specified
	 * `defaultValue` if the source Observable emits no items, or the values emitted
	 * by the source Observable.
	 * @method defaultIfEmpty
	 * @owner Observable
	 */
	function defaultIfEmpty$2(defaultValue) {
	    if (defaultValue === void 0) { defaultValue = null; }
	    return this.lift(new DefaultIfEmptyOperator(defaultValue));
	}
	var defaultIfEmpty_2 = defaultIfEmpty$2;
	var DefaultIfEmptyOperator = (function () {
	    function DefaultIfEmptyOperator(defaultValue) {
	        this.defaultValue = defaultValue;
	    }
	    DefaultIfEmptyOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new DefaultIfEmptySubscriber(subscriber, this.defaultValue));
	    };
	    return DefaultIfEmptyOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var DefaultIfEmptySubscriber = (function (_super) {
	    __extends$58(DefaultIfEmptySubscriber, _super);
	    function DefaultIfEmptySubscriber(destination, defaultValue) {
	        _super.call(this, destination);
	        this.defaultValue = defaultValue;
	        this.isEmpty = true;
	    }
	    DefaultIfEmptySubscriber.prototype._next = function (value) {
	        this.isEmpty = false;
	        this.destination.next(value);
	    };
	    DefaultIfEmptySubscriber.prototype._complete = function () {
	        if (this.isEmpty) {
	            this.destination.next(this.defaultValue);
	        }
	        this.destination.complete();
	    };
	    return DefaultIfEmptySubscriber;
	}(Subscriber_1$17.Subscriber));


	var defaultIfEmpty_1$1 = {
		defaultIfEmpty: defaultIfEmpty_2
	};

	var Observable_1$75 = Observable_1$2;
	var defaultIfEmpty_1 = defaultIfEmpty_1$1;
	Observable_1$75.Observable.prototype.defaultIfEmpty = defaultIfEmpty_1.defaultIfEmpty;

	var __extends$59 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var async_1$6 = async;
	var isDate_1$4 = isDate_1$2;
	var Subscriber_1$18 = Subscriber_1$3;
	var Notification_1$4 = Notification_1$2;
	/**
	 * Delays the emission of items from the source Observable by a given timeout or
	 * until a given Date.
	 *
	 * <span class="informal">Time shifts each item by some specified amount of
	 * milliseconds.</span>
	 *
	 * <img src="./img/delay.png" width="100%">
	 *
	 * If the delay argument is a Number, this operator time shifts the source
	 * Observable by that amount of time expressed in milliseconds. The relative
	 * time intervals between the values are preserved.
	 *
	 * If the delay argument is a Date, this operator time shifts the start of the
	 * Observable execution until the given date occurs.
	 *
	 * @example <caption>Delay each click by one second</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var delayedClicks = clicks.delay(1000); // each click emitted after 1 second
	 * delayedClicks.subscribe(x => console.log(x));
	 *
	 * @example <caption>Delay all clicks until a future date happens</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var date = new Date('March 15, 2050 12:00:00'); // in the future
	 * var delayedClicks = clicks.delay(date); // click emitted only after that date
	 * delayedClicks.subscribe(x => console.log(x));
	 *
	 * @see {@link debounceTime}
	 * @see {@link delayWhen}
	 *
	 * @param {number|Date} delay The delay duration in milliseconds (a `number`) or
	 * a `Date` until which the emission of the source items is delayed.
	 * @param {Scheduler} [scheduler=async] The IScheduler to use for
	 * managing the timers that handle the time-shift for each item.
	 * @return {Observable} An Observable that delays the emissions of the source
	 * Observable by the specified timeout or Date.
	 * @method delay
	 * @owner Observable
	 */
	function delay$3(delay, scheduler) {
	    if (scheduler === void 0) { scheduler = async_1$6.async; }
	    var absoluteDelay = isDate_1$4.isDate(delay);
	    var delayFor = absoluteDelay ? (+delay - scheduler.now()) : Math.abs(delay);
	    return this.lift(new DelayOperator(delayFor, scheduler));
	}
	var delay_2 = delay$3;
	var DelayOperator = (function () {
	    function DelayOperator(delay, scheduler) {
	        this.delay = delay;
	        this.scheduler = scheduler;
	    }
	    DelayOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new DelaySubscriber(subscriber, this.delay, this.scheduler));
	    };
	    return DelayOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var DelaySubscriber = (function (_super) {
	    __extends$59(DelaySubscriber, _super);
	    function DelaySubscriber(destination, delay, scheduler) {
	        _super.call(this, destination);
	        this.delay = delay;
	        this.scheduler = scheduler;
	        this.queue = [];
	        this.active = false;
	        this.errored = false;
	    }
	    DelaySubscriber.dispatch = function (state) {
	        var source = state.source;
	        var queue = source.queue;
	        var scheduler = state.scheduler;
	        var destination = state.destination;
	        while (queue.length > 0 && (queue[0].time - scheduler.now()) <= 0) {
	            queue.shift().notification.observe(destination);
	        }
	        if (queue.length > 0) {
	            var delay_1 = Math.max(0, queue[0].time - scheduler.now());
	            this.schedule(state, delay_1);
	        }
	        else {
	            source.active = false;
	        }
	    };
	    DelaySubscriber.prototype._schedule = function (scheduler) {
	        this.active = true;
	        this.add(scheduler.schedule(DelaySubscriber.dispatch, this.delay, {
	            source: this, destination: this.destination, scheduler: scheduler
	        }));
	    };
	    DelaySubscriber.prototype.scheduleNotification = function (notification) {
	        if (this.errored === true) {
	            return;
	        }
	        var scheduler = this.scheduler;
	        var message = new DelayMessage(scheduler.now() + this.delay, notification);
	        this.queue.push(message);
	        if (this.active === false) {
	            this._schedule(scheduler);
	        }
	    };
	    DelaySubscriber.prototype._next = function (value) {
	        this.scheduleNotification(Notification_1$4.Notification.createNext(value));
	    };
	    DelaySubscriber.prototype._error = function (err) {
	        this.errored = true;
	        this.queue = [];
	        this.destination.error(err);
	    };
	    DelaySubscriber.prototype._complete = function () {
	        this.scheduleNotification(Notification_1$4.Notification.createComplete());
	    };
	    return DelaySubscriber;
	}(Subscriber_1$18.Subscriber));
	var DelayMessage = (function () {
	    function DelayMessage(time, notification) {
	        this.time = time;
	        this.notification = notification;
	    }
	    return DelayMessage;
	}());


	var delay_1$2 = {
		delay: delay_2
	};

	var Observable_1$76 = Observable_1$2;
	var delay_1$1 = delay_1$2;
	Observable_1$76.Observable.prototype.delay = delay_1$1.delay;

	var __extends$60 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1$19 = Subscriber_1$3;
	var Observable_1$78 = Observable_1$2;
	var OuterSubscriber_1$18 = OuterSubscriber_1$1;
	var subscribeToResult_1$18 = subscribeToResult_1$1;
	/**
	 * Delays the emission of items from the source Observable by a given time span
	 * determined by the emissions of another Observable.
	 *
	 * <span class="informal">It's like {@link delay}, but the time span of the
	 * delay duration is determined by a second Observable.</span>
	 *
	 * <img src="./img/delayWhen.png" width="100%">
	 *
	 * `delayWhen` time shifts each emitted value from the source Observable by a
	 * time span determined by another Observable. When the source emits a value,
	 * the `delayDurationSelector` function is called with the source value as
	 * argument, and should return an Observable, called the "duration" Observable.
	 * The source value is emitted on the output Observable only when the duration
	 * Observable emits a value or completes.
	 *
	 * Optionally, `delayWhen` takes a second argument, `subscriptionDelay`, which
	 * is an Observable. When `subscriptionDelay` emits its first value or
	 * completes, the source Observable is subscribed to and starts behaving like
	 * described in the previous paragraph. If `subscriptionDelay` is not provided,
	 * `delayWhen` will subscribe to the source Observable as soon as the output
	 * Observable is subscribed.
	 *
	 * @example <caption>Delay each click by a random amount of time, between 0 and 5 seconds</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var delayedClicks = clicks.delayWhen(event =>
	 *   Rx.Observable.interval(Math.random() * 5000)
	 * );
	 * delayedClicks.subscribe(x => console.log(x));
	 *
	 * @see {@link debounce}
	 * @see {@link delay}
	 *
	 * @param {function(value: T): Observable} delayDurationSelector A function that
	 * returns an Observable for each value emitted by the source Observable, which
	 * is then used to delay the emission of that item on the output Observable
	 * until the Observable returned from this function emits a value.
	 * @param {Observable} subscriptionDelay An Observable that triggers the
	 * subscription to the source Observable once it emits any value.
	 * @return {Observable} An Observable that delays the emissions of the source
	 * Observable by an amount of time specified by the Observable returned by
	 * `delayDurationSelector`.
	 * @method delayWhen
	 * @owner Observable
	 */
	function delayWhen$2(delayDurationSelector, subscriptionDelay) {
	    if (subscriptionDelay) {
	        return new SubscriptionDelayObservable(this, subscriptionDelay)
	            .lift(new DelayWhenOperator(delayDurationSelector));
	    }
	    return this.lift(new DelayWhenOperator(delayDurationSelector));
	}
	var delayWhen_2 = delayWhen$2;
	var DelayWhenOperator = (function () {
	    function DelayWhenOperator(delayDurationSelector) {
	        this.delayDurationSelector = delayDurationSelector;
	    }
	    DelayWhenOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new DelayWhenSubscriber(subscriber, this.delayDurationSelector));
	    };
	    return DelayWhenOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var DelayWhenSubscriber = (function (_super) {
	    __extends$60(DelayWhenSubscriber, _super);
	    function DelayWhenSubscriber(destination, delayDurationSelector) {
	        _super.call(this, destination);
	        this.delayDurationSelector = delayDurationSelector;
	        this.completed = false;
	        this.delayNotifierSubscriptions = [];
	        this.values = [];
	    }
	    DelayWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        this.destination.next(outerValue);
	        this.removeSubscription(innerSub);
	        this.tryComplete();
	    };
	    DelayWhenSubscriber.prototype.notifyError = function (error, innerSub) {
	        this._error(error);
	    };
	    DelayWhenSubscriber.prototype.notifyComplete = function (innerSub) {
	        var value = this.removeSubscription(innerSub);
	        if (value) {
	            this.destination.next(value);
	        }
	        this.tryComplete();
	    };
	    DelayWhenSubscriber.prototype._next = function (value) {
	        try {
	            var delayNotifier = this.delayDurationSelector(value);
	            if (delayNotifier) {
	                this.tryDelay(delayNotifier, value);
	            }
	        }
	        catch (err) {
	            this.destination.error(err);
	        }
	    };
	    DelayWhenSubscriber.prototype._complete = function () {
	        this.completed = true;
	        this.tryComplete();
	    };
	    DelayWhenSubscriber.prototype.removeSubscription = function (subscription) {
	        subscription.unsubscribe();
	        var subscriptionIdx = this.delayNotifierSubscriptions.indexOf(subscription);
	        var value = null;
	        if (subscriptionIdx !== -1) {
	            value = this.values[subscriptionIdx];
	            this.delayNotifierSubscriptions.splice(subscriptionIdx, 1);
	            this.values.splice(subscriptionIdx, 1);
	        }
	        return value;
	    };
	    DelayWhenSubscriber.prototype.tryDelay = function (delayNotifier, value) {
	        var notifierSubscription = subscribeToResult_1$18.subscribeToResult(this, delayNotifier, value);
	        if (notifierSubscription && !notifierSubscription.closed) {
	            this.add(notifierSubscription);
	            this.delayNotifierSubscriptions.push(notifierSubscription);
	        }
	        this.values.push(value);
	    };
	    DelayWhenSubscriber.prototype.tryComplete = function () {
	        if (this.completed && this.delayNotifierSubscriptions.length === 0) {
	            this.destination.complete();
	        }
	    };
	    return DelayWhenSubscriber;
	}(OuterSubscriber_1$18.OuterSubscriber));
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var SubscriptionDelayObservable = (function (_super) {
	    __extends$60(SubscriptionDelayObservable, _super);
	    function SubscriptionDelayObservable(source, subscriptionDelay) {
	        _super.call(this);
	        this.source = source;
	        this.subscriptionDelay = subscriptionDelay;
	    }
	    SubscriptionDelayObservable.prototype._subscribe = function (subscriber) {
	        this.subscriptionDelay.subscribe(new SubscriptionDelaySubscriber(subscriber, this.source));
	    };
	    return SubscriptionDelayObservable;
	}(Observable_1$78.Observable));
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var SubscriptionDelaySubscriber = (function (_super) {
	    __extends$60(SubscriptionDelaySubscriber, _super);
	    function SubscriptionDelaySubscriber(parent, source) {
	        _super.call(this);
	        this.parent = parent;
	        this.source = source;
	        this.sourceSubscribed = false;
	    }
	    SubscriptionDelaySubscriber.prototype._next = function (unused) {
	        this.subscribeToSource();
	    };
	    SubscriptionDelaySubscriber.prototype._error = function (err) {
	        this.unsubscribe();
	        this.parent.error(err);
	    };
	    SubscriptionDelaySubscriber.prototype._complete = function () {
	        this.subscribeToSource();
	    };
	    SubscriptionDelaySubscriber.prototype.subscribeToSource = function () {
	        if (!this.sourceSubscribed) {
	            this.sourceSubscribed = true;
	            this.unsubscribe();
	            this.source.subscribe(this.parent);
	        }
	    };
	    return SubscriptionDelaySubscriber;
	}(Subscriber_1$19.Subscriber));


	var delayWhen_1$1 = {
		delayWhen: delayWhen_2
	};

	var Observable_1$77 = Observable_1$2;
	var delayWhen_1 = delayWhen_1$1;
	Observable_1$77.Observable.prototype.delayWhen = delayWhen_1.delayWhen;

	var root_1$9 = root$1;
	function minimalSetImpl() {
	    // THIS IS NOT a full impl of Set, this is just the minimum
	    // bits of functionality we need for this library.
	    return (function () {
	        function MinimalSet() {
	            this._values = [];
	        }
	        MinimalSet.prototype.add = function (value) {
	            if (!this.has(value)) {
	                this._values.push(value);
	            }
	        };
	        MinimalSet.prototype.has = function (value) {
	            return this._values.indexOf(value) !== -1;
	        };
	        Object.defineProperty(MinimalSet.prototype, "size", {
	            get: function () {
	                return this._values.length;
	            },
	            enumerable: true,
	            configurable: true
	        });
	        MinimalSet.prototype.clear = function () {
	            this._values.length = 0;
	        };
	        return MinimalSet;
	    }());
	}
	var minimalSetImpl_1 = minimalSetImpl;
	var Set = root_1$9.root.Set || minimalSetImpl();


	var _Set$2 = {
		minimalSetImpl: minimalSetImpl_1,
		Set: Set
	};

	var __extends$61 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var OuterSubscriber_1$19 = OuterSubscriber_1$1;
	var subscribeToResult_1$19 = subscribeToResult_1$1;
	var Set_1 = _Set$2;
	/**
	 * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from previous items.
	 *
	 * If a keySelector function is provided, then it will project each value from the source observable into a new value that it will
	 * check for equality with previously projected values. If a keySelector function is not provided, it will use each value from the
	 * source observable directly with an equality check against previous values.
	 *
	 * In JavaScript runtimes that support `Set`, this operator will use a `Set` to improve performance of the distinct value checking.
	 *
	 * In other runtimes, this operator will use a minimal implementation of `Set` that relies on an `Array` and `indexOf` under the
	 * hood, so performance will degrade as more values are checked for distinction. Even in newer browsers, a long-running `distinct`
	 * use might result in memory leaks. To help alleviate this in some scenarios, an optional `flushes` parameter is also provided so
	 * that the internal `Set` can be "flushed", basically clearing it of values.
	 *
	 * @example <caption>A simple example with numbers</caption>
	 * Observable.of(1, 1, 2, 2, 2, 1, 2, 3, 4, 3, 2, 1)
	 *   .distinct()
	 *   .subscribe(x => console.log(x)); // 1, 2, 3, 4
	 *
	 * @example <caption>An example using a keySelector function</caption>
	 * interface Person {
	 *    age: number,
	 *    name: string
	 * }
	 *
	 * Observable.of<Person>(
	 *     { age: 4, name: 'Foo'},
	 *     { age: 7, name: 'Bar'},
	 *     { age: 5, name: 'Foo'})
	 *     .distinct((p: Person) => p.name)
	 *     .subscribe(x => console.log(x));
	 *
	 * // displays:
	 * // { age: 4, name: 'Foo' }
	 * // { age: 7, name: 'Bar' }
	 *
	 * @see {@link distinctUntilChanged}
	 * @see {@link distinctUntilKeyChanged}
	 *
	 * @param {function} [keySelector] Optional function to select which value you want to check as distinct.
	 * @param {Observable} [flushes] Optional Observable for flushing the internal HashSet of the operator.
	 * @return {Observable} An Observable that emits items from the source Observable with distinct values.
	 * @method distinct
	 * @owner Observable
	 */
	function distinct$2(keySelector, flushes) {
	    return this.lift(new DistinctOperator(keySelector, flushes));
	}
	var distinct_2 = distinct$2;
	var DistinctOperator = (function () {
	    function DistinctOperator(keySelector, flushes) {
	        this.keySelector = keySelector;
	        this.flushes = flushes;
	    }
	    DistinctOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new DistinctSubscriber(subscriber, this.keySelector, this.flushes));
	    };
	    return DistinctOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var DistinctSubscriber = (function (_super) {
	    __extends$61(DistinctSubscriber, _super);
	    function DistinctSubscriber(destination, keySelector, flushes) {
	        _super.call(this, destination);
	        this.keySelector = keySelector;
	        this.values = new Set_1.Set();
	        if (flushes) {
	            this.add(subscribeToResult_1$19.subscribeToResult(this, flushes));
	        }
	    }
	    DistinctSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        this.values.clear();
	    };
	    DistinctSubscriber.prototype.notifyError = function (error, innerSub) {
	        this._error(error);
	    };
	    DistinctSubscriber.prototype._next = function (value) {
	        if (this.keySelector) {
	            this._useKeySelector(value);
	        }
	        else {
	            this._finalizeNext(value, value);
	        }
	    };
	    DistinctSubscriber.prototype._useKeySelector = function (value) {
	        var key;
	        var destination = this.destination;
	        try {
	            key = this.keySelector(value);
	        }
	        catch (err) {
	            destination.error(err);
	            return;
	        }
	        this._finalizeNext(key, value);
	    };
	    DistinctSubscriber.prototype._finalizeNext = function (key, value) {
	        var values = this.values;
	        if (!values.has(key)) {
	            values.add(key);
	            this.destination.next(value);
	        }
	    };
	    return DistinctSubscriber;
	}(OuterSubscriber_1$19.OuterSubscriber));
	var DistinctSubscriber_1 = DistinctSubscriber;


	var distinct_1$1 = {
		distinct: distinct_2,
		DistinctSubscriber: DistinctSubscriber_1
	};

	var Observable_1$79 = Observable_1$2;
	var distinct_1 = distinct_1$1;
	Observable_1$79.Observable.prototype.distinct = distinct_1.distinct;

	var __extends$62 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1$20 = Subscriber_1$3;
	var tryCatch_1$9 = tryCatch_1$1;
	var errorObject_1$9 = errorObject;
	/* tslint:enable:max-line-length */
	/**
	 * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from the previous item.
	 *
	 * If a comparator function is provided, then it will be called for each item to test for whether or not that value should be emitted.
	 *
	 * If a comparator function is not provided, an equality check is used by default.
	 *
	 * @example <caption>A simple example with numbers</caption>
	 * Observable.of(1, 1, 2, 2, 2, 1, 1, 2, 3, 3, 4)
	 *   .distinctUntilChanged()
	 *   .subscribe(x => console.log(x)); // 1, 2, 1, 2, 3, 4
	 *
	 * @example <caption>An example using a compare function</caption>
	 * interface Person {
	 *    age: number,
	 *    name: string
	 * }
	 *
	 * Observable.of<Person>(
	 *     { age: 4, name: 'Foo'},
	 *     { age: 7, name: 'Bar'},
	 *     { age: 5, name: 'Foo'})
	 *     { age: 6, name: 'Foo'})
	 *     .distinctUntilChanged((p: Person, q: Person) => p.name === q.name)
	 *     .subscribe(x => console.log(x));
	 *
	 * // displays:
	 * // { age: 4, name: 'Foo' }
	 * // { age: 7, name: 'Bar' }
	 * // { age: 5, name: 'Foo' }
	 *
	 * @see {@link distinct}
	 * @see {@link distinctUntilKeyChanged}
	 *
	 * @param {function} [compare] Optional comparison function called to test if an item is distinct from the previous item in the source.
	 * @return {Observable} An Observable that emits items from the source Observable with distinct values.
	 * @method distinctUntilChanged
	 * @owner Observable
	 */
	function distinctUntilChanged$2(compare, keySelector) {
	    return this.lift(new DistinctUntilChangedOperator(compare, keySelector));
	}
	var distinctUntilChanged_2 = distinctUntilChanged$2;
	var DistinctUntilChangedOperator = (function () {
	    function DistinctUntilChangedOperator(compare, keySelector) {
	        this.compare = compare;
	        this.keySelector = keySelector;
	    }
	    DistinctUntilChangedOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new DistinctUntilChangedSubscriber(subscriber, this.compare, this.keySelector));
	    };
	    return DistinctUntilChangedOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var DistinctUntilChangedSubscriber = (function (_super) {
	    __extends$62(DistinctUntilChangedSubscriber, _super);
	    function DistinctUntilChangedSubscriber(destination, compare, keySelector) {
	        _super.call(this, destination);
	        this.keySelector = keySelector;
	        this.hasKey = false;
	        if (typeof compare === 'function') {
	            this.compare = compare;
	        }
	    }
	    DistinctUntilChangedSubscriber.prototype.compare = function (x, y) {
	        return x === y;
	    };
	    DistinctUntilChangedSubscriber.prototype._next = function (value) {
	        var keySelector = this.keySelector;
	        var key = value;
	        if (keySelector) {
	            key = tryCatch_1$9.tryCatch(this.keySelector)(value);
	            if (key === errorObject_1$9.errorObject) {
	                return this.destination.error(errorObject_1$9.errorObject.e);
	            }
	        }
	        var result = false;
	        if (this.hasKey) {
	            result = tryCatch_1$9.tryCatch(this.compare)(this.key, key);
	            if (result === errorObject_1$9.errorObject) {
	                return this.destination.error(errorObject_1$9.errorObject.e);
	            }
	        }
	        else {
	            this.hasKey = true;
	        }
	        if (Boolean(result) === false) {
	            this.key = key;
	            this.destination.next(value);
	        }
	    };
	    return DistinctUntilChangedSubscriber;
	}(Subscriber_1$20.Subscriber));


	var distinctUntilChanged_1$1 = {
		distinctUntilChanged: distinctUntilChanged_2
	};

	var Observable_1$80 = Observable_1$2;
	var distinctUntilChanged_1 = distinctUntilChanged_1$1;
	Observable_1$80.Observable.prototype.distinctUntilChanged = distinctUntilChanged_1.distinctUntilChanged;

	var distinctUntilChanged_1$3 = distinctUntilChanged_1$1;
	/* tslint:enable:max-line-length */
	/**
	 * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from the previous item,
	 * using a property accessed by using the key provided to check if the two items are distinct.
	 *
	 * If a comparator function is provided, then it will be called for each item to test for whether or not that value should be emitted.
	 *
	 * If a comparator function is not provided, an equality check is used by default.
	 *
	 * @example <caption>An example comparing the name of persons</caption>
	 *
	 *  interface Person {
	 *     age: number,
	 *     name: string
	 *  }
	 *
	 * Observable.of<Person>(
	 *     { age: 4, name: 'Foo'},
	 *     { age: 7, name: 'Bar'},
	 *     { age: 5, name: 'Foo'},
	 *     { age: 6, name: 'Foo'})
	 *     .distinctUntilKeyChanged('name')
	 *     .subscribe(x => console.log(x));
	 *
	 * // displays:
	 * // { age: 4, name: 'Foo' }
	 * // { age: 7, name: 'Bar' }
	 * // { age: 5, name: 'Foo' }
	 *
	 * @example <caption>An example comparing the first letters of the name</caption>
	 *
	 * interface Person {
	 *     age: number,
	 *     name: string
	 *  }
	 *
	 * Observable.of<Person>(
	 *     { age: 4, name: 'Foo1'},
	 *     { age: 7, name: 'Bar'},
	 *     { age: 5, name: 'Foo2'},
	 *     { age: 6, name: 'Foo3'})
	 *     .distinctUntilKeyChanged('name', (x: string, y: string) => x.substring(0, 3) === y.substring(0, 3))
	 *     .subscribe(x => console.log(x));
	 *
	 * // displays:
	 * // { age: 4, name: 'Foo1' }
	 * // { age: 7, name: 'Bar' }
	 * // { age: 5, name: 'Foo2' }
	 *
	 * @see {@link distinct}
	 * @see {@link distinctUntilChanged}
	 *
	 * @param {string} key String key for object property lookup on each item.
	 * @param {function} [compare] Optional comparison function called to test if an item is distinct from the previous item in the source.
	 * @return {Observable} An Observable that emits items from the source Observable with distinct values based on the key specified.
	 * @method distinctUntilKeyChanged
	 * @owner Observable
	 */
	function distinctUntilKeyChanged$2(key, compare) {
	    return distinctUntilChanged_1$3.distinctUntilChanged.call(this, function (x, y) {
	        if (compare) {
	            return compare(x[key], y[key]);
	        }
	        return x[key] === y[key];
	    });
	}
	var distinctUntilKeyChanged_2 = distinctUntilKeyChanged$2;


	var distinctUntilKeyChanged_1$1 = {
		distinctUntilKeyChanged: distinctUntilKeyChanged_2
	};

	var Observable_1$81 = Observable_1$2;
	var distinctUntilKeyChanged_1 = distinctUntilKeyChanged_1$1;
	Observable_1$81.Observable.prototype.distinctUntilKeyChanged = distinctUntilKeyChanged_1.distinctUntilKeyChanged;

	var __extends$63 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1$21 = Subscriber_1$3;
	/* tslint:enable:max-line-length */
	/**
	 * Perform a side effect for every emission on the source Observable, but return
	 * an Observable that is identical to the source.
	 *
	 * <span class="informal">Intercepts each emission on the source and runs a
	 * function, but returns an output which is identical to the source as long as errors don't occur.</span>
	 *
	 * <img src="./img/do.png" width="100%">
	 *
	 * Returns a mirrored Observable of the source Observable, but modified so that
	 * the provided Observer is called to perform a side effect for every value,
	 * error, and completion emitted by the source. Any errors that are thrown in
	 * the aforementioned Observer or handlers are safely sent down the error path
	 * of the output Observable.
	 *
	 * This operator is useful for debugging your Observables for the correct values
	 * or performing other side effects.
	 *
	 * Note: this is different to a `subscribe` on the Observable. If the Observable
	 * returned by `do` is not subscribed, the side effects specified by the
	 * Observer will never happen. `do` therefore simply spies on existing
	 * execution, it does not trigger an execution to happen like `subscribe` does.
	 *
	 * @example <caption>Map every every click to the clientX position of that click, while also logging the click event</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var positions = clicks
	 *   .do(ev => console.log(ev))
	 *   .map(ev => ev.clientX);
	 * positions.subscribe(x => console.log(x));
	 *
	 * @see {@link map}
	 * @see {@link subscribe}
	 *
	 * @param {Observer|function} [nextOrObserver] A normal Observer object or a
	 * callback for `next`.
	 * @param {function} [error] Callback for errors in the source.
	 * @param {function} [complete] Callback for the completion of the source.
	 * @return {Observable} An Observable identical to the source, but runs the
	 * specified Observer or callback(s) for each item.
	 * @method do
	 * @name do
	 * @owner Observable
	 */
	function _do$2(nextOrObserver, error, complete) {
	    return this.lift(new DoOperator(nextOrObserver, error, complete));
	}
	var _do_2 = _do$2;
	var DoOperator = (function () {
	    function DoOperator(nextOrObserver, error, complete) {
	        this.nextOrObserver = nextOrObserver;
	        this.error = error;
	        this.complete = complete;
	    }
	    DoOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new DoSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));
	    };
	    return DoOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var DoSubscriber = (function (_super) {
	    __extends$63(DoSubscriber, _super);
	    function DoSubscriber(destination, nextOrObserver, error, complete) {
	        _super.call(this, destination);
	        var safeSubscriber = new Subscriber_1$21.Subscriber(nextOrObserver, error, complete);
	        safeSubscriber.syncErrorThrowable = true;
	        this.add(safeSubscriber);
	        this.safeSubscriber = safeSubscriber;
	    }
	    DoSubscriber.prototype._next = function (value) {
	        var safeSubscriber = this.safeSubscriber;
	        safeSubscriber.next(value);
	        if (safeSubscriber.syncErrorThrown) {
	            this.destination.error(safeSubscriber.syncErrorValue);
	        }
	        else {
	            this.destination.next(value);
	        }
	    };
	    DoSubscriber.prototype._error = function (err) {
	        var safeSubscriber = this.safeSubscriber;
	        safeSubscriber.error(err);
	        if (safeSubscriber.syncErrorThrown) {
	            this.destination.error(safeSubscriber.syncErrorValue);
	        }
	        else {
	            this.destination.error(err);
	        }
	    };
	    DoSubscriber.prototype._complete = function () {
	        var safeSubscriber = this.safeSubscriber;
	        safeSubscriber.complete();
	        if (safeSubscriber.syncErrorThrown) {
	            this.destination.error(safeSubscriber.syncErrorValue);
	        }
	        else {
	            this.destination.complete();
	        }
	    };
	    return DoSubscriber;
	}(Subscriber_1$21.Subscriber));


	var _do_1 = {
		_do: _do_2
	};

	var Observable_1$82 = Observable_1$2;
	var do_1 = _do_1;
	Observable_1$82.Observable.prototype.do = do_1._do;
	Observable_1$82.Observable.prototype._do = do_1._do;

	var __extends$64 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var OuterSubscriber_1$20 = OuterSubscriber_1$1;
	var subscribeToResult_1$20 = subscribeToResult_1$1;
	/**
	 * Converts a higher-order Observable into a first-order Observable by dropping
	 * inner Observables while the previous inner Observable has not yet completed.
	 *
	 * <span class="informal">Flattens an Observable-of-Observables by dropping the
	 * next inner Observables while the current inner is still executing.</span>
	 *
	 * <img src="./img/exhaust.png" width="100%">
	 *
	 * `exhaust` subscribes to an Observable that emits Observables, also known as a
	 * higher-order Observable. Each time it observes one of these emitted inner
	 * Observables, the output Observable begins emitting the items emitted by that
	 * inner Observable. So far, it behaves like {@link mergeAll}. However,
	 * `exhaust` ignores every new inner Observable if the previous Observable has
	 * not yet completed. Once that one completes, it will accept and flatten the
	 * next inner Observable and repeat this process.
	 *
	 * @example <caption>Run a finite timer for each click, only if there is no currently active timer</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000));
	 * var result = higherOrder.exhaust();
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link combineAll}
	 * @see {@link concatAll}
	 * @see {@link switch}
	 * @see {@link mergeAll}
	 * @see {@link exhaustMap}
	 * @see {@link zipAll}
	 *
	 * @return {Observable} An Observable that takes a source of Observables and propagates the first observable
	 * exclusively until it completes before subscribing to the next.
	 * @method exhaust
	 * @owner Observable
	 */
	function exhaust$2() {
	    return this.lift(new SwitchFirstOperator());
	}
	var exhaust_2 = exhaust$2;
	var SwitchFirstOperator = (function () {
	    function SwitchFirstOperator() {
	    }
	    SwitchFirstOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new SwitchFirstSubscriber(subscriber));
	    };
	    return SwitchFirstOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var SwitchFirstSubscriber = (function (_super) {
	    __extends$64(SwitchFirstSubscriber, _super);
	    function SwitchFirstSubscriber(destination) {
	        _super.call(this, destination);
	        this.hasCompleted = false;
	        this.hasSubscription = false;
	    }
	    SwitchFirstSubscriber.prototype._next = function (value) {
	        if (!this.hasSubscription) {
	            this.hasSubscription = true;
	            this.add(subscribeToResult_1$20.subscribeToResult(this, value));
	        }
	    };
	    SwitchFirstSubscriber.prototype._complete = function () {
	        this.hasCompleted = true;
	        if (!this.hasSubscription) {
	            this.destination.complete();
	        }
	    };
	    SwitchFirstSubscriber.prototype.notifyComplete = function (innerSub) {
	        this.remove(innerSub);
	        this.hasSubscription = false;
	        if (this.hasCompleted) {
	            this.destination.complete();
	        }
	    };
	    return SwitchFirstSubscriber;
	}(OuterSubscriber_1$20.OuterSubscriber));


	var exhaust_1$1 = {
		exhaust: exhaust_2
	};

	var Observable_1$83 = Observable_1$2;
	var exhaust_1 = exhaust_1$1;
	Observable_1$83.Observable.prototype.exhaust = exhaust_1.exhaust;

	var __extends$65 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var OuterSubscriber_1$21 = OuterSubscriber_1$1;
	var subscribeToResult_1$21 = subscribeToResult_1$1;
	/* tslint:enable:max-line-length */
	/**
	 * Projects each source value to an Observable which is merged in the output
	 * Observable only if the previous projected Observable has completed.
	 *
	 * <span class="informal">Maps each value to an Observable, then flattens all of
	 * these inner Observables using {@link exhaust}.</span>
	 *
	 * <img src="./img/exhaustMap.png" width="100%">
	 *
	 * Returns an Observable that emits items based on applying a function that you
	 * supply to each item emitted by the source Observable, where that function
	 * returns an (so-called "inner") Observable. When it projects a source value to
	 * an Observable, the output Observable begins emitting the items emitted by
	 * that projected Observable. However, `exhaustMap` ignores every new projected
	 * Observable if the previous projected Observable has not yet completed. Once
	 * that one completes, it will accept and flatten the next projected Observable
	 * and repeat this process.
	 *
	 * @example <caption>Run a finite timer for each click, only if there is no currently active timer</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = clicks.exhaustMap((ev) => Rx.Observable.interval(1000));
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link concatMap}
	 * @see {@link exhaust}
	 * @see {@link mergeMap}
	 * @see {@link switchMap}
	 *
	 * @param {function(value: T, ?index: number): ObservableInput} project A function
	 * that, when applied to an item emitted by the source Observable, returns an
	 * Observable.
	 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
	 * A function to produce the value on the output Observable based on the values
	 * and the indices of the source (outer) emission and the inner Observable
	 * emission. The arguments passed to this function are:
	 * - `outerValue`: the value that came from the source
	 * - `innerValue`: the value that came from the projected Observable
	 * - `outerIndex`: the "index" of the value that came from the source
	 * - `innerIndex`: the "index" of the value from the projected Observable
	 * @return {Observable} An Observable containing projected Observables
	 * of each item of the source, ignoring projected Observables that start before
	 * their preceding Observable has completed.
	 * @method exhaustMap
	 * @owner Observable
	 */
	function exhaustMap$2(project, resultSelector) {
	    return this.lift(new SwitchFirstMapOperator(project, resultSelector));
	}
	var exhaustMap_2 = exhaustMap$2;
	var SwitchFirstMapOperator = (function () {
	    function SwitchFirstMapOperator(project, resultSelector) {
	        this.project = project;
	        this.resultSelector = resultSelector;
	    }
	    SwitchFirstMapOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new SwitchFirstMapSubscriber(subscriber, this.project, this.resultSelector));
	    };
	    return SwitchFirstMapOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var SwitchFirstMapSubscriber = (function (_super) {
	    __extends$65(SwitchFirstMapSubscriber, _super);
	    function SwitchFirstMapSubscriber(destination, project, resultSelector) {
	        _super.call(this, destination);
	        this.project = project;
	        this.resultSelector = resultSelector;
	        this.hasSubscription = false;
	        this.hasCompleted = false;
	        this.index = 0;
	    }
	    SwitchFirstMapSubscriber.prototype._next = function (value) {
	        if (!this.hasSubscription) {
	            this.tryNext(value);
	        }
	    };
	    SwitchFirstMapSubscriber.prototype.tryNext = function (value) {
	        var index = this.index++;
	        var destination = this.destination;
	        try {
	            var result = this.project(value, index);
	            this.hasSubscription = true;
	            this.add(subscribeToResult_1$21.subscribeToResult(this, result, value, index));
	        }
	        catch (err) {
	            destination.error(err);
	        }
	    };
	    SwitchFirstMapSubscriber.prototype._complete = function () {
	        this.hasCompleted = true;
	        if (!this.hasSubscription) {
	            this.destination.complete();
	        }
	    };
	    SwitchFirstMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;
	        if (resultSelector) {
	            this.trySelectResult(outerValue, innerValue, outerIndex, innerIndex);
	        }
	        else {
	            destination.next(innerValue);
	        }
	    };
	    SwitchFirstMapSubscriber.prototype.trySelectResult = function (outerValue, innerValue, outerIndex, innerIndex) {
	        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;
	        try {
	            var result = resultSelector(outerValue, innerValue, outerIndex, innerIndex);
	            destination.next(result);
	        }
	        catch (err) {
	            destination.error(err);
	        }
	    };
	    SwitchFirstMapSubscriber.prototype.notifyError = function (err) {
	        this.destination.error(err);
	    };
	    SwitchFirstMapSubscriber.prototype.notifyComplete = function (innerSub) {
	        this.remove(innerSub);
	        this.hasSubscription = false;
	        if (this.hasCompleted) {
	            this.destination.complete();
	        }
	    };
	    return SwitchFirstMapSubscriber;
	}(OuterSubscriber_1$21.OuterSubscriber));


	var exhaustMap_1$1 = {
		exhaustMap: exhaustMap_2
	};

	var Observable_1$84 = Observable_1$2;
	var exhaustMap_1 = exhaustMap_1$1;
	Observable_1$84.Observable.prototype.exhaustMap = exhaustMap_1.exhaustMap;

	var __extends$66 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var tryCatch_1$10 = tryCatch_1$1;
	var errorObject_1$10 = errorObject;
	var OuterSubscriber_1$22 = OuterSubscriber_1$1;
	var subscribeToResult_1$22 = subscribeToResult_1$1;
	/* tslint:enable:max-line-length */
	/**
	 * Recursively projects each source value to an Observable which is merged in
	 * the output Observable.
	 *
	 * <span class="informal">It's similar to {@link mergeMap}, but applies the
	 * projection function to every source value as well as every output value.
	 * It's recursive.</span>
	 *
	 * <img src="./img/expand.png" width="100%">
	 *
	 * Returns an Observable that emits items based on applying a function that you
	 * supply to each item emitted by the source Observable, where that function
	 * returns an Observable, and then merging those resulting Observables and
	 * emitting the results of this merger. *Expand* will re-emit on the output
	 * Observable every source value. Then, each output value is given to the
	 * `project` function which returns an inner Observable to be merged on the
	 * output Observable. Those output values resulting from the projection are also
	 * given to the `project` function to produce new output values. This is how
	 * *expand* behaves recursively.
	 *
	 * @example <caption>Start emitting the powers of two on every click, at most 10 of them</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var powersOfTwo = clicks
	 *   .mapTo(1)
	 *   .expand(x => Rx.Observable.of(2 * x).delay(1000))
	 *   .take(10);
	 * powersOfTwo.subscribe(x => console.log(x));
	 *
	 * @see {@link mergeMap}
	 * @see {@link mergeScan}
	 *
	 * @param {function(value: T, index: number) => Observable} project A function
	 * that, when applied to an item emitted by the source or the output Observable,
	 * returns an Observable.
	 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
	 * Observables being subscribed to concurrently.
	 * @param {Scheduler} [scheduler=null] The IScheduler to use for subscribing to
	 * each projected inner Observable.
	 * @return {Observable} An Observable that emits the source values and also
	 * result of applying the projection function to each value emitted on the
	 * output Observable and and merging the results of the Observables obtained
	 * from this transformation.
	 * @method expand
	 * @owner Observable
	 */
	function expand$2(project, concurrent, scheduler) {
	    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
	    if (scheduler === void 0) { scheduler = undefined; }
	    concurrent = (concurrent || 0) < 1 ? Number.POSITIVE_INFINITY : concurrent;
	    return this.lift(new ExpandOperator(project, concurrent, scheduler));
	}
	var expand_2 = expand$2;
	var ExpandOperator = (function () {
	    function ExpandOperator(project, concurrent, scheduler) {
	        this.project = project;
	        this.concurrent = concurrent;
	        this.scheduler = scheduler;
	    }
	    ExpandOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new ExpandSubscriber(subscriber, this.project, this.concurrent, this.scheduler));
	    };
	    return ExpandOperator;
	}());
	var ExpandOperator_1 = ExpandOperator;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var ExpandSubscriber = (function (_super) {
	    __extends$66(ExpandSubscriber, _super);
	    function ExpandSubscriber(destination, project, concurrent, scheduler) {
	        _super.call(this, destination);
	        this.project = project;
	        this.concurrent = concurrent;
	        this.scheduler = scheduler;
	        this.index = 0;
	        this.active = 0;
	        this.hasCompleted = false;
	        if (concurrent < Number.POSITIVE_INFINITY) {
	            this.buffer = [];
	        }
	    }
	    ExpandSubscriber.dispatch = function (arg) {
	        var subscriber = arg.subscriber, result = arg.result, value = arg.value, index = arg.index;
	        subscriber.subscribeToProjection(result, value, index);
	    };
	    ExpandSubscriber.prototype._next = function (value) {
	        var destination = this.destination;
	        if (destination.closed) {
	            this._complete();
	            return;
	        }
	        var index = this.index++;
	        if (this.active < this.concurrent) {
	            destination.next(value);
	            var result = tryCatch_1$10.tryCatch(this.project)(value, index);
	            if (result === errorObject_1$10.errorObject) {
	                destination.error(errorObject_1$10.errorObject.e);
	            }
	            else if (!this.scheduler) {
	                this.subscribeToProjection(result, value, index);
	            }
	            else {
	                var state = { subscriber: this, result: result, value: value, index: index };
	                this.add(this.scheduler.schedule(ExpandSubscriber.dispatch, 0, state));
	            }
	        }
	        else {
	            this.buffer.push(value);
	        }
	    };
	    ExpandSubscriber.prototype.subscribeToProjection = function (result, value, index) {
	        this.active++;
	        this.add(subscribeToResult_1$22.subscribeToResult(this, result, value, index));
	    };
	    ExpandSubscriber.prototype._complete = function () {
	        this.hasCompleted = true;
	        if (this.hasCompleted && this.active === 0) {
	            this.destination.complete();
	        }
	    };
	    ExpandSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        this._next(innerValue);
	    };
	    ExpandSubscriber.prototype.notifyComplete = function (innerSub) {
	        var buffer = this.buffer;
	        this.remove(innerSub);
	        this.active--;
	        if (buffer && buffer.length > 0) {
	            this._next(buffer.shift());
	        }
	        if (this.hasCompleted && this.active === 0) {
	            this.destination.complete();
	        }
	    };
	    return ExpandSubscriber;
	}(OuterSubscriber_1$22.OuterSubscriber));
	var ExpandSubscriber_1 = ExpandSubscriber;


	var expand_1$1 = {
		expand: expand_2,
		ExpandOperator: ExpandOperator_1,
		ExpandSubscriber: ExpandSubscriber_1
	};

	var Observable_1$85 = Observable_1$2;
	var expand_1 = expand_1$1;
	Observable_1$85.Observable.prototype.expand = expand_1.expand;

	var __extends$68 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/**
	 * An error thrown when an element was queried at a certain index of an
	 * Observable, but no such index or position exists in that sequence.
	 *
	 * @see {@link elementAt}
	 * @see {@link take}
	 * @see {@link takeLast}
	 *
	 * @class ArgumentOutOfRangeError
	 */
	var ArgumentOutOfRangeError$1 = (function (_super) {
	    __extends$68(ArgumentOutOfRangeError, _super);
	    function ArgumentOutOfRangeError() {
	        var err = _super.call(this, 'argument out of range');
	        this.name = err.name = 'ArgumentOutOfRangeError';
	        this.stack = err.stack;
	        this.message = err.message;
	    }
	    return ArgumentOutOfRangeError;
	}(Error));
	var ArgumentOutOfRangeError_2 = ArgumentOutOfRangeError$1;


	var ArgumentOutOfRangeError_1$2 = {
		ArgumentOutOfRangeError: ArgumentOutOfRangeError_2
	};

	var __extends$67 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1$22 = Subscriber_1$3;
	var ArgumentOutOfRangeError_1$1 = ArgumentOutOfRangeError_1$2;
	/**
	 * Emits the single value at the specified `index` in a sequence of emissions
	 * from the source Observable.
	 *
	 * <span class="informal">Emits only the i-th value, then completes.</span>
	 *
	 * <img src="./img/elementAt.png" width="100%">
	 *
	 * `elementAt` returns an Observable that emits the item at the specified
	 * `index` in the source Observable, or a default value if that `index` is out
	 * of range and the `default` argument is provided. If the `default` argument is
	 * not given and the `index` is out of range, the output Observable will emit an
	 * `ArgumentOutOfRangeError` error.
	 *
	 * @example <caption>Emit only the third click event</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = clicks.elementAt(2);
	 * result.subscribe(x => console.log(x));
	 *
	 * // Results in:
	 * // click 1 = nothing
	 * // click 2 = nothing
	 * // click 3 = MouseEvent object logged to console
	 *
	 * @see {@link first}
	 * @see {@link last}
	 * @see {@link skip}
	 * @see {@link single}
	 * @see {@link take}
	 *
	 * @throws {ArgumentOutOfRangeError} When using `elementAt(i)`, it delivers an
	 * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0` or the
	 * Observable has completed before emitting the i-th `next` notification.
	 *
	 * @param {number} index Is the number `i` for the i-th source emission that has
	 * happened since the subscription, starting from the number `0`.
	 * @param {T} [defaultValue] The default value returned for missing indices.
	 * @return {Observable} An Observable that emits a single item, if it is found.
	 * Otherwise, will emit the default value if given. If not, then emits an error.
	 * @method elementAt
	 * @owner Observable
	 */
	function elementAt$2(index, defaultValue) {
	    return this.lift(new ElementAtOperator(index, defaultValue));
	}
	var elementAt_2 = elementAt$2;
	var ElementAtOperator = (function () {
	    function ElementAtOperator(index, defaultValue) {
	        this.index = index;
	        this.defaultValue = defaultValue;
	        if (index < 0) {
	            throw new ArgumentOutOfRangeError_1$1.ArgumentOutOfRangeError;
	        }
	    }
	    ElementAtOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new ElementAtSubscriber(subscriber, this.index, this.defaultValue));
	    };
	    return ElementAtOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var ElementAtSubscriber = (function (_super) {
	    __extends$67(ElementAtSubscriber, _super);
	    function ElementAtSubscriber(destination, index, defaultValue) {
	        _super.call(this, destination);
	        this.index = index;
	        this.defaultValue = defaultValue;
	    }
	    ElementAtSubscriber.prototype._next = function (x) {
	        if (this.index-- === 0) {
	            this.destination.next(x);
	            this.destination.complete();
	        }
	    };
	    ElementAtSubscriber.prototype._complete = function () {
	        var destination = this.destination;
	        if (this.index >= 0) {
	            if (typeof this.defaultValue !== 'undefined') {
	                destination.next(this.defaultValue);
	            }
	            else {
	                destination.error(new ArgumentOutOfRangeError_1$1.ArgumentOutOfRangeError);
	            }
	        }
	        destination.complete();
	    };
	    return ElementAtSubscriber;
	}(Subscriber_1$22.Subscriber));


	var elementAt_1$1 = {
		elementAt: elementAt_2
	};

	var Observable_1$86 = Observable_1$2;
	var elementAt_1 = elementAt_1$1;
	Observable_1$86.Observable.prototype.elementAt = elementAt_1.elementAt;

	var __extends$69 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1$23 = Subscriber_1$3;
	/* tslint:enable:max-line-length */
	/**
	 * Filter items emitted by the source Observable by only emitting those that
	 * satisfy a specified predicate.
	 *
	 * <span class="informal">Like
	 * [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter),
	 * it only emits a value from the source if it passes a criterion function.</span>
	 *
	 * <img src="./img/filter.png" width="100%">
	 *
	 * Similar to the well-known `Array.prototype.filter` method, this operator
	 * takes values from the source Observable, passes them through a `predicate`
	 * function and only emits those values that yielded `true`.
	 *
	 * @example <caption>Emit only click events whose target was a DIV element</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var clicksOnDivs = clicks.filter(ev => ev.target.tagName === 'DIV');
	 * clicksOnDivs.subscribe(x => console.log(x));
	 *
	 * @see {@link distinct}
	 * @see {@link distinctUntilChanged}
	 * @see {@link distinctUntilKeyChanged}
	 * @see {@link ignoreElements}
	 * @see {@link partition}
	 * @see {@link skip}
	 *
	 * @param {function(value: T, index: number): boolean} predicate A function that
	 * evaluates each value emitted by the source Observable. If it returns `true`,
	 * the value is emitted, if `false` the value is not passed to the output
	 * Observable. The `index` parameter is the number `i` for the i-th source
	 * emission that has happened since the subscription, starting from the number
	 * `0`.
	 * @param {any} [thisArg] An optional argument to determine the value of `this`
	 * in the `predicate` function.
	 * @return {Observable} An Observable of values from the source that were
	 * allowed by the `predicate` function.
	 * @method filter
	 * @owner Observable
	 */
	function filter$3(predicate, thisArg) {
	    return this.lift(new FilterOperator(predicate, thisArg));
	}
	var filter_2 = filter$3;
	var FilterOperator = (function () {
	    function FilterOperator(predicate, thisArg) {
	        this.predicate = predicate;
	        this.thisArg = thisArg;
	    }
	    FilterOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));
	    };
	    return FilterOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var FilterSubscriber = (function (_super) {
	    __extends$69(FilterSubscriber, _super);
	    function FilterSubscriber(destination, predicate, thisArg) {
	        _super.call(this, destination);
	        this.predicate = predicate;
	        this.thisArg = thisArg;
	        this.count = 0;
	        this.predicate = predicate;
	    }
	    // the try catch block below is left specifically for
	    // optimization and perf reasons. a tryCatcher is not necessary here.
	    FilterSubscriber.prototype._next = function (value) {
	        var result;
	        try {
	            result = this.predicate.call(this.thisArg, value, this.count++);
	        }
	        catch (err) {
	            this.destination.error(err);
	            return;
	        }
	        if (result) {
	            this.destination.next(value);
	        }
	    };
	    return FilterSubscriber;
	}(Subscriber_1$23.Subscriber));


	var filter_1$2 = {
		filter: filter_2
	};

	var Observable_1$87 = Observable_1$2;
	var filter_1$1 = filter_1$2;
	Observable_1$87.Observable.prototype.filter = filter_1$1.filter;

	var __extends$70 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1$24 = Subscriber_1$3;
	var Subscription_1$14 = Subscription_1$3;
	/**
	 * Returns an Observable that mirrors the source Observable, but will call a specified function when
	 * the source terminates on complete or error.
	 * @param {function} callback Function to be called when source terminates.
	 * @return {Observable} An Observable that mirrors the source, but will call the specified function on termination.
	 * @method finally
	 * @owner Observable
	 */
	function _finally$2(callback) {
	    return this.lift(new FinallyOperator(callback));
	}
	var _finally_2 = _finally$2;
	var FinallyOperator = (function () {
	    function FinallyOperator(callback) {
	        this.callback = callback;
	    }
	    FinallyOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new FinallySubscriber(subscriber, this.callback));
	    };
	    return FinallyOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var FinallySubscriber = (function (_super) {
	    __extends$70(FinallySubscriber, _super);
	    function FinallySubscriber(destination, callback) {
	        _super.call(this, destination);
	        this.add(new Subscription_1$14.Subscription(callback));
	    }
	    return FinallySubscriber;
	}(Subscriber_1$24.Subscriber));


	var _finally_1 = {
		_finally: _finally_2
	};

	var Observable_1$88 = Observable_1$2;
	var finally_1 = _finally_1;
	Observable_1$88.Observable.prototype.finally = finally_1._finally;
	Observable_1$88.Observable.prototype._finally = finally_1._finally;

	var __extends$71 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1$25 = Subscriber_1$3;
	/* tslint:enable:max-line-length */
	/**
	 * Emits only the first value emitted by the source Observable that meets some
	 * condition.
	 *
	 * <span class="informal">Finds the first value that passes some test and emits
	 * that.</span>
	 *
	 * <img src="./img/find.png" width="100%">
	 *
	 * `find` searches for the first item in the source Observable that matches the
	 * specified condition embodied by the `predicate`, and returns the first
	 * occurrence in the source. Unlike {@link first}, the `predicate` is required
	 * in `find`, and does not emit an error if a valid value is not found.
	 *
	 * @example <caption>Find and emit the first click that happens on a DIV element</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = clicks.find(ev => ev.target.tagName === 'DIV');
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link filter}
	 * @see {@link first}
	 * @see {@link findIndex}
	 * @see {@link take}
	 *
	 * @param {function(value: T, index: number, source: Observable<T>): boolean} predicate
	 * A function called with each item to test for condition matching.
	 * @param {any} [thisArg] An optional argument to determine the value of `this`
	 * in the `predicate` function.
	 * @return {Observable<T>} An Observable of the first item that matches the
	 * condition.
	 * @method find
	 * @owner Observable
	 */
	function find$3(predicate, thisArg) {
	    if (typeof predicate !== 'function') {
	        throw new TypeError('predicate is not a function');
	    }
	    return this.lift(new FindValueOperator(predicate, this, false, thisArg));
	}
	var find_2 = find$3;
	var FindValueOperator = (function () {
	    function FindValueOperator(predicate, source, yieldIndex, thisArg) {
	        this.predicate = predicate;
	        this.source = source;
	        this.yieldIndex = yieldIndex;
	        this.thisArg = thisArg;
	    }
	    FindValueOperator.prototype.call = function (observer, source) {
	        return source.subscribe(new FindValueSubscriber(observer, this.predicate, this.source, this.yieldIndex, this.thisArg));
	    };
	    return FindValueOperator;
	}());
	var FindValueOperator_1 = FindValueOperator;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var FindValueSubscriber = (function (_super) {
	    __extends$71(FindValueSubscriber, _super);
	    function FindValueSubscriber(destination, predicate, source, yieldIndex, thisArg) {
	        _super.call(this, destination);
	        this.predicate = predicate;
	        this.source = source;
	        this.yieldIndex = yieldIndex;
	        this.thisArg = thisArg;
	        this.index = 0;
	    }
	    FindValueSubscriber.prototype.notifyComplete = function (value) {
	        var destination = this.destination;
	        destination.next(value);
	        destination.complete();
	    };
	    FindValueSubscriber.prototype._next = function (value) {
	        var _a = this, predicate = _a.predicate, thisArg = _a.thisArg;
	        var index = this.index++;
	        try {
	            var result = predicate.call(thisArg || this, value, index, this.source);
	            if (result) {
	                this.notifyComplete(this.yieldIndex ? index : value);
	            }
	        }
	        catch (err) {
	            this.destination.error(err);
	        }
	    };
	    FindValueSubscriber.prototype._complete = function () {
	        this.notifyComplete(this.yieldIndex ? -1 : undefined);
	    };
	    return FindValueSubscriber;
	}(Subscriber_1$25.Subscriber));
	var FindValueSubscriber_1 = FindValueSubscriber;


	var find_1$2 = {
		find: find_2,
		FindValueOperator: FindValueOperator_1,
		FindValueSubscriber: FindValueSubscriber_1
	};

	var Observable_1$89 = Observable_1$2;
	var find_1$1 = find_1$2;
	Observable_1$89.Observable.prototype.find = find_1$1.find;

	var find_1$4 = find_1$2;
	/**
	 * Emits only the index of the first value emitted by the source Observable that
	 * meets some condition.
	 *
	 * <span class="informal">It's like {@link find}, but emits the index of the
	 * found value, not the value itself.</span>
	 *
	 * <img src="./img/findIndex.png" width="100%">
	 *
	 * `findIndex` searches for the first item in the source Observable that matches
	 * the specified condition embodied by the `predicate`, and returns the
	 * (zero-based) index of the first occurrence in the source. Unlike
	 * {@link first}, the `predicate` is required in `findIndex`, and does not emit
	 * an error if a valid value is not found.
	 *
	 * @example <caption>Emit the index of first click that happens on a DIV element</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = clicks.findIndex(ev => ev.target.tagName === 'DIV');
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link filter}
	 * @see {@link find}
	 * @see {@link first}
	 * @see {@link take}
	 *
	 * @param {function(value: T, index: number, source: Observable<T>): boolean} predicate
	 * A function called with each item to test for condition matching.
	 * @param {any} [thisArg] An optional argument to determine the value of `this`
	 * in the `predicate` function.
	 * @return {Observable} An Observable of the index of the first item that
	 * matches the condition.
	 * @method find
	 * @owner Observable
	 */
	function findIndex$3(predicate, thisArg) {
	    return this.lift(new find_1$4.FindValueOperator(predicate, this, true, thisArg));
	}
	var findIndex_2 = findIndex$3;


	var findIndex_1$2 = {
		findIndex: findIndex_2
	};

	var Observable_1$90 = Observable_1$2;
	var findIndex_1$1 = findIndex_1$2;
	Observable_1$90.Observable.prototype.findIndex = findIndex_1$1.findIndex;

	var __extends$73 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/**
	 * An error thrown when an Observable or a sequence was queried but has no
	 * elements.
	 *
	 * @see {@link first}
	 * @see {@link last}
	 * @see {@link single}
	 *
	 * @class EmptyError
	 */
	var EmptyError$1 = (function (_super) {
	    __extends$73(EmptyError, _super);
	    function EmptyError() {
	        var err = _super.call(this, 'no elements in sequence');
	        this.name = err.name = 'EmptyError';
	        this.stack = err.stack;
	        this.message = err.message;
	    }
	    return EmptyError;
	}(Error));
	var EmptyError_2 = EmptyError$1;


	var EmptyError_1$2 = {
		EmptyError: EmptyError_2
	};

	var __extends$72 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1$26 = Subscriber_1$3;
	var EmptyError_1$1 = EmptyError_1$2;
	/**
	 * Emits only the first value (or the first value that meets some condition)
	 * emitted by the source Observable.
	 *
	 * <span class="informal">Emits only the first value. Or emits only the first
	 * value that passes some test.</span>
	 *
	 * <img src="./img/first.png" width="100%">
	 *
	 * If called with no arguments, `first` emits the first value of the source
	 * Observable, then completes. If called with a `predicate` function, `first`
	 * emits the first value of the source that matches the specified condition. It
	 * may also take a `resultSelector` function to produce the output value from
	 * the input value, and a `defaultValue` to emit in case the source completes
	 * before it is able to emit a valid value. Throws an error if `defaultValue`
	 * was not provided and a matching element is not found.
	 *
	 * @example <caption>Emit only the first click that happens on the DOM</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = clicks.first();
	 * result.subscribe(x => console.log(x));
	 *
	 * @example <caption>Emits the first click that happens on a DIV</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = clicks.first(ev => ev.target.tagName === 'DIV');
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link filter}
	 * @see {@link find}
	 * @see {@link take}
	 *
	 * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`
	 * callback if the Observable completes before any `next` notification was sent.
	 *
	 * @param {function(value: T, index: number, source: Observable<T>): boolean} [predicate]
	 * An optional function called with each item to test for condition matching.
	 * @param {function(value: T, index: number): R} [resultSelector] A function to
	 * produce the value on the output Observable based on the values
	 * and the indices of the source Observable. The arguments passed to this
	 * function are:
	 * - `value`: the value that was emitted on the source.
	 * - `index`: the "index" of the value from the source.
	 * @param {R} [defaultValue] The default value emitted in case no valid value
	 * was found on the source.
	 * @return {Observable<T|R>} An Observable of the first item that matches the
	 * condition.
	 * @method first
	 * @owner Observable
	 */
	function first$4(predicate, resultSelector, defaultValue) {
	    return this.lift(new FirstOperator(predicate, resultSelector, defaultValue, this));
	}
	var first_2 = first$4;
	var FirstOperator = (function () {
	    function FirstOperator(predicate, resultSelector, defaultValue, source) {
	        this.predicate = predicate;
	        this.resultSelector = resultSelector;
	        this.defaultValue = defaultValue;
	        this.source = source;
	    }
	    FirstOperator.prototype.call = function (observer, source) {
	        return source.subscribe(new FirstSubscriber(observer, this.predicate, this.resultSelector, this.defaultValue, this.source));
	    };
	    return FirstOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var FirstSubscriber = (function (_super) {
	    __extends$72(FirstSubscriber, _super);
	    function FirstSubscriber(destination, predicate, resultSelector, defaultValue, source) {
	        _super.call(this, destination);
	        this.predicate = predicate;
	        this.resultSelector = resultSelector;
	        this.defaultValue = defaultValue;
	        this.source = source;
	        this.index = 0;
	        this.hasCompleted = false;
	        this._emitted = false;
	    }
	    FirstSubscriber.prototype._next = function (value) {
	        var index = this.index++;
	        if (this.predicate) {
	            this._tryPredicate(value, index);
	        }
	        else {
	            this._emit(value, index);
	        }
	    };
	    FirstSubscriber.prototype._tryPredicate = function (value, index) {
	        var result;
	        try {
	            result = this.predicate(value, index, this.source);
	        }
	        catch (err) {
	            this.destination.error(err);
	            return;
	        }
	        if (result) {
	            this._emit(value, index);
	        }
	    };
	    FirstSubscriber.prototype._emit = function (value, index) {
	        if (this.resultSelector) {
	            this._tryResultSelector(value, index);
	            return;
	        }
	        this._emitFinal(value);
	    };
	    FirstSubscriber.prototype._tryResultSelector = function (value, index) {
	        var result;
	        try {
	            result = this.resultSelector(value, index);
	        }
	        catch (err) {
	            this.destination.error(err);
	            return;
	        }
	        this._emitFinal(result);
	    };
	    FirstSubscriber.prototype._emitFinal = function (value) {
	        var destination = this.destination;
	        if (!this._emitted) {
	            this._emitted = true;
	            destination.next(value);
	            destination.complete();
	            this.hasCompleted = true;
	        }
	    };
	    FirstSubscriber.prototype._complete = function () {
	        var destination = this.destination;
	        if (!this.hasCompleted && typeof this.defaultValue !== 'undefined') {
	            destination.next(this.defaultValue);
	            destination.complete();
	        }
	        else if (!this.hasCompleted) {
	            destination.error(new EmptyError_1$1.EmptyError);
	        }
	    };
	    return FirstSubscriber;
	}(Subscriber_1$26.Subscriber));


	var first_1$1 = {
		first: first_2
	};

	var Observable_1$91 = Observable_1$2;
	var first_1 = first_1$1;
	Observable_1$91.Observable.prototype.first = first_1.first;

	var MapPolyfill = (function () {
	    function MapPolyfill() {
	        this.size = 0;
	        this._values = [];
	        this._keys = [];
	    }
	    MapPolyfill.prototype.get = function (key) {
	        var i = this._keys.indexOf(key);
	        return i === -1 ? undefined : this._values[i];
	    };
	    MapPolyfill.prototype.set = function (key, value) {
	        var i = this._keys.indexOf(key);
	        if (i === -1) {
	            this._keys.push(key);
	            this._values.push(value);
	            this.size++;
	        }
	        else {
	            this._values[i] = value;
	        }
	        return this;
	    };
	    MapPolyfill.prototype.delete = function (key) {
	        var i = this._keys.indexOf(key);
	        if (i === -1) {
	            return false;
	        }
	        this._values.splice(i, 1);
	        this._keys.splice(i, 1);
	        this.size--;
	        return true;
	    };
	    MapPolyfill.prototype.clear = function () {
	        this._keys.length = 0;
	        this._values.length = 0;
	        this.size = 0;
	    };
	    MapPolyfill.prototype.forEach = function (cb, thisArg) {
	        for (var i = 0; i < this.size; i++) {
	            cb.call(thisArg, this._values[i], this._keys[i]);
	        }
	    };
	    return MapPolyfill;
	}());
	var MapPolyfill_2 = MapPolyfill;


	var MapPolyfill_1$1 = {
		MapPolyfill: MapPolyfill_2
	};

	var root_1$10 = root$1;
	var MapPolyfill_1 = MapPolyfill_1$1;
	var Map = root_1$10.root.Map || (function () { return MapPolyfill_1.MapPolyfill; })();


	var _Map$2 = {
		Map: Map
	};

	var FastMap = (function () {
	    function FastMap() {
	        this.values = {};
	    }
	    FastMap.prototype.delete = function (key) {
	        this.values[key] = null;
	        return true;
	    };
	    FastMap.prototype.set = function (key, value) {
	        this.values[key] = value;
	        return this;
	    };
	    FastMap.prototype.get = function (key) {
	        return this.values[key];
	    };
	    FastMap.prototype.forEach = function (cb, thisArg) {
	        var values = this.values;
	        for (var key in values) {
	            if (values.hasOwnProperty(key) && values[key] !== null) {
	                cb.call(thisArg, values[key], key);
	            }
	        }
	    };
	    FastMap.prototype.clear = function () {
	        this.values = {};
	    };
	    return FastMap;
	}());
	var FastMap_2 = FastMap;


	var FastMap_1$1 = {
		FastMap: FastMap_2
	};

	var __extends$74 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1$27 = Subscriber_1$3;
	var Subscription_1$15 = Subscription_1$3;
	var Observable_1$93 = Observable_1$2;
	var Subject_1$6 = Subject_1$1;
	var Map_1 = _Map$2;
	var FastMap_1 = FastMap_1$1;
	/* tslint:enable:max-line-length */
	/**
	 * Groups the items emitted by an Observable according to a specified criterion,
	 * and emits these grouped items as `GroupedObservables`, one
	 * {@link GroupedObservable} per group.
	 *
	 * <img src="./img/groupBy.png" width="100%">
	 *
	 * @example <caption>Group objects by id and return as array</caption>
	 * Observable.of<Obj>({id: 1, name: 'aze1'},
	 *                    {id: 2, name: 'sf2'},
	 *                    {id: 2, name: 'dg2'},
	 *                    {id: 1, name: 'erg1'},
	 *                    {id: 1, name: 'df1'},
	 *                    {id: 2, name: 'sfqfb2'},
	 *                    {id: 3, name: 'qfs3'},
	 *                    {id: 2, name: 'qsgqsfg2'}
	 *     )
	 *     .groupBy(p => p.id)
	 *     .flatMap( (group$) => group$.reduce((acc, cur) => [...acc, cur], []))
	 *     .subscribe(p => console.log(p));
	 *
	 * // displays:
	 * // [ { id: 1, name: 'aze1' },
	 * //   { id: 1, name: 'erg1' },
	 * //   { id: 1, name: 'df1' } ]
	 * //
	 * // [ { id: 2, name: 'sf2' },
	 * //   { id: 2, name: 'dg2' },
	 * //   { id: 2, name: 'sfqfb2' },
	 * //   { id: 2, name: 'qsgqsfg2' } ]
	 * //
	 * // [ { id: 3, name: 'qfs3' } ]
	 *
	 * @example <caption>Pivot data on the id field</caption>
	 * Observable.of<Obj>({id: 1, name: 'aze1'},
	 *                    {id: 2, name: 'sf2'},
	 *                    {id: 2, name: 'dg2'},
	 *                    {id: 1, name: 'erg1'},
	 *                    {id: 1, name: 'df1'},
	 *                    {id: 2, name: 'sfqfb2'},
	 *                    {id: 3, name: 'qfs1'},
	 *                    {id: 2, name: 'qsgqsfg2'}
	 *                   )
	 *     .groupBy(p => p.id, p => p.anme)
	 *     .flatMap( (group$) => group$.reduce((acc, cur) => [...acc, cur], ["" + group$.key]))
	 *     .map(arr => ({'id': parseInt(arr[0]), 'values': arr.slice(1)}))
	 *     .subscribe(p => console.log(p));
	 *
	 * // displays:
	 * // { id: 1, values: [ 'aze1', 'erg1', 'df1' ] }
	 * // { id: 2, values: [ 'sf2', 'dg2', 'sfqfb2', 'qsgqsfg2' ] }
	 * // { id: 3, values: [ 'qfs1' ] }
	 *
	 * @param {function(value: T): K} keySelector A function that extracts the key
	 * for each item.
	 * @param {function(value: T): R} [elementSelector] A function that extracts the
	 * return element for each item.
	 * @param {function(grouped: GroupedObservable<K,R>): Observable<any>} [durationSelector]
	 * A function that returns an Observable to determine how long each group should
	 * exist.
	 * @return {Observable<GroupedObservable<K,R>>} An Observable that emits
	 * GroupedObservables, each of which corresponds to a unique key value and each
	 * of which emits those items from the source Observable that share that key
	 * value.
	 * @method groupBy
	 * @owner Observable
	 */
	function groupBy$3(keySelector, elementSelector, durationSelector, subjectSelector) {
	    return this.lift(new GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector));
	}
	var groupBy_2 = groupBy$3;
	var GroupByOperator = (function () {
	    function GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector) {
	        this.keySelector = keySelector;
	        this.elementSelector = elementSelector;
	        this.durationSelector = durationSelector;
	        this.subjectSelector = subjectSelector;
	    }
	    GroupByOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new GroupBySubscriber(subscriber, this.keySelector, this.elementSelector, this.durationSelector, this.subjectSelector));
	    };
	    return GroupByOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var GroupBySubscriber = (function (_super) {
	    __extends$74(GroupBySubscriber, _super);
	    function GroupBySubscriber(destination, keySelector, elementSelector, durationSelector, subjectSelector) {
	        _super.call(this, destination);
	        this.keySelector = keySelector;
	        this.elementSelector = elementSelector;
	        this.durationSelector = durationSelector;
	        this.subjectSelector = subjectSelector;
	        this.groups = null;
	        this.attemptedToUnsubscribe = false;
	        this.count = 0;
	    }
	    GroupBySubscriber.prototype._next = function (value) {
	        var key;
	        try {
	            key = this.keySelector(value);
	        }
	        catch (err) {
	            this.error(err);
	            return;
	        }
	        this._group(value, key);
	    };
	    GroupBySubscriber.prototype._group = function (value, key) {
	        var groups = this.groups;
	        if (!groups) {
	            groups = this.groups = typeof key === 'string' ? new FastMap_1.FastMap() : new Map_1.Map();
	        }
	        var group = groups.get(key);
	        var element;
	        if (this.elementSelector) {
	            try {
	                element = this.elementSelector(value);
	            }
	            catch (err) {
	                this.error(err);
	            }
	        }
	        else {
	            element = value;
	        }
	        if (!group) {
	            group = this.subjectSelector ? this.subjectSelector() : new Subject_1$6.Subject();
	            groups.set(key, group);
	            var groupedObservable = new GroupedObservable(key, group, this);
	            this.destination.next(groupedObservable);
	            if (this.durationSelector) {
	                var duration = void 0;
	                try {
	                    duration = this.durationSelector(new GroupedObservable(key, group));
	                }
	                catch (err) {
	                    this.error(err);
	                    return;
	                }
	                this.add(duration.subscribe(new GroupDurationSubscriber(key, group, this)));
	            }
	        }
	        if (!group.closed) {
	            group.next(element);
	        }
	    };
	    GroupBySubscriber.prototype._error = function (err) {
	        var groups = this.groups;
	        if (groups) {
	            groups.forEach(function (group, key) {
	                group.error(err);
	            });
	            groups.clear();
	        }
	        this.destination.error(err);
	    };
	    GroupBySubscriber.prototype._complete = function () {
	        var groups = this.groups;
	        if (groups) {
	            groups.forEach(function (group, key) {
	                group.complete();
	            });
	            groups.clear();
	        }
	        this.destination.complete();
	    };
	    GroupBySubscriber.prototype.removeGroup = function (key) {
	        this.groups.delete(key);
	    };
	    GroupBySubscriber.prototype.unsubscribe = function () {
	        if (!this.closed) {
	            this.attemptedToUnsubscribe = true;
	            if (this.count === 0) {
	                _super.prototype.unsubscribe.call(this);
	            }
	        }
	    };
	    return GroupBySubscriber;
	}(Subscriber_1$27.Subscriber));
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var GroupDurationSubscriber = (function (_super) {
	    __extends$74(GroupDurationSubscriber, _super);
	    function GroupDurationSubscriber(key, group, parent) {
	        _super.call(this);
	        this.key = key;
	        this.group = group;
	        this.parent = parent;
	    }
	    GroupDurationSubscriber.prototype._next = function (value) {
	        this._complete();
	    };
	    GroupDurationSubscriber.prototype._error = function (err) {
	        var group = this.group;
	        if (!group.closed) {
	            group.error(err);
	        }
	        this.parent.removeGroup(this.key);
	    };
	    GroupDurationSubscriber.prototype._complete = function () {
	        var group = this.group;
	        if (!group.closed) {
	            group.complete();
	        }
	        this.parent.removeGroup(this.key);
	    };
	    return GroupDurationSubscriber;
	}(Subscriber_1$27.Subscriber));
	/**
	 * An Observable representing values belonging to the same group represented by
	 * a common key. The values emitted by a GroupedObservable come from the source
	 * Observable. The common key is available as the field `key` on a
	 * GroupedObservable instance.
	 *
	 * @class GroupedObservable<K, T>
	 */
	var GroupedObservable = (function (_super) {
	    __extends$74(GroupedObservable, _super);
	    function GroupedObservable(key, groupSubject, refCountSubscription) {
	        _super.call(this);
	        this.key = key;
	        this.groupSubject = groupSubject;
	        this.refCountSubscription = refCountSubscription;
	    }
	    GroupedObservable.prototype._subscribe = function (subscriber) {
	        var subscription = new Subscription_1$15.Subscription();
	        var _a = this, refCountSubscription = _a.refCountSubscription, groupSubject = _a.groupSubject;
	        if (refCountSubscription && !refCountSubscription.closed) {
	            subscription.add(new InnerRefCountSubscription(refCountSubscription));
	        }
	        subscription.add(groupSubject.subscribe(subscriber));
	        return subscription;
	    };
	    return GroupedObservable;
	}(Observable_1$93.Observable));
	var GroupedObservable_1 = GroupedObservable;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var InnerRefCountSubscription = (function (_super) {
	    __extends$74(InnerRefCountSubscription, _super);
	    function InnerRefCountSubscription(parent) {
	        _super.call(this);
	        this.parent = parent;
	        parent.count++;
	    }
	    InnerRefCountSubscription.prototype.unsubscribe = function () {
	        var parent = this.parent;
	        if (!parent.closed && !this.closed) {
	            _super.prototype.unsubscribe.call(this);
	            parent.count -= 1;
	            if (parent.count === 0 && parent.attemptedToUnsubscribe) {
	                parent.unsubscribe();
	            }
	        }
	    };
	    return InnerRefCountSubscription;
	}(Subscription_1$15.Subscription));


	var groupBy_1$2 = {
		groupBy: groupBy_2,
		GroupedObservable: GroupedObservable_1
	};

	var Observable_1$92 = Observable_1$2;
	var groupBy_1$1 = groupBy_1$2;
	Observable_1$92.Observable.prototype.groupBy = groupBy_1$1.groupBy;

	var __extends$75 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1$28 = Subscriber_1$3;
	var noop_1$4 = noop_1$2;
	/**
	 * Ignores all items emitted by the source Observable and only passes calls of `complete` or `error`.
	 *
	 * <img src="./img/ignoreElements.png" width="100%">
	 *
	 * @return {Observable} An empty Observable that only calls `complete`
	 * or `error`, based on which one is called by the source Observable.
	 * @method ignoreElements
	 * @owner Observable
	 */
	function ignoreElements$2() {
	    return this.lift(new IgnoreElementsOperator());
	}
	var ignoreElements_2 = ignoreElements$2;

	var IgnoreElementsOperator = (function () {
	    function IgnoreElementsOperator() {
	    }
	    IgnoreElementsOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new IgnoreElementsSubscriber(subscriber));
	    };
	    return IgnoreElementsOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var IgnoreElementsSubscriber = (function (_super) {
	    __extends$75(IgnoreElementsSubscriber, _super);
	    function IgnoreElementsSubscriber() {
	        _super.apply(this, arguments);
	    }
	    IgnoreElementsSubscriber.prototype._next = function (unused) {
	        noop_1$4.noop();
	    };
	    return IgnoreElementsSubscriber;
	}(Subscriber_1$28.Subscriber));


	var ignoreElements_1$1 = {
		ignoreElements: ignoreElements_2
	};

	var Observable_1$94 = Observable_1$2;
	var ignoreElements_1 = ignoreElements_1$1;
	Observable_1$94.Observable.prototype.ignoreElements = ignoreElements_1.ignoreElements;

	var __extends$76 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1$29 = Subscriber_1$3;
	/**
	 * If the source Observable is empty it returns an Observable that emits true, otherwise it emits false.
	 *
	 * <img src="./img/isEmpty.png" width="100%">
	 *
	 * @return {Observable} An Observable that emits a Boolean.
	 * @method isEmpty
	 * @owner Observable
	 */
	function isEmpty$3() {
	    return this.lift(new IsEmptyOperator());
	}
	var isEmpty_2 = isEmpty$3;
	var IsEmptyOperator = (function () {
	    function IsEmptyOperator() {
	    }
	    IsEmptyOperator.prototype.call = function (observer, source) {
	        return source.subscribe(new IsEmptySubscriber(observer));
	    };
	    return IsEmptyOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var IsEmptySubscriber = (function (_super) {
	    __extends$76(IsEmptySubscriber, _super);
	    function IsEmptySubscriber(destination) {
	        _super.call(this, destination);
	    }
	    IsEmptySubscriber.prototype.notifyComplete = function (isEmpty) {
	        var destination = this.destination;
	        destination.next(isEmpty);
	        destination.complete();
	    };
	    IsEmptySubscriber.prototype._next = function (value) {
	        this.notifyComplete(false);
	    };
	    IsEmptySubscriber.prototype._complete = function () {
	        this.notifyComplete(true);
	    };
	    return IsEmptySubscriber;
	}(Subscriber_1$29.Subscriber));


	var isEmpty_1$2 = {
		isEmpty: isEmpty_2
	};

	var Observable_1$95 = Observable_1$2;
	var isEmpty_1$1 = isEmpty_1$2;
	Observable_1$95.Observable.prototype.isEmpty = isEmpty_1$1.isEmpty;

	var __extends$77 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var tryCatch_1$11 = tryCatch_1$1;
	var errorObject_1$11 = errorObject;
	var OuterSubscriber_1$23 = OuterSubscriber_1$1;
	var subscribeToResult_1$23 = subscribeToResult_1$1;
	/**
	 * Ignores source values for a duration determined by another Observable, then
	 * emits the most recent value from the source Observable, then repeats this
	 * process.
	 *
	 * <span class="informal">It's like {@link auditTime}, but the silencing
	 * duration is determined by a second Observable.</span>
	 *
	 * <img src="./img/audit.png" width="100%">
	 *
	 * `audit` is similar to `throttle`, but emits the last value from the silenced
	 * time window, instead of the first value. `audit` emits the most recent value
	 * from the source Observable on the output Observable as soon as its internal
	 * timer becomes disabled, and ignores source values while the timer is enabled.
	 * Initially, the timer is disabled. As soon as the first source value arrives,
	 * the timer is enabled by calling the `durationSelector` function with the
	 * source value, which returns the "duration" Observable. When the duration
	 * Observable emits a value or completes, the timer is disabled, then the most
	 * recent source value is emitted on the output Observable, and this process
	 * repeats for the next source value.
	 *
	 * @example <caption>Emit clicks at a rate of at most one click per second</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = clicks.audit(ev => Rx.Observable.interval(1000));
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link auditTime}
	 * @see {@link debounce}
	 * @see {@link delayWhen}
	 * @see {@link sample}
	 * @see {@link throttle}
	 *
	 * @param {function(value: T): SubscribableOrPromise} durationSelector A function
	 * that receives a value from the source Observable, for computing the silencing
	 * duration, returned as an Observable or a Promise.
	 * @return {Observable<T>} An Observable that performs rate-limiting of
	 * emissions from the source Observable.
	 * @method audit
	 * @owner Observable
	 */
	function audit$2(durationSelector) {
	    return this.lift(new AuditOperator(durationSelector));
	}
	var audit_2 = audit$2;
	var AuditOperator = (function () {
	    function AuditOperator(durationSelector) {
	        this.durationSelector = durationSelector;
	    }
	    AuditOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new AuditSubscriber(subscriber, this.durationSelector));
	    };
	    return AuditOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var AuditSubscriber = (function (_super) {
	    __extends$77(AuditSubscriber, _super);
	    function AuditSubscriber(destination, durationSelector) {
	        _super.call(this, destination);
	        this.durationSelector = durationSelector;
	        this.hasValue = false;
	    }
	    AuditSubscriber.prototype._next = function (value) {
	        this.value = value;
	        this.hasValue = true;
	        if (!this.throttled) {
	            var duration = tryCatch_1$11.tryCatch(this.durationSelector)(value);
	            if (duration === errorObject_1$11.errorObject) {
	                this.destination.error(errorObject_1$11.errorObject.e);
	            }
	            else {
	                this.add(this.throttled = subscribeToResult_1$23.subscribeToResult(this, duration));
	            }
	        }
	    };
	    AuditSubscriber.prototype.clearThrottle = function () {
	        var _a = this, value = _a.value, hasValue = _a.hasValue, throttled = _a.throttled;
	        if (throttled) {
	            this.remove(throttled);
	            this.throttled = null;
	            throttled.unsubscribe();
	        }
	        if (hasValue) {
	            this.value = null;
	            this.hasValue = false;
	            this.destination.next(value);
	        }
	    };
	    AuditSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex) {
	        this.clearThrottle();
	    };
	    AuditSubscriber.prototype.notifyComplete = function () {
	        this.clearThrottle();
	    };
	    return AuditSubscriber;
	}(OuterSubscriber_1$23.OuterSubscriber));


	var audit_1$1 = {
		audit: audit_2
	};

	var Observable_1$96 = Observable_1$2;
	var audit_1 = audit_1$1;
	Observable_1$96.Observable.prototype.audit = audit_1.audit;

	var __extends$78 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var async_1$7 = async;
	var Subscriber_1$30 = Subscriber_1$3;
	/**
	 * Ignores source values for `duration` milliseconds, then emits the most recent
	 * value from the source Observable, then repeats this process.
	 *
	 * <span class="informal">When it sees a source values, it ignores that plus
	 * the next ones for `duration` milliseconds, and then it emits the most recent
	 * value from the source.</span>
	 *
	 * <img src="./img/auditTime.png" width="100%">
	 *
	 * `auditTime` is similar to `throttleTime`, but emits the last value from the
	 * silenced time window, instead of the first value. `auditTime` emits the most
	 * recent value from the source Observable on the output Observable as soon as
	 * its internal timer becomes disabled, and ignores source values while the
	 * timer is enabled. Initially, the timer is disabled. As soon as the first
	 * source value arrives, the timer is enabled. After `duration` milliseconds (or
	 * the time unit determined internally by the optional `scheduler`) has passed,
	 * the timer is disabled, then the most recent source value is emitted on the
	 * output Observable, and this process repeats for the next source value.
	 * Optionally takes a {@link IScheduler} for managing timers.
	 *
	 * @example <caption>Emit clicks at a rate of at most one click per second</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = clicks.auditTime(1000);
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link audit}
	 * @see {@link debounceTime}
	 * @see {@link delay}
	 * @see {@link sampleTime}
	 * @see {@link throttleTime}
	 *
	 * @param {number} duration Time to wait before emitting the most recent source
	 * value, measured in milliseconds or the time unit determined internally
	 * by the optional `scheduler`.
	 * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for
	 * managing the timers that handle the rate-limiting behavior.
	 * @return {Observable<T>} An Observable that performs rate-limiting of
	 * emissions from the source Observable.
	 * @method auditTime
	 * @owner Observable
	 */
	function auditTime$2(duration, scheduler) {
	    if (scheduler === void 0) { scheduler = async_1$7.async; }
	    return this.lift(new AuditTimeOperator(duration, scheduler));
	}
	var auditTime_2 = auditTime$2;
	var AuditTimeOperator = (function () {
	    function AuditTimeOperator(duration, scheduler) {
	        this.duration = duration;
	        this.scheduler = scheduler;
	    }
	    AuditTimeOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new AuditTimeSubscriber(subscriber, this.duration, this.scheduler));
	    };
	    return AuditTimeOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var AuditTimeSubscriber = (function (_super) {
	    __extends$78(AuditTimeSubscriber, _super);
	    function AuditTimeSubscriber(destination, duration, scheduler) {
	        _super.call(this, destination);
	        this.duration = duration;
	        this.scheduler = scheduler;
	        this.hasValue = false;
	    }
	    AuditTimeSubscriber.prototype._next = function (value) {
	        this.value = value;
	        this.hasValue = true;
	        if (!this.throttled) {
	            this.add(this.throttled = this.scheduler.schedule(dispatchNext$4, this.duration, this));
	        }
	    };
	    AuditTimeSubscriber.prototype.clearThrottle = function () {
	        var _a = this, value = _a.value, hasValue = _a.hasValue, throttled = _a.throttled;
	        if (throttled) {
	            this.remove(throttled);
	            this.throttled = null;
	            throttled.unsubscribe();
	        }
	        if (hasValue) {
	            this.value = null;
	            this.hasValue = false;
	            this.destination.next(value);
	        }
	    };
	    return AuditTimeSubscriber;
	}(Subscriber_1$30.Subscriber));
	function dispatchNext$4(subscriber) {
	    subscriber.clearThrottle();
	}


	var auditTime_1$1 = {
		auditTime: auditTime_2
	};

	var Observable_1$97 = Observable_1$2;
	var auditTime_1 = auditTime_1$1;
	Observable_1$97.Observable.prototype.auditTime = auditTime_1.auditTime;

	var __extends$79 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1$31 = Subscriber_1$3;
	var EmptyError_1$4 = EmptyError_1$2;
	/* tslint:enable:max-line-length */
	/**
	 * Returns an Observable that emits only the last item emitted by the source Observable.
	 * It optionally takes a predicate function as a parameter, in which case, rather than emitting
	 * the last item from the source Observable, the resulting Observable will emit the last item
	 * from the source Observable that satisfies the predicate.
	 *
	 * <img src="./img/last.png" width="100%">
	 *
	 * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`
	 * callback if the Observable completes before any `next` notification was sent.
	 * @param {function} predicate - The condition any source emitted item has to satisfy.
	 * @return {Observable} An Observable that emits only the last item satisfying the given condition
	 * from the source, or an NoSuchElementException if no such items are emitted.
	 * @throws - Throws if no items that match the predicate are emitted by the source Observable.
	 * @method last
	 * @owner Observable
	 */
	function last$3(predicate, resultSelector, defaultValue) {
	    return this.lift(new LastOperator(predicate, resultSelector, defaultValue, this));
	}
	var last_2 = last$3;
	var LastOperator = (function () {
	    function LastOperator(predicate, resultSelector, defaultValue, source) {
	        this.predicate = predicate;
	        this.resultSelector = resultSelector;
	        this.defaultValue = defaultValue;
	        this.source = source;
	    }
	    LastOperator.prototype.call = function (observer, source) {
	        return source.subscribe(new LastSubscriber(observer, this.predicate, this.resultSelector, this.defaultValue, this.source));
	    };
	    return LastOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var LastSubscriber = (function (_super) {
	    __extends$79(LastSubscriber, _super);
	    function LastSubscriber(destination, predicate, resultSelector, defaultValue, source) {
	        _super.call(this, destination);
	        this.predicate = predicate;
	        this.resultSelector = resultSelector;
	        this.defaultValue = defaultValue;
	        this.source = source;
	        this.hasValue = false;
	        this.index = 0;
	        if (typeof defaultValue !== 'undefined') {
	            this.lastValue = defaultValue;
	            this.hasValue = true;
	        }
	    }
	    LastSubscriber.prototype._next = function (value) {
	        var index = this.index++;
	        if (this.predicate) {
	            this._tryPredicate(value, index);
	        }
	        else {
	            if (this.resultSelector) {
	                this._tryResultSelector(value, index);
	                return;
	            }
	            this.lastValue = value;
	            this.hasValue = true;
	        }
	    };
	    LastSubscriber.prototype._tryPredicate = function (value, index) {
	        var result;
	        try {
	            result = this.predicate(value, index, this.source);
	        }
	        catch (err) {
	            this.destination.error(err);
	            return;
	        }
	        if (result) {
	            if (this.resultSelector) {
	                this._tryResultSelector(value, index);
	                return;
	            }
	            this.lastValue = value;
	            this.hasValue = true;
	        }
	    };
	    LastSubscriber.prototype._tryResultSelector = function (value, index) {
	        var result;
	        try {
	            result = this.resultSelector(value, index);
	        }
	        catch (err) {
	            this.destination.error(err);
	            return;
	        }
	        this.lastValue = result;
	        this.hasValue = true;
	    };
	    LastSubscriber.prototype._complete = function () {
	        var destination = this.destination;
	        if (this.hasValue) {
	            destination.next(this.lastValue);
	            destination.complete();
	        }
	        else {
	            destination.error(new EmptyError_1$4.EmptyError);
	        }
	    };
	    return LastSubscriber;
	}(Subscriber_1$31.Subscriber));


	var last_1$2 = {
		last: last_2
	};

	var Observable_1$98 = Observable_1$2;
	var last_1$1 = last_1$2;
	Observable_1$98.Observable.prototype.last = last_1$1.last;

	/**
	 * @param func
	 * @return {Observable<R>}
	 * @method let
	 * @owner Observable
	 */
	function letProto(func) {
	    return func(this);
	}
	var letProto_1 = letProto;


	var _let$2 = {
		letProto: letProto_1
	};

	var Observable_1$99 = Observable_1$2;
	var let_1 = _let$2;
	Observable_1$99.Observable.prototype.let = let_1.letProto;
	Observable_1$99.Observable.prototype.letBind = let_1.letProto;

	var __extends$80 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1$32 = Subscriber_1$3;
	/**
	 * Returns an Observable that emits whether or not every item of the source satisfies the condition specified.
	 *
	 * @example <caption>A simple example emitting true if all elements are less than 5, false otherwise</caption>
	 *  Observable.of(1, 2, 3, 4, 5, 6)
	 *     .every(x => x < 5)
	 *     .subscribe(x => console.log(x)); // -> false
	 *
	 * @param {function} predicate A function for determining if an item meets a specified condition.
	 * @param {any} [thisArg] Optional object to use for `this` in the callback.
	 * @return {Observable} An Observable of booleans that determines if all items of the source Observable meet the condition specified.
	 * @method every
	 * @owner Observable
	 */
	function every$3(predicate, thisArg) {
	    return this.lift(new EveryOperator(predicate, thisArg, this));
	}
	var every_2 = every$3;
	var EveryOperator = (function () {
	    function EveryOperator(predicate, thisArg, source) {
	        this.predicate = predicate;
	        this.thisArg = thisArg;
	        this.source = source;
	    }
	    EveryOperator.prototype.call = function (observer, source) {
	        return source.subscribe(new EverySubscriber(observer, this.predicate, this.thisArg, this.source));
	    };
	    return EveryOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var EverySubscriber = (function (_super) {
	    __extends$80(EverySubscriber, _super);
	    function EverySubscriber(destination, predicate, thisArg, source) {
	        _super.call(this, destination);
	        this.predicate = predicate;
	        this.thisArg = thisArg;
	        this.source = source;
	        this.index = 0;
	        this.thisArg = thisArg || this;
	    }
	    EverySubscriber.prototype.notifyComplete = function (everyValueMatch) {
	        this.destination.next(everyValueMatch);
	        this.destination.complete();
	    };
	    EverySubscriber.prototype._next = function (value) {
	        var result = false;
	        try {
	            result = this.predicate.call(this.thisArg, value, this.index++, this.source);
	        }
	        catch (err) {
	            this.destination.error(err);
	            return;
	        }
	        if (!result) {
	            this.notifyComplete(false);
	        }
	    };
	    EverySubscriber.prototype._complete = function () {
	        this.notifyComplete(true);
	    };
	    return EverySubscriber;
	}(Subscriber_1$32.Subscriber));


	var every_1$2 = {
		every: every_2
	};

	var Observable_1$100 = Observable_1$2;
	var every_1$1 = every_1$2;
	Observable_1$100.Observable.prototype.every = every_1$1.every;

	var Observable_1$101 = Observable_1$2;
	var map_1$4 = map_1$2;
	Observable_1$101.Observable.prototype.map = map_1$4.map;

	var __extends$81 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1$33 = Subscriber_1$3;
	/**
	 * Emits the given constant value on the output Observable every time the source
	 * Observable emits a value.
	 *
	 * <span class="informal">Like {@link map}, but it maps every source value to
	 * the same output value every time.</span>
	 *
	 * <img src="./img/mapTo.png" width="100%">
	 *
	 * Takes a constant `value` as argument, and emits that whenever the source
	 * Observable emits a value. In other words, ignores the actual source value,
	 * and simply uses the emission moment to know when to emit the given `value`.
	 *
	 * @example <caption>Map every every click to the string 'Hi'</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var greetings = clicks.mapTo('Hi');
	 * greetings.subscribe(x => console.log(x));
	 *
	 * @see {@link map}
	 *
	 * @param {any} value The value to map each source value to.
	 * @return {Observable} An Observable that emits the given `value` every time
	 * the source Observable emits something.
	 * @method mapTo
	 * @owner Observable
	 */
	function mapTo$2(value) {
	    return this.lift(new MapToOperator(value));
	}
	var mapTo_2 = mapTo$2;
	var MapToOperator = (function () {
	    function MapToOperator(value) {
	        this.value = value;
	    }
	    MapToOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new MapToSubscriber(subscriber, this.value));
	    };
	    return MapToOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var MapToSubscriber = (function (_super) {
	    __extends$81(MapToSubscriber, _super);
	    function MapToSubscriber(destination, value) {
	        _super.call(this, destination);
	        this.value = value;
	    }
	    MapToSubscriber.prototype._next = function (x) {
	        this.destination.next(this.value);
	    };
	    return MapToSubscriber;
	}(Subscriber_1$33.Subscriber));


	var mapTo_1$1 = {
		mapTo: mapTo_2
	};

	var Observable_1$102 = Observable_1$2;
	var mapTo_1 = mapTo_1$1;
	Observable_1$102.Observable.prototype.mapTo = mapTo_1.mapTo;

	var __extends$82 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1$34 = Subscriber_1$3;
	var Notification_1$5 = Notification_1$2;
	/**
	 * Represents all of the notifications from the source Observable as `next`
	 * emissions marked with their original types within {@link Notification}
	 * objects.
	 *
	 * <span class="informal">Wraps `next`, `error` and `complete` emissions in
	 * {@link Notification} objects, emitted as `next` on the output Observable.
	 * </span>
	 *
	 * <img src="./img/materialize.png" width="100%">
	 *
	 * `materialize` returns an Observable that emits a `next` notification for each
	 * `next`, `error`, or `complete` emission of the source Observable. When the
	 * source Observable emits `complete`, the output Observable will emit `next` as
	 * a Notification of type "complete", and then it will emit `complete` as well.
	 * When the source Observable emits `error`, the output will emit `next` as a
	 * Notification of type "error", and then `complete`.
	 *
	 * This operator is useful for producing metadata of the source Observable, to
	 * be consumed as `next` emissions. Use it in conjunction with
	 * {@link dematerialize}.
	 *
	 * @example <caption>Convert a faulty Observable to an Observable of Notifications</caption>
	 * var letters = Rx.Observable.of('a', 'b', 13, 'd');
	 * var upperCase = letters.map(x => x.toUpperCase());
	 * var materialized = upperCase.materialize();
	 * materialized.subscribe(x => console.log(x));
	 *
	 * // Results in the following:
	 * // - Notification {kind: "N", value: "A", error: undefined, hasValue: true}
	 * // - Notification {kind: "N", value: "B", error: undefined, hasValue: true}
	 * // - Notification {kind: "E", value: undefined, error: TypeError:
	 * //   x.toUpperCase is not a function at MapSubscriber.letters.map.x
	 * //   [as project] (http://1, hasValue: false}
	 *
	 * @see {@link Notification}
	 * @see {@link dematerialize}
	 *
	 * @return {Observable<Notification<T>>} An Observable that emits
	 * {@link Notification} objects that wrap the original emissions from the source
	 * Observable with metadata.
	 * @method materialize
	 * @owner Observable
	 */
	function materialize$2() {
	    return this.lift(new MaterializeOperator());
	}
	var materialize_2 = materialize$2;
	var MaterializeOperator = (function () {
	    function MaterializeOperator() {
	    }
	    MaterializeOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new MaterializeSubscriber(subscriber));
	    };
	    return MaterializeOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var MaterializeSubscriber = (function (_super) {
	    __extends$82(MaterializeSubscriber, _super);
	    function MaterializeSubscriber(destination) {
	        _super.call(this, destination);
	    }
	    MaterializeSubscriber.prototype._next = function (value) {
	        this.destination.next(Notification_1$5.Notification.createNext(value));
	    };
	    MaterializeSubscriber.prototype._error = function (err) {
	        var destination = this.destination;
	        destination.next(Notification_1$5.Notification.createError(err));
	        destination.complete();
	    };
	    MaterializeSubscriber.prototype._complete = function () {
	        var destination = this.destination;
	        destination.next(Notification_1$5.Notification.createComplete());
	        destination.complete();
	    };
	    return MaterializeSubscriber;
	}(Subscriber_1$34.Subscriber));


	var materialize_1$1 = {
		materialize: materialize_2
	};

	var Observable_1$103 = Observable_1$2;
	var materialize_1 = materialize_1$1;
	Observable_1$103.Observable.prototype.materialize = materialize_1.materialize;

	var __extends$83 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1$35 = Subscriber_1$3;
	/* tslint:enable:max-line-length */
	/**
	 * Applies an accumulator function over the source Observable, and returns the
	 * accumulated result when the source completes, given an optional seed value.
	 *
	 * <span class="informal">Combines together all values emitted on the source,
	 * using an accumulator function that knows how to join a new source value into
	 * the accumulation from the past.</span>
	 *
	 * <img src="./img/reduce.png" width="100%">
	 *
	 * Like
	 * [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce),
	 * `reduce` applies an `accumulator` function against an accumulation and each
	 * value of the source Observable (from the past) to reduce it to a single
	 * value, emitted on the output Observable. Note that `reduce` will only emit
	 * one value, only when the source Observable completes. It is equivalent to
	 * applying operator {@link scan} followed by operator {@link last}.
	 *
	 * Returns an Observable that applies a specified `accumulator` function to each
	 * item emitted by the source Observable. If a `seed` value is specified, then
	 * that value will be used as the initial value for the accumulator. If no seed
	 * value is specified, the first item of the source is used as the seed.
	 *
	 * @example <caption>Count the number of click events that happened in 5 seconds</caption>
	 * var clicksInFiveSeconds = Rx.Observable.fromEvent(document, 'click')
	 *   .takeUntil(Rx.Observable.interval(5000));
	 * var ones = clicksInFiveSeconds.mapTo(1);
	 * var seed = 0;
	 * var count = ones.reduce((acc, one) => acc + one, seed);
	 * count.subscribe(x => console.log(x));
	 *
	 * @see {@link count}
	 * @see {@link expand}
	 * @see {@link mergeScan}
	 * @see {@link scan}
	 *
	 * @param {function(acc: R, value: T, index: number): R} accumulator The accumulator function
	 * called on each source value.
	 * @param {R} [seed] The initial accumulation value.
	 * @return {Observable<R>} An Observable that emits a single value that is the
	 * result of accumulating the values emitted by the source Observable.
	 * @method reduce
	 * @owner Observable
	 */
	function reduce$1(accumulator, seed) {
	    var hasSeed = false;
	    // providing a seed of `undefined` *should* be valid and trigger
	    // hasSeed! so don't use `seed !== undefined` checks!
	    // For this reason, we have to check it here at the original call site
	    // otherwise inside Operator/Subscriber we won't know if `undefined`
	    // means they didn't provide anything or if they literally provided `undefined`
	    if (arguments.length >= 2) {
	        hasSeed = true;
	    }
	    return this.lift(new ReduceOperator(accumulator, seed, hasSeed));
	}
	var reduce_2 = reduce$1;
	var ReduceOperator = (function () {
	    function ReduceOperator(accumulator, seed, hasSeed) {
	        if (hasSeed === void 0) { hasSeed = false; }
	        this.accumulator = accumulator;
	        this.seed = seed;
	        this.hasSeed = hasSeed;
	    }
	    ReduceOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new ReduceSubscriber(subscriber, this.accumulator, this.seed, this.hasSeed));
	    };
	    return ReduceOperator;
	}());
	var ReduceOperator_1 = ReduceOperator;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var ReduceSubscriber = (function (_super) {
	    __extends$83(ReduceSubscriber, _super);
	    function ReduceSubscriber(destination, accumulator, seed, hasSeed) {
	        _super.call(this, destination);
	        this.accumulator = accumulator;
	        this.hasSeed = hasSeed;
	        this.index = 0;
	        this.hasValue = false;
	        this.acc = seed;
	        if (!this.hasSeed) {
	            this.index++;
	        }
	    }
	    ReduceSubscriber.prototype._next = function (value) {
	        if (this.hasValue || (this.hasValue = this.hasSeed)) {
	            this._tryReduce(value);
	        }
	        else {
	            this.acc = value;
	            this.hasValue = true;
	        }
	    };
	    ReduceSubscriber.prototype._tryReduce = function (value) {
	        var result;
	        try {
	            result = this.accumulator(this.acc, value, this.index++);
	        }
	        catch (err) {
	            this.destination.error(err);
	            return;
	        }
	        this.acc = result;
	    };
	    ReduceSubscriber.prototype._complete = function () {
	        if (this.hasValue || this.hasSeed) {
	            this.destination.next(this.acc);
	        }
	        this.destination.complete();
	    };
	    return ReduceSubscriber;
	}(Subscriber_1$35.Subscriber));
	var ReduceSubscriber_1 = ReduceSubscriber;


	var reduce_1$2 = {
		reduce: reduce_2,
		ReduceOperator: ReduceOperator_1,
		ReduceSubscriber: ReduceSubscriber_1
	};

	var reduce_1$1 = reduce_1$2;
	/**
	 * The Max operator operates on an Observable that emits numbers (or items that can be compared with a provided function),
	 * and when source Observable completes it emits a single item: the item with the largest value.
	 *
	 * <img src="./img/max.png" width="100%">
	 *
	 * @example <caption>Get the maximal value of a series of numbers</caption>
	 * Rx.Observable.of(5, 4, 7, 2, 8)
	 *   .max()
	 *   .subscribe(x => console.log(x)); // -> 8
	 *
	 * @example <caption>Use a comparer function to get the maximal item</caption>
	 * interface Person {
	 *   age: number,
	 *   name: string
	 * }
	 * Observable.of<Person>({age: 7, name: 'Foo'},
	 *                       {age: 5, name: 'Bar'},
	 *                       {age: 9, name: 'Beer'})
	 *           .max<Person>((a: Person, b: Person) => a.age < b.age ? -1 : 1)
	 *           .subscribe((x: Person) => console.log(x.name)); // -> 'Beer'
	 * }
	 *
	 * @see {@link min}
	 *
	 * @param {Function} [comparer] - Optional comparer function that it will use instead of its default to compare the
	 * value of two items.
	 * @return {Observable} An Observable that emits item with the largest value.
	 * @method max
	 * @owner Observable
	 */
	function max$3(comparer) {
	    var max = (typeof comparer === 'function')
	        ? function (x, y) { return comparer(x, y) > 0 ? x : y; }
	        : function (x, y) { return x > y ? x : y; };
	    return this.lift(new reduce_1$1.ReduceOperator(max));
	}
	var max_2 = max$3;


	var max_1$2 = {
		max: max_2
	};

	var Observable_1$104 = Observable_1$2;
	var max_1$1 = max_1$2;
	Observable_1$104.Observable.prototype.max = max_1$1.max;

	var Observable_1$105 = Observable_1$2;
	var merge_1$5 = merge_1$3;
	Observable_1$105.Observable.prototype.merge = merge_1$5.merge;

	var Observable_1$106 = Observable_1$2;
	var mergeAll_1$5 = mergeAll_1$1;
	Observable_1$106.Observable.prototype.mergeAll = mergeAll_1$5.mergeAll;

	var Observable_1$107 = Observable_1$2;
	var mergeMap_1$3 = mergeMap_1$1;
	Observable_1$107.Observable.prototype.mergeMap = mergeMap_1$3.mergeMap;
	Observable_1$107.Observable.prototype.flatMap = mergeMap_1$3.mergeMap;

	var Observable_1$108 = Observable_1$2;
	var mergeMapTo_1$3 = mergeMapTo_1$1;
	Observable_1$108.Observable.prototype.flatMapTo = mergeMapTo_1$3.mergeMapTo;
	Observable_1$108.Observable.prototype.mergeMapTo = mergeMapTo_1$3.mergeMapTo;

	var __extends$84 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var tryCatch_1$12 = tryCatch_1$1;
	var errorObject_1$12 = errorObject;
	var subscribeToResult_1$24 = subscribeToResult_1$1;
	var OuterSubscriber_1$24 = OuterSubscriber_1$1;
	/**
	 * Applies an accumulator function over the source Observable where the
	 * accumulator function itself returns an Observable, then each intermediate
	 * Observable returned is merged into the output Observable.
	 *
	 * <span class="informal">It's like {@link scan}, but the Observables returned
	 * by the accumulator are merged into the outer Observable.</span>
	 *
	 * @example <caption>Count the number of click events</caption>
	 * const click$ = Rx.Observable.fromEvent(document, 'click');
	 * const one$ = click$.mapTo(1);
	 * const seed = 0;
	 * const count$ = one$.mergeScan((acc, one) => Rx.Observable.of(acc + one), seed);
	 * count$.subscribe(x => console.log(x));
	 *
	 * // Results:
	 * 1
	 * 2
	 * 3
	 * 4
	 * // ...and so on for each click
	 *
	 * @param {function(acc: R, value: T): Observable<R>} accumulator
	 * The accumulator function called on each source value.
	 * @param seed The initial accumulation value.
	 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of
	 * input Observables being subscribed to concurrently.
	 * @return {Observable<R>} An observable of the accumulated values.
	 * @method mergeScan
	 * @owner Observable
	 */
	function mergeScan$2(accumulator, seed, concurrent) {
	    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
	    return this.lift(new MergeScanOperator(accumulator, seed, concurrent));
	}
	var mergeScan_2 = mergeScan$2;
	var MergeScanOperator = (function () {
	    function MergeScanOperator(accumulator, seed, concurrent) {
	        this.accumulator = accumulator;
	        this.seed = seed;
	        this.concurrent = concurrent;
	    }
	    MergeScanOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new MergeScanSubscriber(subscriber, this.accumulator, this.seed, this.concurrent));
	    };
	    return MergeScanOperator;
	}());
	var MergeScanOperator_1 = MergeScanOperator;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var MergeScanSubscriber = (function (_super) {
	    __extends$84(MergeScanSubscriber, _super);
	    function MergeScanSubscriber(destination, accumulator, acc, concurrent) {
	        _super.call(this, destination);
	        this.accumulator = accumulator;
	        this.acc = acc;
	        this.concurrent = concurrent;
	        this.hasValue = false;
	        this.hasCompleted = false;
	        this.buffer = [];
	        this.active = 0;
	        this.index = 0;
	    }
	    MergeScanSubscriber.prototype._next = function (value) {
	        if (this.active < this.concurrent) {
	            var index = this.index++;
	            var ish = tryCatch_1$12.tryCatch(this.accumulator)(this.acc, value);
	            var destination = this.destination;
	            if (ish === errorObject_1$12.errorObject) {
	                destination.error(errorObject_1$12.errorObject.e);
	            }
	            else {
	                this.active++;
	                this._innerSub(ish, value, index);
	            }
	        }
	        else {
	            this.buffer.push(value);
	        }
	    };
	    MergeScanSubscriber.prototype._innerSub = function (ish, value, index) {
	        this.add(subscribeToResult_1$24.subscribeToResult(this, ish, value, index));
	    };
	    MergeScanSubscriber.prototype._complete = function () {
	        this.hasCompleted = true;
	        if (this.active === 0 && this.buffer.length === 0) {
	            if (this.hasValue === false) {
	                this.destination.next(this.acc);
	            }
	            this.destination.complete();
	        }
	    };
	    MergeScanSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        var destination = this.destination;
	        this.acc = innerValue;
	        this.hasValue = true;
	        destination.next(innerValue);
	    };
	    MergeScanSubscriber.prototype.notifyComplete = function (innerSub) {
	        var buffer = this.buffer;
	        this.remove(innerSub);
	        this.active--;
	        if (buffer.length > 0) {
	            this._next(buffer.shift());
	        }
	        else if (this.active === 0 && this.hasCompleted) {
	            if (this.hasValue === false) {
	                this.destination.next(this.acc);
	            }
	            this.destination.complete();
	        }
	    };
	    return MergeScanSubscriber;
	}(OuterSubscriber_1$24.OuterSubscriber));
	var MergeScanSubscriber_1 = MergeScanSubscriber;


	var mergeScan_1$1 = {
		mergeScan: mergeScan_2,
		MergeScanOperator: MergeScanOperator_1,
		MergeScanSubscriber: MergeScanSubscriber_1
	};

	var Observable_1$109 = Observable_1$2;
	var mergeScan_1 = mergeScan_1$1;
	Observable_1$109.Observable.prototype.mergeScan = mergeScan_1.mergeScan;

	var reduce_1$4 = reduce_1$2;
	/**
	 * The Min operator operates on an Observable that emits numbers (or items that can be compared with a provided function),
	 * and when source Observable completes it emits a single item: the item with the smallest value.
	 *
	 * <img src="./img/min.png" width="100%">
	 *
	 * @example <caption>Get the minimal value of a series of numbers</caption>
	 * Rx.Observable.of(5, 4, 7, 2, 8)
	 *   .min()
	 *   .subscribe(x => console.log(x)); // -> 2
	 *
	 * @example <caption>Use a comparer function to get the minimal item</caption>
	 * interface Person {
	 *   age: number,
	 *   name: string
	 * }
	 * Observable.of<Person>({age: 7, name: 'Foo'},
	 *                       {age: 5, name: 'Bar'},
	 *                       {age: 9, name: 'Beer'})
	 *           .min<Person>( (a: Person, b: Person) => a.age < b.age ? -1 : 1)
	 *           .subscribe((x: Person) => console.log(x.name)); // -> 'Bar'
	 * }
	 *
	 * @see {@link max}
	 *
	 * @param {Function} [comparer] - Optional comparer function that it will use instead of its default to compare the
	 * value of two items.
	 * @return {Observable<R>} An Observable that emits item with the smallest value.
	 * @method min
	 * @owner Observable
	 */
	function min$3(comparer) {
	    var min = (typeof comparer === 'function')
	        ? function (x, y) { return comparer(x, y) < 0 ? x : y; }
	        : function (x, y) { return x < y ? x : y; };
	    return this.lift(new reduce_1$4.ReduceOperator(min));
	}
	var min_2 = min$3;


	var min_1$2 = {
		min: min_2
	};

	var Observable_1$110 = Observable_1$2;
	var min_1$1 = min_1$2;
	Observable_1$110.Observable.prototype.min = min_1$1.min;

	var __extends$85 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subject_1$7 = Subject_1$1;
	var Observable_1$112 = Observable_1$2;
	var Subscriber_1$36 = Subscriber_1$3;
	var Subscription_1$16 = Subscription_1$3;
	/**
	 * @class ConnectableObservable<T>
	 */
	var ConnectableObservable$1 = (function (_super) {
	    __extends$85(ConnectableObservable, _super);
	    function ConnectableObservable(source, subjectFactory) {
	        _super.call(this);
	        this.source = source;
	        this.subjectFactory = subjectFactory;
	        this._refCount = 0;
	        this._isComplete = false;
	    }
	    ConnectableObservable.prototype._subscribe = function (subscriber) {
	        return this.getSubject().subscribe(subscriber);
	    };
	    ConnectableObservable.prototype.getSubject = function () {
	        var subject = this._subject;
	        if (!subject || subject.isStopped) {
	            this._subject = this.subjectFactory();
	        }
	        return this._subject;
	    };
	    ConnectableObservable.prototype.connect = function () {
	        var connection = this._connection;
	        if (!connection) {
	            this._isComplete = false;
	            connection = this._connection = new Subscription_1$16.Subscription();
	            connection.add(this.source
	                .subscribe(new ConnectableSubscriber(this.getSubject(), this)));
	            if (connection.closed) {
	                this._connection = null;
	                connection = Subscription_1$16.Subscription.EMPTY;
	            }
	            else {
	                this._connection = connection;
	            }
	        }
	        return connection;
	    };
	    ConnectableObservable.prototype.refCount = function () {
	        return this.lift(new RefCountOperator(this));
	    };
	    return ConnectableObservable;
	}(Observable_1$112.Observable));
	var ConnectableObservable_2 = ConnectableObservable$1;
	var connectableProto = ConnectableObservable$1.prototype;
	var connectableObservableDescriptor = {
	    operator: { value: null },
	    _refCount: { value: 0, writable: true },
	    _subject: { value: null, writable: true },
	    _connection: { value: null, writable: true },
	    _subscribe: { value: connectableProto._subscribe },
	    _isComplete: { value: connectableProto._isComplete, writable: true },
	    getSubject: { value: connectableProto.getSubject },
	    connect: { value: connectableProto.connect },
	    refCount: { value: connectableProto.refCount }
	};
	var ConnectableSubscriber = (function (_super) {
	    __extends$85(ConnectableSubscriber, _super);
	    function ConnectableSubscriber(destination, connectable) {
	        _super.call(this, destination);
	        this.connectable = connectable;
	    }
	    ConnectableSubscriber.prototype._error = function (err) {
	        this._unsubscribe();
	        _super.prototype._error.call(this, err);
	    };
	    ConnectableSubscriber.prototype._complete = function () {
	        this.connectable._isComplete = true;
	        this._unsubscribe();
	        _super.prototype._complete.call(this);
	    };
	    ConnectableSubscriber.prototype._unsubscribe = function () {
	        var connectable = this.connectable;
	        if (connectable) {
	            this.connectable = null;
	            var connection = connectable._connection;
	            connectable._refCount = 0;
	            connectable._subject = null;
	            connectable._connection = null;
	            if (connection) {
	                connection.unsubscribe();
	            }
	        }
	    };
	    return ConnectableSubscriber;
	}(Subject_1$7.SubjectSubscriber));
	var RefCountOperator = (function () {
	    function RefCountOperator(connectable) {
	        this.connectable = connectable;
	    }
	    RefCountOperator.prototype.call = function (subscriber, source) {
	        var connectable = this.connectable;
	        connectable._refCount++;
	        var refCounter = new RefCountSubscriber(subscriber, connectable);
	        var subscription = source.subscribe(refCounter);
	        if (!refCounter.closed) {
	            refCounter.connection = connectable.connect();
	        }
	        return subscription;
	    };
	    return RefCountOperator;
	}());
	var RefCountSubscriber = (function (_super) {
	    __extends$85(RefCountSubscriber, _super);
	    function RefCountSubscriber(destination, connectable) {
	        _super.call(this, destination);
	        this.connectable = connectable;
	    }
	    RefCountSubscriber.prototype._unsubscribe = function () {
	        var connectable = this.connectable;
	        if (!connectable) {
	            this.connection = null;
	            return;
	        }
	        this.connectable = null;
	        var refCount = connectable._refCount;
	        if (refCount <= 0) {
	            this.connection = null;
	            return;
	        }
	        connectable._refCount = refCount - 1;
	        if (refCount > 1) {
	            this.connection = null;
	            return;
	        }
	        ///
	        // Compare the local RefCountSubscriber's connection Subscription to the
	        // connection Subscription on the shared ConnectableObservable. In cases
	        // where the ConnectableObservable source synchronously emits values, and
	        // the RefCountSubscriber's downstream Observers synchronously unsubscribe,
	        // execution continues to here before the RefCountOperator has a chance to
	        // supply the RefCountSubscriber with the shared connection Subscription.
	        // For example:
	        // ```
	        // Observable.range(0, 10)
	        //   .publish()
	        //   .refCount()
	        //   .take(5)
	        //   .subscribe();
	        // ```
	        // In order to account for this case, RefCountSubscriber should only dispose
	        // the ConnectableObservable's shared connection Subscription if the
	        // connection Subscription exists, *and* either:
	        //   a. RefCountSubscriber doesn't have a reference to the shared connection
	        //      Subscription yet, or,
	        //   b. RefCountSubscriber's connection Subscription reference is identical
	        //      to the shared connection Subscription
	        ///
	        var connection = this.connection;
	        var sharedConnection = connectable._connection;
	        this.connection = null;
	        if (sharedConnection && (!connection || sharedConnection === connection)) {
	            sharedConnection.unsubscribe();
	        }
	    };
	    return RefCountSubscriber;
	}(Subscriber_1$36.Subscriber));


	var ConnectableObservable_1$2 = {
		ConnectableObservable: ConnectableObservable_2,
		connectableObservableDescriptor: connectableObservableDescriptor
	};

	var ConnectableObservable_1$1 = ConnectableObservable_1$2;
	/* tslint:enable:max-line-length */
	/**
	 * Returns an Observable that emits the results of invoking a specified selector on items
	 * emitted by a ConnectableObservable that shares a single subscription to the underlying stream.
	 *
	 * <img src="./img/multicast.png" width="100%">
	 *
	 * @param {Function|Subject} subjectOrSubjectFactory - Factory function to create an intermediate subject through
	 * which the source sequence's elements will be multicast to the selector function
	 * or Subject to push source elements into.
	 * @param {Function} [selector] - Optional selector function that can use the multicasted source stream
	 * as many times as needed, without causing multiple subscriptions to the source stream.
	 * Subscribers to the given source will receive all notifications of the source from the
	 * time of the subscription forward.
	 * @return {Observable} An Observable that emits the results of invoking the selector
	 * on the items emitted by a `ConnectableObservable` that shares a single subscription to
	 * the underlying stream.
	 * @method multicast
	 * @owner Observable
	 */
	function multicast$2(subjectOrSubjectFactory, selector) {
	    var subjectFactory;
	    if (typeof subjectOrSubjectFactory === 'function') {
	        subjectFactory = subjectOrSubjectFactory;
	    }
	    else {
	        subjectFactory = function subjectFactory() {
	            return subjectOrSubjectFactory;
	        };
	    }
	    if (typeof selector === 'function') {
	        return this.lift(new MulticastOperator(subjectFactory, selector));
	    }
	    var connectable = Object.create(this, ConnectableObservable_1$1.connectableObservableDescriptor);
	    connectable.source = this;
	    connectable.subjectFactory = subjectFactory;
	    return connectable;
	}
	var multicast_2 = multicast$2;
	var MulticastOperator = (function () {
	    function MulticastOperator(subjectFactory, selector) {
	        this.subjectFactory = subjectFactory;
	        this.selector = selector;
	    }
	    MulticastOperator.prototype.call = function (subscriber, source) {
	        var selector = this.selector;
	        var subject = this.subjectFactory();
	        var subscription = selector(subject).subscribe(subscriber);
	        subscription.add(source.subscribe(subject));
	        return subscription;
	    };
	    return MulticastOperator;
	}());
	var MulticastOperator_1 = MulticastOperator;


	var multicast_1$1 = {
		multicast: multicast_2,
		MulticastOperator: MulticastOperator_1
	};

	var Observable_1$111 = Observable_1$2;
	var multicast_1 = multicast_1$1;
	Observable_1$111.Observable.prototype.multicast = multicast_1.multicast;

	var Observable_1$113 = Observable_1$2;
	var observeOn_1$4 = observeOn_1$1;
	Observable_1$113.Observable.prototype.observeOn = observeOn_1$4.observeOn;

	var Observable_1$114 = Observable_1$2;
	var onErrorResumeNext_1$3 = onErrorResumeNext_1$1;
	Observable_1$114.Observable.prototype.onErrorResumeNext = onErrorResumeNext_1$3.onErrorResumeNext;

	var __extends$86 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1$37 = Subscriber_1$3;
	/**
	 * Groups pairs of consecutive emissions together and emits them as an array of
	 * two values.
	 *
	 * <span class="informal">Puts the current value and previous value together as
	 * an array, and emits that.</span>
	 *
	 * <img src="./img/pairwise.png" width="100%">
	 *
	 * The Nth emission from the source Observable will cause the output Observable
	 * to emit an array [(N-1)th, Nth] of the previous and the current value, as a
	 * pair. For this reason, `pairwise` emits on the second and subsequent
	 * emissions from the source Observable, but not on the first emission, because
	 * there is no previous value in that case.
	 *
	 * @example <caption>On every click (starting from the second), emit the relative distance to the previous click</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var pairs = clicks.pairwise();
	 * var distance = pairs.map(pair => {
	 *   var x0 = pair[0].clientX;
	 *   var y0 = pair[0].clientY;
	 *   var x1 = pair[1].clientX;
	 *   var y1 = pair[1].clientY;
	 *   return Math.sqrt(Math.pow(x0 - x1, 2) + Math.pow(y0 - y1, 2));
	 * });
	 * distance.subscribe(x => console.log(x));
	 *
	 * @see {@link buffer}
	 * @see {@link bufferCount}
	 *
	 * @return {Observable<Array<T>>} An Observable of pairs (as arrays) of
	 * consecutive values from the source Observable.
	 * @method pairwise
	 * @owner Observable
	 */
	function pairwise$2() {
	    return this.lift(new PairwiseOperator());
	}
	var pairwise_2 = pairwise$2;
	var PairwiseOperator = (function () {
	    function PairwiseOperator() {
	    }
	    PairwiseOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new PairwiseSubscriber(subscriber));
	    };
	    return PairwiseOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var PairwiseSubscriber = (function (_super) {
	    __extends$86(PairwiseSubscriber, _super);
	    function PairwiseSubscriber(destination) {
	        _super.call(this, destination);
	        this.hasPrev = false;
	    }
	    PairwiseSubscriber.prototype._next = function (value) {
	        if (this.hasPrev) {
	            this.destination.next([this.prev, value]);
	        }
	        else {
	            this.hasPrev = true;
	        }
	        this.prev = value;
	    };
	    return PairwiseSubscriber;
	}(Subscriber_1$37.Subscriber));


	var pairwise_1$1 = {
		pairwise: pairwise_2
	};

	var Observable_1$115 = Observable_1$2;
	var pairwise_1 = pairwise_1$1;
	Observable_1$115.Observable.prototype.pairwise = pairwise_1.pairwise;

	function not(pred, thisArg) {
	    function notPred() {
	        return !(notPred.pred.apply(notPred.thisArg, arguments));
	    }
	    notPred.pred = pred;
	    notPred.thisArg = thisArg;
	    return notPred;
	}
	var not_2 = not;


	var not_1$1 = {
		not: not_2
	};

	var not_1 = not_1$1;
	var filter_1$4 = filter_1$2;
	/**
	 * Splits the source Observable into two, one with values that satisfy a
	 * predicate, and another with values that don't satisfy the predicate.
	 *
	 * <span class="informal">It's like {@link filter}, but returns two Observables:
	 * one like the output of {@link filter}, and the other with values that did not
	 * pass the condition.</span>
	 *
	 * <img src="./img/partition.png" width="100%">
	 *
	 * `partition` outputs an array with two Observables that partition the values
	 * from the source Observable through the given `predicate` function. The first
	 * Observable in that array emits source values for which the predicate argument
	 * returns true. The second Observable emits source values for which the
	 * predicate returns false. The first behaves like {@link filter} and the second
	 * behaves like {@link filter} with the predicate negated.
	 *
	 * @example <caption>Partition click events into those on DIV elements and those elsewhere</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var parts = clicks.partition(ev => ev.target.tagName === 'DIV');
	 * var clicksOnDivs = parts[0];
	 * var clicksElsewhere = parts[1];
	 * clicksOnDivs.subscribe(x => console.log('DIV clicked: ', x));
	 * clicksElsewhere.subscribe(x => console.log('Other clicked: ', x));
	 *
	 * @see {@link filter}
	 *
	 * @param {function(value: T, index: number): boolean} predicate A function that
	 * evaluates each value emitted by the source Observable. If it returns `true`,
	 * the value is emitted on the first Observable in the returned array, if
	 * `false` the value is emitted on the second Observable in the array. The
	 * `index` parameter is the number `i` for the i-th source emission that has
	 * happened since the subscription, starting from the number `0`.
	 * @param {any} [thisArg] An optional argument to determine the value of `this`
	 * in the `predicate` function.
	 * @return {[Observable<T>, Observable<T>]} An array with two Observables: one
	 * with values that passed the predicate, and another with values that did not
	 * pass the predicate.
	 * @method partition
	 * @owner Observable
	 */
	function partition$3(predicate, thisArg) {
	    return [
	        filter_1$4.filter.call(this, predicate, thisArg),
	        filter_1$4.filter.call(this, not_1.not(predicate, thisArg))
	    ];
	}
	var partition_2 = partition$3;


	var partition_1$2 = {
		partition: partition_2
	};

	var Observable_1$116 = Observable_1$2;
	var partition_1$1 = partition_1$2;
	Observable_1$116.Observable.prototype.partition = partition_1$1.partition;

	var map_1$5 = map_1$2;
	/**
	 * Maps each source value (an object) to its specified nested property.
	 *
	 * <span class="informal">Like {@link map}, but meant only for picking one of
	 * the nested properties of every emitted object.</span>
	 *
	 * <img src="./img/pluck.png" width="100%">
	 *
	 * Given a list of strings describing a path to an object property, retrieves
	 * the value of a specified nested property from all values in the source
	 * Observable. If a property can't be resolved, it will return `undefined` for
	 * that value.
	 *
	 * @example <caption>Map every every click to the tagName of the clicked target element</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var tagNames = clicks.pluck('target', 'tagName');
	 * tagNames.subscribe(x => console.log(x));
	 *
	 * @see {@link map}
	 *
	 * @param {...string} properties The nested properties to pluck from each source
	 * value (an object).
	 * @return {Observable} A new Observable of property values from the source values.
	 * @method pluck
	 * @owner Observable
	 */
	function pluck$2() {
	    var properties = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        properties[_i - 0] = arguments[_i];
	    }
	    var length = properties.length;
	    if (length === 0) {
	        throw new Error('list of properties cannot be empty.');
	    }
	    return map_1$5.map.call(this, plucker(properties, length));
	}
	var pluck_2 = pluck$2;
	function plucker(props, length) {
	    var mapper = function (x) {
	        var currentProp = x;
	        for (var i = 0; i < length; i++) {
	            var p = currentProp[props[i]];
	            if (typeof p !== 'undefined') {
	                currentProp = p;
	            }
	            else {
	                return undefined;
	            }
	        }
	        return currentProp;
	    };
	    return mapper;
	}


	var pluck_1$1 = {
		pluck: pluck_2
	};

	var Observable_1$117 = Observable_1$2;
	var pluck_1 = pluck_1$1;
	Observable_1$117.Observable.prototype.pluck = pluck_1.pluck;

	var Subject_1$8 = Subject_1$1;
	var multicast_1$3 = multicast_1$1;
	/* tslint:enable:max-line-length */
	/**
	 * Returns a ConnectableObservable, which is a variety of Observable that waits until its connect method is called
	 * before it begins emitting items to those Observers that have subscribed to it.
	 *
	 * <img src="./img/publish.png" width="100%">
	 *
	 * @param {Function} [selector] - Optional selector function which can use the multicasted source sequence as many times
	 * as needed, without causing multiple subscriptions to the source sequence.
	 * Subscribers to the given source will receive all notifications of the source from the time of the subscription on.
	 * @return A ConnectableObservable that upon connection causes the source Observable to emit items to its Observers.
	 * @method publish
	 * @owner Observable
	 */
	function publish$2(selector) {
	    return selector ? multicast_1$3.multicast.call(this, function () { return new Subject_1$8.Subject(); }, selector) :
	        multicast_1$3.multicast.call(this, new Subject_1$8.Subject());
	}
	var publish_2 = publish$2;


	var publish_1$1 = {
		publish: publish_2
	};

	var Observable_1$118 = Observable_1$2;
	var publish_1 = publish_1$1;
	Observable_1$118.Observable.prototype.publish = publish_1.publish;

	var __extends$87 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subject_1$9 = Subject_1$1;
	var ObjectUnsubscribedError_1$5 = ObjectUnsubscribedError_1$2;
	/**
	 * @class BehaviorSubject<T>
	 */
	var BehaviorSubject$1 = (function (_super) {
	    __extends$87(BehaviorSubject, _super);
	    function BehaviorSubject(_value) {
	        _super.call(this);
	        this._value = _value;
	    }
	    Object.defineProperty(BehaviorSubject.prototype, "value", {
	        get: function () {
	            return this.getValue();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    BehaviorSubject.prototype._subscribe = function (subscriber) {
	        var subscription = _super.prototype._subscribe.call(this, subscriber);
	        if (subscription && !subscription.closed) {
	            subscriber.next(this._value);
	        }
	        return subscription;
	    };
	    BehaviorSubject.prototype.getValue = function () {
	        if (this.hasError) {
	            throw this.thrownError;
	        }
	        else if (this.closed) {
	            throw new ObjectUnsubscribedError_1$5.ObjectUnsubscribedError();
	        }
	        else {
	            return this._value;
	        }
	    };
	    BehaviorSubject.prototype.next = function (value) {
	        _super.prototype.next.call(this, this._value = value);
	    };
	    return BehaviorSubject;
	}(Subject_1$9.Subject));
	var BehaviorSubject_2 = BehaviorSubject$1;


	var BehaviorSubject_1$2 = {
		BehaviorSubject: BehaviorSubject_2
	};

	var BehaviorSubject_1$1 = BehaviorSubject_1$2;
	var multicast_1$4 = multicast_1$1;
	/**
	 * @param value
	 * @return {ConnectableObservable<T>}
	 * @method publishBehavior
	 * @owner Observable
	 */
	function publishBehavior$2(value) {
	    return multicast_1$4.multicast.call(this, new BehaviorSubject_1$1.BehaviorSubject(value));
	}
	var publishBehavior_2 = publishBehavior$2;


	var publishBehavior_1$1 = {
		publishBehavior: publishBehavior_2
	};

	var Observable_1$119 = Observable_1$2;
	var publishBehavior_1 = publishBehavior_1$1;
	Observable_1$119.Observable.prototype.publishBehavior = publishBehavior_1.publishBehavior;

	var ReplaySubject_1$4 = ReplaySubject_1$2;
	var multicast_1$5 = multicast_1$1;
	/**
	 * @param bufferSize
	 * @param windowTime
	 * @param scheduler
	 * @return {ConnectableObservable<T>}
	 * @method publishReplay
	 * @owner Observable
	 */
	function publishReplay$2(bufferSize, windowTime, scheduler) {
	    if (bufferSize === void 0) { bufferSize = Number.POSITIVE_INFINITY; }
	    if (windowTime === void 0) { windowTime = Number.POSITIVE_INFINITY; }
	    return multicast_1$5.multicast.call(this, new ReplaySubject_1$4.ReplaySubject(bufferSize, windowTime, scheduler));
	}
	var publishReplay_2 = publishReplay$2;


	var publishReplay_1$1 = {
		publishReplay: publishReplay_2
	};

	var Observable_1$120 = Observable_1$2;
	var publishReplay_1 = publishReplay_1$1;
	Observable_1$120.Observable.prototype.publishReplay = publishReplay_1.publishReplay;

	var AsyncSubject_1$5 = AsyncSubject_1$2;
	var multicast_1$6 = multicast_1$1;
	/**
	 * @return {ConnectableObservable<T>}
	 * @method publishLast
	 * @owner Observable
	 */
	function publishLast$2() {
	    return multicast_1$6.multicast.call(this, new AsyncSubject_1$5.AsyncSubject());
	}
	var publishLast_2 = publishLast$2;


	var publishLast_1$1 = {
		publishLast: publishLast_2
	};

	var Observable_1$121 = Observable_1$2;
	var publishLast_1 = publishLast_1$1;
	Observable_1$121.Observable.prototype.publishLast = publishLast_1.publishLast;

	var Observable_1$122 = Observable_1$2;
	var race_1$3 = race_1$1;
	Observable_1$122.Observable.prototype.race = race_1$3.race;

	var Observable_1$123 = Observable_1$2;
	var reduce_1$5 = reduce_1$2;
	Observable_1$123.Observable.prototype.reduce = reduce_1$5.reduce;

	var __extends$88 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1$38 = Subscriber_1$3;
	var EmptyObservable_1$6 = EmptyObservable_1$1;
	/**
	 * Returns an Observable that repeats the stream of items emitted by the source Observable at most count times.
	 *
	 * <img src="./img/repeat.png" width="100%">
	 *
	 * @param {number} [count] The number of times the source Observable items are repeated, a count of 0 will yield
	 * an empty Observable.
	 * @return {Observable} An Observable that repeats the stream of items emitted by the source Observable at most
	 * count times.
	 * @method repeat
	 * @owner Observable
	 */
	function repeat$3(count) {
	    if (count === void 0) { count = -1; }
	    if (count === 0) {
	        return new EmptyObservable_1$6.EmptyObservable();
	    }
	    else if (count < 0) {
	        return this.lift(new RepeatOperator(-1, this));
	    }
	    else {
	        return this.lift(new RepeatOperator(count - 1, this));
	    }
	}
	var repeat_2 = repeat$3;
	var RepeatOperator = (function () {
	    function RepeatOperator(count, source) {
	        this.count = count;
	        this.source = source;
	    }
	    RepeatOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new RepeatSubscriber(subscriber, this.count, this.source));
	    };
	    return RepeatOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var RepeatSubscriber = (function (_super) {
	    __extends$88(RepeatSubscriber, _super);
	    function RepeatSubscriber(destination, count, source) {
	        _super.call(this, destination);
	        this.count = count;
	        this.source = source;
	    }
	    RepeatSubscriber.prototype.complete = function () {
	        if (!this.isStopped) {
	            var _a = this, source = _a.source, count = _a.count;
	            if (count === 0) {
	                return _super.prototype.complete.call(this);
	            }
	            else if (count > -1) {
	                this.count = count - 1;
	            }
	            source.subscribe(this._unsubscribeAndRecycle());
	        }
	    };
	    return RepeatSubscriber;
	}(Subscriber_1$38.Subscriber));


	var repeat_1$2 = {
		repeat: repeat_2
	};

	var Observable_1$124 = Observable_1$2;
	var repeat_1$1 = repeat_1$2;
	Observable_1$124.Observable.prototype.repeat = repeat_1$1.repeat;

	var __extends$89 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subject_1$10 = Subject_1$1;
	var tryCatch_1$13 = tryCatch_1$1;
	var errorObject_1$13 = errorObject;
	var OuterSubscriber_1$25 = OuterSubscriber_1$1;
	var subscribeToResult_1$25 = subscribeToResult_1$1;
	/**
	 * Returns an Observable that mirrors the source Observable with the exception of a `complete`. If the source
	 * Observable calls `complete`, this method will emit to the Observable returned from `notifier`. If that Observable
	 * calls `complete` or `error`, then this method will call `complete` or `error` on the child subscription. Otherwise
	 * this method will resubscribe to the source Observable.
	 *
	 * <img src="./img/repeatWhen.png" width="100%">
	 *
	 * @param {function(notifications: Observable): Observable} notifier - Receives an Observable of notifications with
	 * which a user can `complete` or `error`, aborting the repetition.
	 * @return {Observable} The source Observable modified with repeat logic.
	 * @method repeatWhen
	 * @owner Observable
	 */
	function repeatWhen$2(notifier) {
	    return this.lift(new RepeatWhenOperator(notifier));
	}
	var repeatWhen_2 = repeatWhen$2;
	var RepeatWhenOperator = (function () {
	    function RepeatWhenOperator(notifier) {
	        this.notifier = notifier;
	    }
	    RepeatWhenOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new RepeatWhenSubscriber(subscriber, this.notifier, source));
	    };
	    return RepeatWhenOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var RepeatWhenSubscriber = (function (_super) {
	    __extends$89(RepeatWhenSubscriber, _super);
	    function RepeatWhenSubscriber(destination, notifier, source) {
	        _super.call(this, destination);
	        this.notifier = notifier;
	        this.source = source;
	        this.sourceIsBeingSubscribedTo = true;
	    }
	    RepeatWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        this.sourceIsBeingSubscribedTo = true;
	        this.source.subscribe(this);
	    };
	    RepeatWhenSubscriber.prototype.notifyComplete = function (innerSub) {
	        if (this.sourceIsBeingSubscribedTo === false) {
	            return _super.prototype.complete.call(this);
	        }
	    };
	    RepeatWhenSubscriber.prototype.complete = function () {
	        this.sourceIsBeingSubscribedTo = false;
	        if (!this.isStopped) {
	            if (!this.retries) {
	                this.subscribeToRetries();
	            }
	            else if (this.retriesSubscription.closed) {
	                return _super.prototype.complete.call(this);
	            }
	            this._unsubscribeAndRecycle();
	            this.notifications.next();
	        }
	    };
	    RepeatWhenSubscriber.prototype._unsubscribe = function () {
	        var _a = this, notifications = _a.notifications, retriesSubscription = _a.retriesSubscription;
	        if (notifications) {
	            notifications.unsubscribe();
	            this.notifications = null;
	        }
	        if (retriesSubscription) {
	            retriesSubscription.unsubscribe();
	            this.retriesSubscription = null;
	        }
	        this.retries = null;
	    };
	    RepeatWhenSubscriber.prototype._unsubscribeAndRecycle = function () {
	        var _a = this, notifications = _a.notifications, retries = _a.retries, retriesSubscription = _a.retriesSubscription;
	        this.notifications = null;
	        this.retries = null;
	        this.retriesSubscription = null;
	        _super.prototype._unsubscribeAndRecycle.call(this);
	        this.notifications = notifications;
	        this.retries = retries;
	        this.retriesSubscription = retriesSubscription;
	        return this;
	    };
	    RepeatWhenSubscriber.prototype.subscribeToRetries = function () {
	        this.notifications = new Subject_1$10.Subject();
	        var retries = tryCatch_1$13.tryCatch(this.notifier)(this.notifications);
	        if (retries === errorObject_1$13.errorObject) {
	            return _super.prototype.complete.call(this);
	        }
	        this.retries = retries;
	        this.retriesSubscription = subscribeToResult_1$25.subscribeToResult(this, retries);
	    };
	    return RepeatWhenSubscriber;
	}(OuterSubscriber_1$25.OuterSubscriber));


	var repeatWhen_1$1 = {
		repeatWhen: repeatWhen_2
	};

	var Observable_1$125 = Observable_1$2;
	var repeatWhen_1 = repeatWhen_1$1;
	Observable_1$125.Observable.prototype.repeatWhen = repeatWhen_1.repeatWhen;

	var __extends$90 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1$39 = Subscriber_1$3;
	/**
	 * Returns an Observable that mirrors the source Observable with the exception of an `error`. If the source Observable
	 * calls `error`, this method will resubscribe to the source Observable for a maximum of `count` resubscriptions (given
	 * as a number parameter) rather than propagating the `error` call.
	 *
	 * <img src="./img/retry.png" width="100%">
	 *
	 * Any and all items emitted by the source Observable will be emitted by the resulting Observable, even those emitted
	 * during failed subscriptions. For example, if an Observable fails at first but emits [1, 2] then succeeds the second
	 * time and emits: [1, 2, 3, 4, 5] then the complete stream of emissions and notifications
	 * would be: [1, 2, 1, 2, 3, 4, 5, `complete`].
	 * @param {number} count - Number of retry attempts before failing.
	 * @return {Observable} The source Observable modified with the retry logic.
	 * @method retry
	 * @owner Observable
	 */
	function retry$2(count) {
	    if (count === void 0) { count = -1; }
	    return this.lift(new RetryOperator(count, this));
	}
	var retry_2 = retry$2;
	var RetryOperator = (function () {
	    function RetryOperator(count, source) {
	        this.count = count;
	        this.source = source;
	    }
	    RetryOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new RetrySubscriber(subscriber, this.count, this.source));
	    };
	    return RetryOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var RetrySubscriber = (function (_super) {
	    __extends$90(RetrySubscriber, _super);
	    function RetrySubscriber(destination, count, source) {
	        _super.call(this, destination);
	        this.count = count;
	        this.source = source;
	    }
	    RetrySubscriber.prototype.error = function (err) {
	        if (!this.isStopped) {
	            var _a = this, source = _a.source, count = _a.count;
	            if (count === 0) {
	                return _super.prototype.error.call(this, err);
	            }
	            else if (count > -1) {
	                this.count = count - 1;
	            }
	            source.subscribe(this._unsubscribeAndRecycle());
	        }
	    };
	    return RetrySubscriber;
	}(Subscriber_1$39.Subscriber));


	var retry_1$1 = {
		retry: retry_2
	};

	var Observable_1$126 = Observable_1$2;
	var retry_1 = retry_1$1;
	Observable_1$126.Observable.prototype.retry = retry_1.retry;

	var __extends$91 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subject_1$11 = Subject_1$1;
	var tryCatch_1$14 = tryCatch_1$1;
	var errorObject_1$14 = errorObject;
	var OuterSubscriber_1$26 = OuterSubscriber_1$1;
	var subscribeToResult_1$26 = subscribeToResult_1$1;
	/**
	 * Returns an Observable that mirrors the source Observable with the exception of an `error`. If the source Observable
	 * calls `error`, this method will emit the Throwable that caused the error to the Observable returned from `notifier`.
	 * If that Observable calls `complete` or `error` then this method will call `complete` or `error` on the child
	 * subscription. Otherwise this method will resubscribe to the source Observable.
	 *
	 * <img src="./img/retryWhen.png" width="100%">
	 *
	 * @param {function(errors: Observable): Observable} notifier - Receives an Observable of notifications with which a
	 * user can `complete` or `error`, aborting the retry.
	 * @return {Observable} The source Observable modified with retry logic.
	 * @method retryWhen
	 * @owner Observable
	 */
	function retryWhen$2(notifier) {
	    return this.lift(new RetryWhenOperator(notifier, this));
	}
	var retryWhen_2 = retryWhen$2;
	var RetryWhenOperator = (function () {
	    function RetryWhenOperator(notifier, source) {
	        this.notifier = notifier;
	        this.source = source;
	    }
	    RetryWhenOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new RetryWhenSubscriber(subscriber, this.notifier, this.source));
	    };
	    return RetryWhenOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var RetryWhenSubscriber = (function (_super) {
	    __extends$91(RetryWhenSubscriber, _super);
	    function RetryWhenSubscriber(destination, notifier, source) {
	        _super.call(this, destination);
	        this.notifier = notifier;
	        this.source = source;
	    }
	    RetryWhenSubscriber.prototype.error = function (err) {
	        if (!this.isStopped) {
	            var errors = this.errors;
	            var retries = this.retries;
	            var retriesSubscription = this.retriesSubscription;
	            if (!retries) {
	                errors = new Subject_1$11.Subject();
	                retries = tryCatch_1$14.tryCatch(this.notifier)(errors);
	                if (retries === errorObject_1$14.errorObject) {
	                    return _super.prototype.error.call(this, errorObject_1$14.errorObject.e);
	                }
	                retriesSubscription = subscribeToResult_1$26.subscribeToResult(this, retries);
	            }
	            else {
	                this.errors = null;
	                this.retriesSubscription = null;
	            }
	            this._unsubscribeAndRecycle();
	            this.errors = errors;
	            this.retries = retries;
	            this.retriesSubscription = retriesSubscription;
	            errors.next(err);
	        }
	    };
	    RetryWhenSubscriber.prototype._unsubscribe = function () {
	        var _a = this, errors = _a.errors, retriesSubscription = _a.retriesSubscription;
	        if (errors) {
	            errors.unsubscribe();
	            this.errors = null;
	        }
	        if (retriesSubscription) {
	            retriesSubscription.unsubscribe();
	            this.retriesSubscription = null;
	        }
	        this.retries = null;
	    };
	    RetryWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        var _a = this, errors = _a.errors, retries = _a.retries, retriesSubscription = _a.retriesSubscription;
	        this.errors = null;
	        this.retries = null;
	        this.retriesSubscription = null;
	        this._unsubscribeAndRecycle();
	        this.errors = errors;
	        this.retries = retries;
	        this.retriesSubscription = retriesSubscription;
	        this.source.subscribe(this);
	    };
	    return RetryWhenSubscriber;
	}(OuterSubscriber_1$26.OuterSubscriber));


	var retryWhen_1$1 = {
		retryWhen: retryWhen_2
	};

	var Observable_1$127 = Observable_1$2;
	var retryWhen_1 = retryWhen_1$1;
	Observable_1$127.Observable.prototype.retryWhen = retryWhen_1.retryWhen;

	var __extends$92 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var OuterSubscriber_1$27 = OuterSubscriber_1$1;
	var subscribeToResult_1$27 = subscribeToResult_1$1;
	/**
	 * Emits the most recently emitted value from the source Observable whenever
	 * another Observable, the `notifier`, emits.
	 *
	 * <span class="informal">It's like {@link sampleTime}, but samples whenever
	 * the `notifier` Observable emits something.</span>
	 *
	 * <img src="./img/sample.png" width="100%">
	 *
	 * Whenever the `notifier` Observable emits a value or completes, `sample`
	 * looks at the source Observable and emits whichever value it has most recently
	 * emitted since the previous sampling, unless the source has not emitted
	 * anything since the previous sampling. The `notifier` is subscribed to as soon
	 * as the output Observable is subscribed.
	 *
	 * @example <caption>On every click, sample the most recent "seconds" timer</caption>
	 * var seconds = Rx.Observable.interval(1000);
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = seconds.sample(clicks);
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link audit}
	 * @see {@link debounce}
	 * @see {@link sampleTime}
	 * @see {@link throttle}
	 *
	 * @param {Observable<any>} notifier The Observable to use for sampling the
	 * source Observable.
	 * @return {Observable<T>} An Observable that emits the results of sampling the
	 * values emitted by the source Observable whenever the notifier Observable
	 * emits value or completes.
	 * @method sample
	 * @owner Observable
	 */
	function sample$3(notifier) {
	    return this.lift(new SampleOperator(notifier));
	}
	var sample_2 = sample$3;
	var SampleOperator = (function () {
	    function SampleOperator(notifier) {
	        this.notifier = notifier;
	    }
	    SampleOperator.prototype.call = function (subscriber, source) {
	        var sampleSubscriber = new SampleSubscriber(subscriber);
	        var subscription = source.subscribe(sampleSubscriber);
	        subscription.add(subscribeToResult_1$27.subscribeToResult(sampleSubscriber, this.notifier));
	        return subscription;
	    };
	    return SampleOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var SampleSubscriber = (function (_super) {
	    __extends$92(SampleSubscriber, _super);
	    function SampleSubscriber() {
	        _super.apply(this, arguments);
	        this.hasValue = false;
	    }
	    SampleSubscriber.prototype._next = function (value) {
	        this.value = value;
	        this.hasValue = true;
	    };
	    SampleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        this.emitValue();
	    };
	    SampleSubscriber.prototype.notifyComplete = function () {
	        this.emitValue();
	    };
	    SampleSubscriber.prototype.emitValue = function () {
	        if (this.hasValue) {
	            this.hasValue = false;
	            this.destination.next(this.value);
	        }
	    };
	    return SampleSubscriber;
	}(OuterSubscriber_1$27.OuterSubscriber));


	var sample_1$2 = {
		sample: sample_2
	};

	var Observable_1$128 = Observable_1$2;
	var sample_1$1 = sample_1$2;
	Observable_1$128.Observable.prototype.sample = sample_1$1.sample;

	var __extends$93 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1$40 = Subscriber_1$3;
	var async_1$8 = async;
	/**
	 * Emits the most recently emitted value from the source Observable within
	 * periodic time intervals.
	 *
	 * <span class="informal">Samples the source Observable at periodic time
	 * intervals, emitting what it samples.</span>
	 *
	 * <img src="./img/sampleTime.png" width="100%">
	 *
	 * `sampleTime` periodically looks at the source Observable and emits whichever
	 * value it has most recently emitted since the previous sampling, unless the
	 * source has not emitted anything since the previous sampling. The sampling
	 * happens periodically in time every `period` milliseconds (or the time unit
	 * defined by the optional `scheduler` argument). The sampling starts as soon as
	 * the output Observable is subscribed.
	 *
	 * @example <caption>Every second, emit the most recent click at most once</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = clicks.sampleTime(1000);
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link auditTime}
	 * @see {@link debounceTime}
	 * @see {@link delay}
	 * @see {@link sample}
	 * @see {@link throttleTime}
	 *
	 * @param {number} period The sampling period expressed in milliseconds or the
	 * time unit determined internally by the optional `scheduler`.
	 * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for
	 * managing the timers that handle the sampling.
	 * @return {Observable<T>} An Observable that emits the results of sampling the
	 * values emitted by the source Observable at the specified time interval.
	 * @method sampleTime
	 * @owner Observable
	 */
	function sampleTime$2(period, scheduler) {
	    if (scheduler === void 0) { scheduler = async_1$8.async; }
	    return this.lift(new SampleTimeOperator(period, scheduler));
	}
	var sampleTime_2 = sampleTime$2;
	var SampleTimeOperator = (function () {
	    function SampleTimeOperator(period, scheduler) {
	        this.period = period;
	        this.scheduler = scheduler;
	    }
	    SampleTimeOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new SampleTimeSubscriber(subscriber, this.period, this.scheduler));
	    };
	    return SampleTimeOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var SampleTimeSubscriber = (function (_super) {
	    __extends$93(SampleTimeSubscriber, _super);
	    function SampleTimeSubscriber(destination, period, scheduler) {
	        _super.call(this, destination);
	        this.period = period;
	        this.scheduler = scheduler;
	        this.hasValue = false;
	        this.add(scheduler.schedule(dispatchNotification, period, { subscriber: this, period: period }));
	    }
	    SampleTimeSubscriber.prototype._next = function (value) {
	        this.lastValue = value;
	        this.hasValue = true;
	    };
	    SampleTimeSubscriber.prototype.notifyNext = function () {
	        if (this.hasValue) {
	            this.hasValue = false;
	            this.destination.next(this.lastValue);
	        }
	    };
	    return SampleTimeSubscriber;
	}(Subscriber_1$40.Subscriber));
	function dispatchNotification(state) {
	    var subscriber = state.subscriber, period = state.period;
	    subscriber.notifyNext();
	    this.schedule(state, period);
	}


	var sampleTime_1$1 = {
		sampleTime: sampleTime_2
	};

	var Observable_1$129 = Observable_1$2;
	var sampleTime_1 = sampleTime_1$1;
	Observable_1$129.Observable.prototype.sampleTime = sampleTime_1.sampleTime;

	var __extends$94 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1$41 = Subscriber_1$3;
	/* tslint:enable:max-line-length */
	/**
	 * Applies an accumulator function over the source Observable, and returns each
	 * intermediate result, with an optional seed value.
	 *
	 * <span class="informal">It's like {@link reduce}, but emits the current
	 * accumulation whenever the source emits a value.</span>
	 *
	 * <img src="./img/scan.png" width="100%">
	 *
	 * Combines together all values emitted on the source, using an accumulator
	 * function that knows how to join a new source value into the accumulation from
	 * the past. Is similar to {@link reduce}, but emits the intermediate
	 * accumulations.
	 *
	 * Returns an Observable that applies a specified `accumulator` function to each
	 * item emitted by the source Observable. If a `seed` value is specified, then
	 * that value will be used as the initial value for the accumulator. If no seed
	 * value is specified, the first item of the source is used as the seed.
	 *
	 * @example <caption>Count the number of click events</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var ones = clicks.mapTo(1);
	 * var seed = 0;
	 * var count = ones.scan((acc, one) => acc + one, seed);
	 * count.subscribe(x => console.log(x));
	 *
	 * @see {@link expand}
	 * @see {@link mergeScan}
	 * @see {@link reduce}
	 *
	 * @param {function(acc: R, value: T, index: number): R} accumulator
	 * The accumulator function called on each source value.
	 * @param {T|R} [seed] The initial accumulation value.
	 * @return {Observable<R>} An observable of the accumulated values.
	 * @method scan
	 * @owner Observable
	 */
	function scan$2(accumulator, seed) {
	    var hasSeed = false;
	    // providing a seed of `undefined` *should* be valid and trigger
	    // hasSeed! so don't use `seed !== undefined` checks!
	    // For this reason, we have to check it here at the original call site
	    // otherwise inside Operator/Subscriber we won't know if `undefined`
	    // means they didn't provide anything or if they literally provided `undefined`
	    if (arguments.length >= 2) {
	        hasSeed = true;
	    }
	    return this.lift(new ScanOperator(accumulator, seed, hasSeed));
	}
	var scan_2 = scan$2;
	var ScanOperator = (function () {
	    function ScanOperator(accumulator, seed, hasSeed) {
	        if (hasSeed === void 0) { hasSeed = false; }
	        this.accumulator = accumulator;
	        this.seed = seed;
	        this.hasSeed = hasSeed;
	    }
	    ScanOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new ScanSubscriber(subscriber, this.accumulator, this.seed, this.hasSeed));
	    };
	    return ScanOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var ScanSubscriber = (function (_super) {
	    __extends$94(ScanSubscriber, _super);
	    function ScanSubscriber(destination, accumulator, _seed, hasSeed) {
	        _super.call(this, destination);
	        this.accumulator = accumulator;
	        this._seed = _seed;
	        this.hasSeed = hasSeed;
	        this.index = 0;
	    }
	    Object.defineProperty(ScanSubscriber.prototype, "seed", {
	        get: function () {
	            return this._seed;
	        },
	        set: function (value) {
	            this.hasSeed = true;
	            this._seed = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    ScanSubscriber.prototype._next = function (value) {
	        if (!this.hasSeed) {
	            this.seed = value;
	            this.destination.next(value);
	        }
	        else {
	            return this._tryNext(value);
	        }
	    };
	    ScanSubscriber.prototype._tryNext = function (value) {
	        var index = this.index++;
	        var result;
	        try {
	            result = this.accumulator(this.seed, value, index);
	        }
	        catch (err) {
	            this.destination.error(err);
	        }
	        this.seed = result;
	        this.destination.next(result);
	    };
	    return ScanSubscriber;
	}(Subscriber_1$41.Subscriber));


	var scan_1$1 = {
		scan: scan_2
	};

	var Observable_1$130 = Observable_1$2;
	var scan_1 = scan_1$1;
	Observable_1$130.Observable.prototype.scan = scan_1.scan;

	var __extends$95 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1$42 = Subscriber_1$3;
	var tryCatch_1$15 = tryCatch_1$1;
	var errorObject_1$15 = errorObject;
	/**
	 * Compares all values of two observables in sequence using an optional comparor function
	 * and returns an observable of a single boolean value representing whether or not the two sequences
	 * are equal.
	 *
	 * <span class="informal">Checks to see of all values emitted by both observables are equal, in order.</span>
	 *
	 * <img src="./img/sequenceEqual.png" width="100%">
	 *
	 * `sequenceEqual` subscribes to two observables and buffers incoming values from each observable. Whenever either
	 * observable emits a value, the value is buffered and the buffers are shifted and compared from the bottom
	 * up; If any value pair doesn't match, the returned observable will emit `false` and complete. If one of the
	 * observables completes, the operator will wait for the other observable to complete; If the other
	 * observable emits before completing, the returned observable will emit `false` and complete. If one observable never
	 * completes or emits after the other complets, the returned observable will never complete.
	 *
	 * @example <caption>figure out if the Konami code matches</caption>
	 * var code = Rx.Observable.from([
	 *  "ArrowUp",
	 *  "ArrowUp",
	 *  "ArrowDown",
	 *  "ArrowDown",
	 *  "ArrowLeft",
	 *  "ArrowRight",
	 *  "ArrowLeft",
	 *  "ArrowRight",
	 *  "KeyB",
	 *  "KeyA",
	 *  "Enter" // no start key, clearly.
	 * ]);
	 *
	 * var keys = Rx.Observable.fromEvent(document, 'keyup')
	 *  .map(e => e.code);
	 * var matches = keys.bufferCount(11, 1)
	 *  .mergeMap(
	 *    last11 =>
	 *      Rx.Observable.from(last11)
	 *        .sequenceEqual(code)
	 *   );
	 * matches.subscribe(matched => console.log('Successful cheat at Contra? ', matched));
	 *
	 * @see {@link combineLatest}
	 * @see {@link zip}
	 * @see {@link withLatestFrom}
	 *
	 * @param {Observable} compareTo The observable sequence to compare the source sequence to.
	 * @param {function} [comparor] An optional function to compare each value pair
	 * @return {Observable} An Observable of a single boolean value representing whether or not
	 * the values emitted by both observables were equal in sequence.
	 * @method sequenceEqual
	 * @owner Observable
	 */
	function sequenceEqual$2(compareTo, comparor) {
	    return this.lift(new SequenceEqualOperator(compareTo, comparor));
	}
	var sequenceEqual_2 = sequenceEqual$2;
	var SequenceEqualOperator = (function () {
	    function SequenceEqualOperator(compareTo, comparor) {
	        this.compareTo = compareTo;
	        this.comparor = comparor;
	    }
	    SequenceEqualOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new SequenceEqualSubscriber(subscriber, this.compareTo, this.comparor));
	    };
	    return SequenceEqualOperator;
	}());
	var SequenceEqualOperator_1 = SequenceEqualOperator;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var SequenceEqualSubscriber = (function (_super) {
	    __extends$95(SequenceEqualSubscriber, _super);
	    function SequenceEqualSubscriber(destination, compareTo, comparor) {
	        _super.call(this, destination);
	        this.compareTo = compareTo;
	        this.comparor = comparor;
	        this._a = [];
	        this._b = [];
	        this._oneComplete = false;
	        this.add(compareTo.subscribe(new SequenceEqualCompareToSubscriber(destination, this)));
	    }
	    SequenceEqualSubscriber.prototype._next = function (value) {
	        if (this._oneComplete && this._b.length === 0) {
	            this.emit(false);
	        }
	        else {
	            this._a.push(value);
	            this.checkValues();
	        }
	    };
	    SequenceEqualSubscriber.prototype._complete = function () {
	        if (this._oneComplete) {
	            this.emit(this._a.length === 0 && this._b.length === 0);
	        }
	        else {
	            this._oneComplete = true;
	        }
	    };
	    SequenceEqualSubscriber.prototype.checkValues = function () {
	        var _c = this, _a = _c._a, _b = _c._b, comparor = _c.comparor;
	        while (_a.length > 0 && _b.length > 0) {
	            var a = _a.shift();
	            var b = _b.shift();
	            var areEqual = false;
	            if (comparor) {
	                areEqual = tryCatch_1$15.tryCatch(comparor)(a, b);
	                if (areEqual === errorObject_1$15.errorObject) {
	                    this.destination.error(errorObject_1$15.errorObject.e);
	                }
	            }
	            else {
	                areEqual = a === b;
	            }
	            if (!areEqual) {
	                this.emit(false);
	            }
	        }
	    };
	    SequenceEqualSubscriber.prototype.emit = function (value) {
	        var destination = this.destination;
	        destination.next(value);
	        destination.complete();
	    };
	    SequenceEqualSubscriber.prototype.nextB = function (value) {
	        if (this._oneComplete && this._a.length === 0) {
	            this.emit(false);
	        }
	        else {
	            this._b.push(value);
	            this.checkValues();
	        }
	    };
	    return SequenceEqualSubscriber;
	}(Subscriber_1$42.Subscriber));
	var SequenceEqualSubscriber_1 = SequenceEqualSubscriber;
	var SequenceEqualCompareToSubscriber = (function (_super) {
	    __extends$95(SequenceEqualCompareToSubscriber, _super);
	    function SequenceEqualCompareToSubscriber(destination, parent) {
	        _super.call(this, destination);
	        this.parent = parent;
	    }
	    SequenceEqualCompareToSubscriber.prototype._next = function (value) {
	        this.parent.nextB(value);
	    };
	    SequenceEqualCompareToSubscriber.prototype._error = function (err) {
	        this.parent.error(err);
	    };
	    SequenceEqualCompareToSubscriber.prototype._complete = function () {
	        this.parent._complete();
	    };
	    return SequenceEqualCompareToSubscriber;
	}(Subscriber_1$42.Subscriber));


	var sequenceEqual_1$1 = {
		sequenceEqual: sequenceEqual_2,
		SequenceEqualOperator: SequenceEqualOperator_1,
		SequenceEqualSubscriber: SequenceEqualSubscriber_1
	};

	var Observable_1$131 = Observable_1$2;
	var sequenceEqual_1 = sequenceEqual_1$1;
	Observable_1$131.Observable.prototype.sequenceEqual = sequenceEqual_1.sequenceEqual;

	var multicast_1$7 = multicast_1$1;
	var Subject_1$12 = Subject_1$1;
	function shareSubjectFactory() {
	    return new Subject_1$12.Subject();
	}
	/**
	 * Returns a new Observable that multicasts (shares) the original Observable. As long as there is at least one
	 * Subscriber this Observable will be subscribed and emitting data. When all subscribers have unsubscribed it will
	 * unsubscribe from the source Observable. Because the Observable is multicasting it makes the stream `hot`.
	 * This is an alias for .publish().refCount().
	 *
	 * <img src="./img/share.png" width="100%">
	 *
	 * @return {Observable<T>} An Observable that upon connection causes the source Observable to emit items to its Observers.
	 * @method share
	 * @owner Observable
	 */
	function share$2() {
	    return multicast_1$7.multicast.call(this, shareSubjectFactory).refCount();
	}
	var share_2 = share$2;



	var share_1$1 = {
		share: share_2
	};

	var Observable_1$132 = Observable_1$2;
	var share_1 = share_1$1;
	Observable_1$132.Observable.prototype.share = share_1.share;

	var multicast_1$8 = multicast_1$1;
	var ReplaySubject_1$5 = ReplaySubject_1$2;
	/**
	 * @method shareReplay
	 * @owner Observable
	 */
	function shareReplay$2(bufferSize, windowTime, scheduler) {
	    var subject;
	    var connectable = multicast_1$8.multicast.call(this, function shareReplaySubjectFactory() {
	        if (this._isComplete) {
	            return subject;
	        }
	        else {
	            return (subject = new ReplaySubject_1$5.ReplaySubject(bufferSize, windowTime, scheduler));
	        }
	    });
	    return connectable.refCount();
	}
	var shareReplay_2 = shareReplay$2;



	var shareReplay_1$1 = {
		shareReplay: shareReplay_2
	};

	var Observable_1$133 = Observable_1$2;
	var shareReplay_1 = shareReplay_1$1;
	Observable_1$133.Observable.prototype.shareReplay = shareReplay_1.shareReplay;

	var __extends$96 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1$43 = Subscriber_1$3;
	var EmptyError_1$5 = EmptyError_1$2;
	/**
	 * Returns an Observable that emits the single item emitted by the source Observable that matches a specified
	 * predicate, if that Observable emits one such item. If the source Observable emits more than one such item or no
	 * such items, notify of an IllegalArgumentException or NoSuchElementException respectively.
	 *
	 * <img src="./img/single.png" width="100%">
	 *
	 * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`
	 * callback if the Observable completes before any `next` notification was sent.
	 * @param {Function} predicate - A predicate function to evaluate items emitted by the source Observable.
	 * @return {Observable<T>} An Observable that emits the single item emitted by the source Observable that matches
	 * the predicate.
	 .
	 * @method single
	 * @owner Observable
	 */
	function single$2(predicate) {
	    return this.lift(new SingleOperator(predicate, this));
	}
	var single_2 = single$2;
	var SingleOperator = (function () {
	    function SingleOperator(predicate, source) {
	        this.predicate = predicate;
	        this.source = source;
	    }
	    SingleOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new SingleSubscriber(subscriber, this.predicate, this.source));
	    };
	    return SingleOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var SingleSubscriber = (function (_super) {
	    __extends$96(SingleSubscriber, _super);
	    function SingleSubscriber(destination, predicate, source) {
	        _super.call(this, destination);
	        this.predicate = predicate;
	        this.source = source;
	        this.seenValue = false;
	        this.index = 0;
	    }
	    SingleSubscriber.prototype.applySingleValue = function (value) {
	        if (this.seenValue) {
	            this.destination.error('Sequence contains more than one element');
	        }
	        else {
	            this.seenValue = true;
	            this.singleValue = value;
	        }
	    };
	    SingleSubscriber.prototype._next = function (value) {
	        var index = this.index++;
	        if (this.predicate) {
	            this.tryNext(value, index);
	        }
	        else {
	            this.applySingleValue(value);
	        }
	    };
	    SingleSubscriber.prototype.tryNext = function (value, index) {
	        try {
	            if (this.predicate(value, index, this.source)) {
	                this.applySingleValue(value);
	            }
	        }
	        catch (err) {
	            this.destination.error(err);
	        }
	    };
	    SingleSubscriber.prototype._complete = function () {
	        var destination = this.destination;
	        if (this.index > 0) {
	            destination.next(this.seenValue ? this.singleValue : undefined);
	            destination.complete();
	        }
	        else {
	            destination.error(new EmptyError_1$5.EmptyError);
	        }
	    };
	    return SingleSubscriber;
	}(Subscriber_1$43.Subscriber));


	var single_1$1 = {
		single: single_2
	};

	var Observable_1$134 = Observable_1$2;
	var single_1 = single_1$1;
	Observable_1$134.Observable.prototype.single = single_1.single;

	var __extends$97 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1$44 = Subscriber_1$3;
	/**
	 * Returns an Observable that skips the first `count` items emitted by the source Observable.
	 *
	 * <img src="./img/skip.png" width="100%">
	 *
	 * @param {Number} count - The number of times, items emitted by source Observable should be skipped.
	 * @return {Observable} An Observable that skips values emitted by the source Observable.
	 *
	 * @method skip
	 * @owner Observable
	 */
	function skip$2(count) {
	    return this.lift(new SkipOperator(count));
	}
	var skip_2 = skip$2;
	var SkipOperator = (function () {
	    function SkipOperator(total) {
	        this.total = total;
	    }
	    SkipOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new SkipSubscriber(subscriber, this.total));
	    };
	    return SkipOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var SkipSubscriber = (function (_super) {
	    __extends$97(SkipSubscriber, _super);
	    function SkipSubscriber(destination, total) {
	        _super.call(this, destination);
	        this.total = total;
	        this.count = 0;
	    }
	    SkipSubscriber.prototype._next = function (x) {
	        if (++this.count > this.total) {
	            this.destination.next(x);
	        }
	    };
	    return SkipSubscriber;
	}(Subscriber_1$44.Subscriber));


	var skip_1$1 = {
		skip: skip_2
	};

	var Observable_1$135 = Observable_1$2;
	var skip_1 = skip_1$1;
	Observable_1$135.Observable.prototype.skip = skip_1.skip;

	var __extends$98 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1$45 = Subscriber_1$3;
	var ArgumentOutOfRangeError_1$4 = ArgumentOutOfRangeError_1$2;
	/**
	 * Skip the last `count` values emitted by the source Observable.
	 *
	 * <img src="./img/skipLast.png" width="100%">
	 *
	 * `skipLast` returns an Observable that accumulates a queue with a length
	 * enough to store the first `count` values. As more values are received,
	 * values are taken from the front of the queue and produced on the result
	 * sequence. This causes values to be delayed.
	 *
	 * @example <caption>Skip the last 2 values of an Observable with many values</caption>
	 * var many = Rx.Observable.range(1, 5);
	 * var skipLastTwo = many.skipLast(2);
	 * skipLastTwo.subscribe(x => console.log(x));
	 *
	 * // Results in:
	 * // 1 2 3
	 *
	 * @see {@link skip}
	 * @see {@link skipUntil}
	 * @see {@link skipWhile}
	 * @see {@link take}
	 *
	 * @throws {ArgumentOutOfRangeError} When using `skipLast(i)`, it throws
	 * ArgumentOutOrRangeError if `i < 0`.
	 *
	 * @param {number} count Number of elements to skip from the end of the source Observable.
	 * @returns {Observable<T>} An Observable that skips the last count values
	 * emitted by the source Observable.
	 * @method skipLast
	 * @owner Observable
	 */
	function skipLast$2(count) {
	    return this.lift(new SkipLastOperator(count));
	}
	var skipLast_2 = skipLast$2;
	var SkipLastOperator = (function () {
	    function SkipLastOperator(_skipCount) {
	        this._skipCount = _skipCount;
	        if (this._skipCount < 0) {
	            throw new ArgumentOutOfRangeError_1$4.ArgumentOutOfRangeError;
	        }
	    }
	    SkipLastOperator.prototype.call = function (subscriber, source) {
	        if (this._skipCount === 0) {
	            // If we don't want to skip any values then just subscribe
	            // to Subscriber without any further logic.
	            return source.subscribe(new Subscriber_1$45.Subscriber(subscriber));
	        }
	        else {
	            return source.subscribe(new SkipLastSubscriber(subscriber, this._skipCount));
	        }
	    };
	    return SkipLastOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var SkipLastSubscriber = (function (_super) {
	    __extends$98(SkipLastSubscriber, _super);
	    function SkipLastSubscriber(destination, _skipCount) {
	        _super.call(this, destination);
	        this._skipCount = _skipCount;
	        this._count = 0;
	        this._ring = new Array(_skipCount);
	    }
	    SkipLastSubscriber.prototype._next = function (value) {
	        var skipCount = this._skipCount;
	        var count = this._count++;
	        if (count < skipCount) {
	            this._ring[count] = value;
	        }
	        else {
	            var currentIndex = count % skipCount;
	            var ring = this._ring;
	            var oldValue = ring[currentIndex];
	            ring[currentIndex] = value;
	            this.destination.next(oldValue);
	        }
	    };
	    return SkipLastSubscriber;
	}(Subscriber_1$45.Subscriber));


	var skipLast_1$1 = {
		skipLast: skipLast_2
	};

	var Observable_1$136 = Observable_1$2;
	var skipLast_1 = skipLast_1$1;
	Observable_1$136.Observable.prototype.skipLast = skipLast_1.skipLast;

	var __extends$99 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var OuterSubscriber_1$28 = OuterSubscriber_1$1;
	var subscribeToResult_1$28 = subscribeToResult_1$1;
	/**
	 * Returns an Observable that skips items emitted by the source Observable until a second Observable emits an item.
	 *
	 * <img src="./img/skipUntil.png" width="100%">
	 *
	 * @param {Observable} notifier - The second Observable that has to emit an item before the source Observable's elements begin to
	 * be mirrored by the resulting Observable.
	 * @return {Observable<T>} An Observable that skips items from the source Observable until the second Observable emits
	 * an item, then emits the remaining items.
	 * @method skipUntil
	 * @owner Observable
	 */
	function skipUntil$2(notifier) {
	    return this.lift(new SkipUntilOperator(notifier));
	}
	var skipUntil_2 = skipUntil$2;
	var SkipUntilOperator = (function () {
	    function SkipUntilOperator(notifier) {
	        this.notifier = notifier;
	    }
	    SkipUntilOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new SkipUntilSubscriber(subscriber, this.notifier));
	    };
	    return SkipUntilOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var SkipUntilSubscriber = (function (_super) {
	    __extends$99(SkipUntilSubscriber, _super);
	    function SkipUntilSubscriber(destination, notifier) {
	        _super.call(this, destination);
	        this.hasValue = false;
	        this.isInnerStopped = false;
	        this.add(subscribeToResult_1$28.subscribeToResult(this, notifier));
	    }
	    SkipUntilSubscriber.prototype._next = function (value) {
	        if (this.hasValue) {
	            _super.prototype._next.call(this, value);
	        }
	    };
	    SkipUntilSubscriber.prototype._complete = function () {
	        if (this.isInnerStopped) {
	            _super.prototype._complete.call(this);
	        }
	        else {
	            this.unsubscribe();
	        }
	    };
	    SkipUntilSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        this.hasValue = true;
	    };
	    SkipUntilSubscriber.prototype.notifyComplete = function () {
	        this.isInnerStopped = true;
	        if (this.isStopped) {
	            _super.prototype._complete.call(this);
	        }
	    };
	    return SkipUntilSubscriber;
	}(OuterSubscriber_1$28.OuterSubscriber));


	var skipUntil_1$1 = {
		skipUntil: skipUntil_2
	};

	var Observable_1$137 = Observable_1$2;
	var skipUntil_1 = skipUntil_1$1;
	Observable_1$137.Observable.prototype.skipUntil = skipUntil_1.skipUntil;

	var __extends$100 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1$46 = Subscriber_1$3;
	/**
	 * Returns an Observable that skips all items emitted by the source Observable as long as a specified condition holds
	 * true, but emits all further source items as soon as the condition becomes false.
	 *
	 * <img src="./img/skipWhile.png" width="100%">
	 *
	 * @param {Function} predicate - A function to test each item emitted from the source Observable.
	 * @return {Observable<T>} An Observable that begins emitting items emitted by the source Observable when the
	 * specified predicate becomes false.
	 * @method skipWhile
	 * @owner Observable
	 */
	function skipWhile$2(predicate) {
	    return this.lift(new SkipWhileOperator(predicate));
	}
	var skipWhile_2 = skipWhile$2;
	var SkipWhileOperator = (function () {
	    function SkipWhileOperator(predicate) {
	        this.predicate = predicate;
	    }
	    SkipWhileOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new SkipWhileSubscriber(subscriber, this.predicate));
	    };
	    return SkipWhileOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var SkipWhileSubscriber = (function (_super) {
	    __extends$100(SkipWhileSubscriber, _super);
	    function SkipWhileSubscriber(destination, predicate) {
	        _super.call(this, destination);
	        this.predicate = predicate;
	        this.skipping = true;
	        this.index = 0;
	    }
	    SkipWhileSubscriber.prototype._next = function (value) {
	        var destination = this.destination;
	        if (this.skipping) {
	            this.tryCallPredicate(value);
	        }
	        if (!this.skipping) {
	            destination.next(value);
	        }
	    };
	    SkipWhileSubscriber.prototype.tryCallPredicate = function (value) {
	        try {
	            var result = this.predicate(value, this.index++);
	            this.skipping = Boolean(result);
	        }
	        catch (err) {
	            this.destination.error(err);
	        }
	    };
	    return SkipWhileSubscriber;
	}(Subscriber_1$46.Subscriber));


	var skipWhile_1$1 = {
		skipWhile: skipWhile_2
	};

	var Observable_1$138 = Observable_1$2;
	var skipWhile_1 = skipWhile_1$1;
	Observable_1$138.Observable.prototype.skipWhile = skipWhile_1.skipWhile;

	var ArrayObservable_1$10 = ArrayObservable_1$1;
	var ScalarObservable_1$4 = ScalarObservable_1$1;
	var EmptyObservable_1$7 = EmptyObservable_1$1;
	var concat_1$6 = concat_1$3;
	var isScheduler_1$9 = isScheduler_1$1;
	/* tslint:enable:max-line-length */
	/**
	 * Returns an Observable that emits the items you specify as arguments before it begins to emit
	 * items emitted by the source Observable.
	 *
	 * <img src="./img/startWith.png" width="100%">
	 *
	 * @param {...T} values - Items you want the modified Observable to emit first.
	 * @param {Scheduler} [scheduler] - A {@link IScheduler} to use for scheduling
	 * the emissions of the `next` notifications.
	 * @return {Observable} An Observable that emits the items in the specified Iterable and then emits the items
	 * emitted by the source Observable.
	 * @method startWith
	 * @owner Observable
	 */
	function startWith$2() {
	    var array = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        array[_i - 0] = arguments[_i];
	    }
	    var scheduler = array[array.length - 1];
	    if (isScheduler_1$9.isScheduler(scheduler)) {
	        array.pop();
	    }
	    else {
	        scheduler = null;
	    }
	    var len = array.length;
	    if (len === 1) {
	        return concat_1$6.concatStatic(new ScalarObservable_1$4.ScalarObservable(array[0], scheduler), this);
	    }
	    else if (len > 1) {
	        return concat_1$6.concatStatic(new ArrayObservable_1$10.ArrayObservable(array, scheduler), this);
	    }
	    else {
	        return concat_1$6.concatStatic(new EmptyObservable_1$7.EmptyObservable(scheduler), this);
	    }
	}
	var startWith_2 = startWith$2;


	var startWith_1$1 = {
		startWith: startWith_2
	};

	var Observable_1$139 = Observable_1$2;
	var startWith_1 = startWith_1$1;
	Observable_1$139.Observable.prototype.startWith = startWith_1.startWith;

	var root_1$11 = root$1;
	var ImmediateDefinition = (function () {
	    function ImmediateDefinition(root) {
	        this.root = root;
	        if (root.setImmediate && typeof root.setImmediate === 'function') {
	            this.setImmediate = root.setImmediate.bind(root);
	            this.clearImmediate = root.clearImmediate.bind(root);
	        }
	        else {
	            this.nextHandle = 1;
	            this.tasksByHandle = {};
	            this.currentlyRunningATask = false;
	            // Don't get fooled by e.g. browserify environments.
	            if (this.canUseProcessNextTick()) {
	                // For Node.js before 0.9
	                this.setImmediate = this.createProcessNextTickSetImmediate();
	            }
	            else if (this.canUsePostMessage()) {
	                // For non-IE10 modern browsers
	                this.setImmediate = this.createPostMessageSetImmediate();
	            }
	            else if (this.canUseMessageChannel()) {
	                // For web workers, where supported
	                this.setImmediate = this.createMessageChannelSetImmediate();
	            }
	            else if (this.canUseReadyStateChange()) {
	                // For IE 68
	                this.setImmediate = this.createReadyStateChangeSetImmediate();
	            }
	            else {
	                // For older browsers
	                this.setImmediate = this.createSetTimeoutSetImmediate();
	            }
	            var ci = function clearImmediate(handle) {
	                delete clearImmediate.instance.tasksByHandle[handle];
	            };
	            ci.instance = this;
	            this.clearImmediate = ci;
	        }
	    }
	    ImmediateDefinition.prototype.identify = function (o) {
	        return this.root.Object.prototype.toString.call(o);
	    };
	    ImmediateDefinition.prototype.canUseProcessNextTick = function () {
	        return this.identify(this.root.process) === '[object process]';
	    };
	    ImmediateDefinition.prototype.canUseMessageChannel = function () {
	        return Boolean(this.root.MessageChannel);
	    };
	    ImmediateDefinition.prototype.canUseReadyStateChange = function () {
	        var document = this.root.document;
	        return Boolean(document && 'onreadystatechange' in document.createElement('script'));
	    };
	    ImmediateDefinition.prototype.canUsePostMessage = function () {
	        var root = this.root;
	        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
	        // where `root.postMessage` means something completely different and can't be used for this purpose.
	        if (root.postMessage && !root.importScripts) {
	            var postMessageIsAsynchronous_1 = true;
	            var oldOnMessage = root.onmessage;
	            root.onmessage = function () {
	                postMessageIsAsynchronous_1 = false;
	            };
	            root.postMessage('', '*');
	            root.onmessage = oldOnMessage;
	            return postMessageIsAsynchronous_1;
	        }
	        return false;
	    };
	    // This function accepts the same arguments as setImmediate, but
	    // returns a function that requires no arguments.
	    ImmediateDefinition.prototype.partiallyApplied = function (handler) {
	        var args = [];
	        for (var _i = 1; _i < arguments.length; _i++) {
	            args[_i - 1] = arguments[_i];
	        }
	        var fn = function result() {
	            var _a = result, handler = _a.handler, args = _a.args;
	            if (typeof handler === 'function') {
	                handler.apply(undefined, args);
	            }
	            else {
	                (new Function('' + handler))();
	            }
	        };
	        fn.handler = handler;
	        fn.args = args;
	        return fn;
	    };
	    ImmediateDefinition.prototype.addFromSetImmediateArguments = function (args) {
	        this.tasksByHandle[this.nextHandle] = this.partiallyApplied.apply(undefined, args);
	        return this.nextHandle++;
	    };
	    ImmediateDefinition.prototype.createProcessNextTickSetImmediate = function () {
	        var fn = function setImmediate() {
	            var instance = setImmediate.instance;
	            var handle = instance.addFromSetImmediateArguments(arguments);
	            instance.root.process.nextTick(instance.partiallyApplied(instance.runIfPresent, handle));
	            return handle;
	        };
	        fn.instance = this;
	        return fn;
	    };
	    ImmediateDefinition.prototype.createPostMessageSetImmediate = function () {
	        // Installs an event handler on `global` for the `message` event: see
	        // * https://developer.mozilla.org/en/DOM/window.postMessage
	        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages
	        var root = this.root;
	        var messagePrefix = 'setImmediate$' + root.Math.random() + '$';
	        var onGlobalMessage = function globalMessageHandler(event) {
	            var instance = globalMessageHandler.instance;
	            if (event.source === root &&
	                typeof event.data === 'string' &&
	                event.data.indexOf(messagePrefix) === 0) {
	                instance.runIfPresent(+event.data.slice(messagePrefix.length));
	            }
	        };
	        onGlobalMessage.instance = this;
	        root.addEventListener('message', onGlobalMessage, false);
	        var fn = function setImmediate() {
	            var _a = setImmediate, messagePrefix = _a.messagePrefix, instance = _a.instance;
	            var handle = instance.addFromSetImmediateArguments(arguments);
	            instance.root.postMessage(messagePrefix + handle, '*');
	            return handle;
	        };
	        fn.instance = this;
	        fn.messagePrefix = messagePrefix;
	        return fn;
	    };
	    ImmediateDefinition.prototype.runIfPresent = function (handle) {
	        // From the spec: 'Wait until any invocations of this algorithm started before this one have completed.'
	        // So if we're currently running a task, we'll need to delay this invocation.
	        if (this.currentlyRunningATask) {
	            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
	            // 'too much recursion' error.
	            this.root.setTimeout(this.partiallyApplied(this.runIfPresent, handle), 0);
	        }
	        else {
	            var task = this.tasksByHandle[handle];
	            if (task) {
	                this.currentlyRunningATask = true;
	                try {
	                    task();
	                }
	                finally {
	                    this.clearImmediate(handle);
	                    this.currentlyRunningATask = false;
	                }
	            }
	        }
	    };
	    ImmediateDefinition.prototype.createMessageChannelSetImmediate = function () {
	        var _this = this;
	        var channel = new this.root.MessageChannel();
	        channel.port1.onmessage = function (event) {
	            var handle = event.data;
	            _this.runIfPresent(handle);
	        };
	        var fn = function setImmediate() {
	            var _a = setImmediate, channel = _a.channel, instance = _a.instance;
	            var handle = instance.addFromSetImmediateArguments(arguments);
	            channel.port2.postMessage(handle);
	            return handle;
	        };
	        fn.channel = channel;
	        fn.instance = this;
	        return fn;
	    };
	    ImmediateDefinition.prototype.createReadyStateChangeSetImmediate = function () {
	        var fn = function setImmediate() {
	            var instance = setImmediate.instance;
	            var root = instance.root;
	            var doc = root.document;
	            var html = doc.documentElement;
	            var handle = instance.addFromSetImmediateArguments(arguments);
	            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
	            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
	            var script = doc.createElement('script');
	            script.onreadystatechange = function () {
	                instance.runIfPresent(handle);
	                script.onreadystatechange = null;
	                html.removeChild(script);
	                script = null;
	            };
	            html.appendChild(script);
	            return handle;
	        };
	        fn.instance = this;
	        return fn;
	    };
	    ImmediateDefinition.prototype.createSetTimeoutSetImmediate = function () {
	        var fn = function setImmediate() {
	            var instance = setImmediate.instance;
	            var handle = instance.addFromSetImmediateArguments(arguments);
	            instance.root.setTimeout(instance.partiallyApplied(instance.runIfPresent, handle), 0);
	            return handle;
	        };
	        fn.instance = this;
	        return fn;
	    };
	    return ImmediateDefinition;
	}());
	var ImmediateDefinition_1 = ImmediateDefinition;
	var Immediate_1$1 = new ImmediateDefinition(root_1$11.root);


	var Immediate = {
		ImmediateDefinition: ImmediateDefinition_1,
		Immediate: Immediate_1$1
	};

	var __extends$102 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Immediate_1 = Immediate;
	var AsyncAction_1$4 = AsyncAction_1$1;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var AsapAction = (function (_super) {
	    __extends$102(AsapAction, _super);
	    function AsapAction(scheduler, work) {
	        _super.call(this, scheduler, work);
	        this.scheduler = scheduler;
	        this.work = work;
	    }
	    AsapAction.prototype.requestAsyncId = function (scheduler, id, delay) {
	        if (delay === void 0) { delay = 0; }
	        // If delay is greater than 0, request as an async action.
	        if (delay !== null && delay > 0) {
	            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
	        }
	        // Push the action to the end of the scheduler queue.
	        scheduler.actions.push(this);
	        // If a microtask has already been scheduled, don't schedule another
	        // one. If a microtask hasn't been scheduled yet, schedule one now. Return
	        // the current scheduled microtask id.
	        return scheduler.scheduled || (scheduler.scheduled = Immediate_1.Immediate.setImmediate(scheduler.flush.bind(scheduler, null)));
	    };
	    AsapAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
	        if (delay === void 0) { delay = 0; }
	        // If delay exists and is greater than 0, or if the delay is null (the
	        // action wasn't rescheduled) but was originally scheduled as an async
	        // action, then recycle as an async action.
	        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
	            return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
	        }
	        // If the scheduler queue is empty, cancel the requested microtask and
	        // set the scheduled flag to undefined so the next AsapAction will schedule
	        // its own.
	        if (scheduler.actions.length === 0) {
	            Immediate_1.Immediate.clearImmediate(id);
	            scheduler.scheduled = undefined;
	        }
	        // Return undefined so the action knows to request a new async id if it's rescheduled.
	        return undefined;
	    };
	    return AsapAction;
	}(AsyncAction_1$4.AsyncAction));
	var AsapAction_2 = AsapAction;


	var AsapAction_1$1 = {
		AsapAction: AsapAction_2
	};

	var __extends$103 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AsyncScheduler_1$4 = AsyncScheduler_1$1;
	var AsapScheduler = (function (_super) {
	    __extends$103(AsapScheduler, _super);
	    function AsapScheduler() {
	        _super.apply(this, arguments);
	    }
	    AsapScheduler.prototype.flush = function (action) {
	        this.active = true;
	        this.scheduled = undefined;
	        var actions = this.actions;
	        var error;
	        var index = -1;
	        var count = actions.length;
	        action = action || actions.shift();
	        do {
	            if (error = action.execute(action.state, action.delay)) {
	                break;
	            }
	        } while (++index < count && (action = actions.shift()));
	        this.active = false;
	        if (error) {
	            while (++index < count && (action = actions.shift())) {
	                action.unsubscribe();
	            }
	            throw error;
	        }
	    };
	    return AsapScheduler;
	}(AsyncScheduler_1$4.AsyncScheduler));
	var AsapScheduler_2 = AsapScheduler;


	var AsapScheduler_1$1 = {
		AsapScheduler: AsapScheduler_2
	};

	var AsapAction_1 = AsapAction_1$1;
	var AsapScheduler_1 = AsapScheduler_1$1;
	/**
	 *
	 * Asap Scheduler
	 *
	 * <span class="informal">Perform task as fast as it can be performed asynchronously</span>
	 *
	 * `asap` scheduler behaves the same as {@link async} scheduler when you use it to delay task
	 * in time. If however you set delay to `0`, `asap` will wait for current synchronously executing
	 * code to end and then it will try to execute given task as fast as possible.
	 *
	 * `asap` scheduler will do its best to minimize time between end of currently executing code
	 * and start of scheduled task. This makes it best candidate for performing so called "deferring".
	 * Traditionally this was achieved by calling `setTimeout(deferredTask, 0)`, but that technique involves
	 * some (although minimal) unwanted delay.
	 *
	 * Note that using `asap` scheduler does not necessarily mean that your task will be first to process
	 * after currently executing code. In particular, if some task was also scheduled with `asap` before,
	 * that task will execute first. That being said, if you need to schedule task asynchronously, but
	 * as soon as possible, `asap` scheduler is your best bet.
	 *
	 * @example <caption>Compare async and asap scheduler</caption>
	 *
	 * Rx.Scheduler.async.schedule(() => console.log('async')); // scheduling 'async' first...
	 * Rx.Scheduler.asap.schedule(() => console.log('asap'));
	 *
	 * // Logs:
	 * // "asap"
	 * // "async"
	 * // ... but 'asap' goes first!
	 *
	 * @static true
	 * @name asap
	 * @owner Scheduler
	 */
	var asap_1$2 = new AsapScheduler_1.AsapScheduler(AsapAction_1.AsapAction);


	var asap = {
		asap: asap_1$2
	};

	var __extends$101 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Observable_1$141 = Observable_1$2;
	var asap_1$1 = asap;
	var isNumeric_1$4 = isNumeric_1$1;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var SubscribeOnObservable = (function (_super) {
	    __extends$101(SubscribeOnObservable, _super);
	    function SubscribeOnObservable(source, delayTime, scheduler) {
	        if (delayTime === void 0) { delayTime = 0; }
	        if (scheduler === void 0) { scheduler = asap_1$1.asap; }
	        _super.call(this);
	        this.source = source;
	        this.delayTime = delayTime;
	        this.scheduler = scheduler;
	        if (!isNumeric_1$4.isNumeric(delayTime) || delayTime < 0) {
	            this.delayTime = 0;
	        }
	        if (!scheduler || typeof scheduler.schedule !== 'function') {
	            this.scheduler = asap_1$1.asap;
	        }
	    }
	    SubscribeOnObservable.create = function (source, delay, scheduler) {
	        if (delay === void 0) { delay = 0; }
	        if (scheduler === void 0) { scheduler = asap_1$1.asap; }
	        return new SubscribeOnObservable(source, delay, scheduler);
	    };
	    SubscribeOnObservable.dispatch = function (arg) {
	        var source = arg.source, subscriber = arg.subscriber;
	        return this.add(source.subscribe(subscriber));
	    };
	    SubscribeOnObservable.prototype._subscribe = function (subscriber) {
	        var delay = this.delayTime;
	        var source = this.source;
	        var scheduler = this.scheduler;
	        return scheduler.schedule(SubscribeOnObservable.dispatch, delay, {
	            source: source, subscriber: subscriber
	        });
	    };
	    return SubscribeOnObservable;
	}(Observable_1$141.Observable));
	var SubscribeOnObservable_2 = SubscribeOnObservable;


	var SubscribeOnObservable_1$1 = {
		SubscribeOnObservable: SubscribeOnObservable_2
	};

	var SubscribeOnObservable_1 = SubscribeOnObservable_1$1;
	/**
	 * Asynchronously subscribes Observers to this Observable on the specified IScheduler.
	 *
	 * <img src="./img/subscribeOn.png" width="100%">
	 *
	 * @param {Scheduler} scheduler - The IScheduler to perform subscription actions on.
	 * @return {Observable<T>} The source Observable modified so that its subscriptions happen on the specified IScheduler.
	 .
	 * @method subscribeOn
	 * @owner Observable
	 */
	function subscribeOn$2(scheduler, delay) {
	    if (delay === void 0) { delay = 0; }
	    return this.lift(new SubscribeOnOperator(scheduler, delay));
	}
	var subscribeOn_2 = subscribeOn$2;
	var SubscribeOnOperator = (function () {
	    function SubscribeOnOperator(scheduler, delay) {
	        this.scheduler = scheduler;
	        this.delay = delay;
	    }
	    SubscribeOnOperator.prototype.call = function (subscriber, source) {
	        return new SubscribeOnObservable_1.SubscribeOnObservable(source, this.delay, this.scheduler).subscribe(subscriber);
	    };
	    return SubscribeOnOperator;
	}());


	var subscribeOn_1$1 = {
		subscribeOn: subscribeOn_2
	};

	var Observable_1$140 = Observable_1$2;
	var subscribeOn_1 = subscribeOn_1$1;
	Observable_1$140.Observable.prototype.subscribeOn = subscribeOn_1.subscribeOn;

	var __extends$104 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var OuterSubscriber_1$29 = OuterSubscriber_1$1;
	var subscribeToResult_1$29 = subscribeToResult_1$1;
	/**
	 * Converts a higher-order Observable into a first-order Observable by
	 * subscribing to only the most recently emitted of those inner Observables.
	 *
	 * <span class="informal">Flattens an Observable-of-Observables by dropping the
	 * previous inner Observable once a new one appears.</span>
	 *
	 * <img src="./img/switch.png" width="100%">
	 *
	 * `switch` subscribes to an Observable that emits Observables, also known as a
	 * higher-order Observable. Each time it observes one of these emitted inner
	 * Observables, the output Observable subscribes to the inner Observable and
	 * begins emitting the items emitted by that. So far, it behaves
	 * like {@link mergeAll}. However, when a new inner Observable is emitted,
	 * `switch` unsubscribes from the earlier-emitted inner Observable and
	 * subscribes to the new inner Observable and begins emitting items from it. It
	 * continues to behave like this for subsequent inner Observables.
	 *
	 * @example <caption>Rerun an interval Observable on every click event</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * // Each click event is mapped to an Observable that ticks every second
	 * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000));
	 * var switched = higherOrder.switch();
	 * // The outcome is that `switched` is essentially a timer that restarts
	 * // on every click. The interval Observables from older clicks do not merge
	 * // with the current interval Observable.
	 * switched.subscribe(x => console.log(x));
	 *
	 * @see {@link combineAll}
	 * @see {@link concatAll}
	 * @see {@link exhaust}
	 * @see {@link mergeAll}
	 * @see {@link switchMap}
	 * @see {@link switchMapTo}
	 * @see {@link zipAll}
	 *
	 * @return {Observable<T>} An Observable that emits the items emitted by the
	 * Observable most recently emitted by the source Observable.
	 * @method switch
	 * @name switch
	 * @owner Observable
	 */
	function _switch$2() {
	    return this.lift(new SwitchOperator());
	}
	var _switch_2 = _switch$2;
	var SwitchOperator = (function () {
	    function SwitchOperator() {
	    }
	    SwitchOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new SwitchSubscriber(subscriber));
	    };
	    return SwitchOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var SwitchSubscriber = (function (_super) {
	    __extends$104(SwitchSubscriber, _super);
	    function SwitchSubscriber(destination) {
	        _super.call(this, destination);
	        this.active = 0;
	        this.hasCompleted = false;
	    }
	    SwitchSubscriber.prototype._next = function (value) {
	        this.unsubscribeInner();
	        this.active++;
	        this.add(this.innerSubscription = subscribeToResult_1$29.subscribeToResult(this, value));
	    };
	    SwitchSubscriber.prototype._complete = function () {
	        this.hasCompleted = true;
	        if (this.active === 0) {
	            this.destination.complete();
	        }
	    };
	    SwitchSubscriber.prototype.unsubscribeInner = function () {
	        this.active = this.active > 0 ? this.active - 1 : 0;
	        var innerSubscription = this.innerSubscription;
	        if (innerSubscription) {
	            innerSubscription.unsubscribe();
	            this.remove(innerSubscription);
	        }
	    };
	    SwitchSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        this.destination.next(innerValue);
	    };
	    SwitchSubscriber.prototype.notifyError = function (err) {
	        this.destination.error(err);
	    };
	    SwitchSubscriber.prototype.notifyComplete = function () {
	        this.unsubscribeInner();
	        if (this.hasCompleted && this.active === 0) {
	            this.destination.complete();
	        }
	    };
	    return SwitchSubscriber;
	}(OuterSubscriber_1$29.OuterSubscriber));


	var _switch_1 = {
		_switch: _switch_2
	};

	var Observable_1$142 = Observable_1$2;
	var switch_1 = _switch_1;
	Observable_1$142.Observable.prototype.switch = switch_1._switch;
	Observable_1$142.Observable.prototype._switch = switch_1._switch;

	var __extends$105 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var OuterSubscriber_1$30 = OuterSubscriber_1$1;
	var subscribeToResult_1$30 = subscribeToResult_1$1;
	/* tslint:enable:max-line-length */
	/**
	 * Projects each source value to an Observable which is merged in the output
	 * Observable, emitting values only from the most recently projected Observable.
	 *
	 * <span class="informal">Maps each value to an Observable, then flattens all of
	 * these inner Observables using {@link switch}.</span>
	 *
	 * <img src="./img/switchMap.png" width="100%">
	 *
	 * Returns an Observable that emits items based on applying a function that you
	 * supply to each item emitted by the source Observable, where that function
	 * returns an (so-called "inner") Observable. Each time it observes one of these
	 * inner Observables, the output Observable begins emitting the items emitted by
	 * that inner Observable. When a new inner Observable is emitted, `switchMap`
	 * stops emitting items from the earlier-emitted inner Observable and begins
	 * emitting items from the new one. It continues to behave like this for
	 * subsequent inner Observables.
	 *
	 * @example <caption>Rerun an interval Observable on every click event</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = clicks.switchMap((ev) => Rx.Observable.interval(1000));
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link concatMap}
	 * @see {@link exhaustMap}
	 * @see {@link mergeMap}
	 * @see {@link switch}
	 * @see {@link switchMapTo}
	 *
	 * @param {function(value: T, ?index: number): ObservableInput} project A function
	 * that, when applied to an item emitted by the source Observable, returns an
	 * Observable.
	 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
	 * A function to produce the value on the output Observable based on the values
	 * and the indices of the source (outer) emission and the inner Observable
	 * emission. The arguments passed to this function are:
	 * - `outerValue`: the value that came from the source
	 * - `innerValue`: the value that came from the projected Observable
	 * - `outerIndex`: the "index" of the value that came from the source
	 * - `innerIndex`: the "index" of the value from the projected Observable
	 * @return {Observable} An Observable that emits the result of applying the
	 * projection function (and the optional `resultSelector`) to each item emitted
	 * by the source Observable and taking only the values from the most recently
	 * projected inner Observable.
	 * @method switchMap
	 * @owner Observable
	 */
	function switchMap$2(project, resultSelector) {
	    return this.lift(new SwitchMapOperator(project, resultSelector));
	}
	var switchMap_2 = switchMap$2;
	var SwitchMapOperator = (function () {
	    function SwitchMapOperator(project, resultSelector) {
	        this.project = project;
	        this.resultSelector = resultSelector;
	    }
	    SwitchMapOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new SwitchMapSubscriber(subscriber, this.project, this.resultSelector));
	    };
	    return SwitchMapOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var SwitchMapSubscriber = (function (_super) {
	    __extends$105(SwitchMapSubscriber, _super);
	    function SwitchMapSubscriber(destination, project, resultSelector) {
	        _super.call(this, destination);
	        this.project = project;
	        this.resultSelector = resultSelector;
	        this.index = 0;
	    }
	    SwitchMapSubscriber.prototype._next = function (value) {
	        var result;
	        var index = this.index++;
	        try {
	            result = this.project(value, index);
	        }
	        catch (error) {
	            this.destination.error(error);
	            return;
	        }
	        this._innerSub(result, value, index);
	    };
	    SwitchMapSubscriber.prototype._innerSub = function (result, value, index) {
	        var innerSubscription = this.innerSubscription;
	        if (innerSubscription) {
	            innerSubscription.unsubscribe();
	        }
	        this.add(this.innerSubscription = subscribeToResult_1$30.subscribeToResult(this, result, value, index));
	    };
	    SwitchMapSubscriber.prototype._complete = function () {
	        var innerSubscription = this.innerSubscription;
	        if (!innerSubscription || innerSubscription.closed) {
	            _super.prototype._complete.call(this);
	        }
	    };
	    SwitchMapSubscriber.prototype._unsubscribe = function () {
	        this.innerSubscription = null;
	    };
	    SwitchMapSubscriber.prototype.notifyComplete = function (innerSub) {
	        this.remove(innerSub);
	        this.innerSubscription = null;
	        if (this.isStopped) {
	            _super.prototype._complete.call(this);
	        }
	    };
	    SwitchMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        if (this.resultSelector) {
	            this._tryNotifyNext(outerValue, innerValue, outerIndex, innerIndex);
	        }
	        else {
	            this.destination.next(innerValue);
	        }
	    };
	    SwitchMapSubscriber.prototype._tryNotifyNext = function (outerValue, innerValue, outerIndex, innerIndex) {
	        var result;
	        try {
	            result = this.resultSelector(outerValue, innerValue, outerIndex, innerIndex);
	        }
	        catch (err) {
	            this.destination.error(err);
	            return;
	        }
	        this.destination.next(result);
	    };
	    return SwitchMapSubscriber;
	}(OuterSubscriber_1$30.OuterSubscriber));


	var switchMap_1$1 = {
		switchMap: switchMap_2
	};

	var Observable_1$143 = Observable_1$2;
	var switchMap_1 = switchMap_1$1;
	Observable_1$143.Observable.prototype.switchMap = switchMap_1.switchMap;

	var __extends$106 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var OuterSubscriber_1$31 = OuterSubscriber_1$1;
	var subscribeToResult_1$31 = subscribeToResult_1$1;
	/* tslint:enable:max-line-length */
	/**
	 * Projects each source value to the same Observable which is flattened multiple
	 * times with {@link switch} in the output Observable.
	 *
	 * <span class="informal">It's like {@link switchMap}, but maps each value
	 * always to the same inner Observable.</span>
	 *
	 * <img src="./img/switchMapTo.png" width="100%">
	 *
	 * Maps each source value to the given Observable `innerObservable` regardless
	 * of the source value, and then flattens those resulting Observables into one
	 * single Observable, which is the output Observable. The output Observables
	 * emits values only from the most recently emitted instance of
	 * `innerObservable`.
	 *
	 * @example <caption>Rerun an interval Observable on every click event</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = clicks.switchMapTo(Rx.Observable.interval(1000));
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link concatMapTo}
	 * @see {@link switch}
	 * @see {@link switchMap}
	 * @see {@link mergeMapTo}
	 *
	 * @param {ObservableInput} innerObservable An Observable to replace each value from
	 * the source Observable.
	 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
	 * A function to produce the value on the output Observable based on the values
	 * and the indices of the source (outer) emission and the inner Observable
	 * emission. The arguments passed to this function are:
	 * - `outerValue`: the value that came from the source
	 * - `innerValue`: the value that came from the projected Observable
	 * - `outerIndex`: the "index" of the value that came from the source
	 * - `innerIndex`: the "index" of the value from the projected Observable
	 * @return {Observable} An Observable that emits items from the given
	 * `innerObservable` (and optionally transformed through `resultSelector`) every
	 * time a value is emitted on the source Observable, and taking only the values
	 * from the most recently projected inner Observable.
	 * @method switchMapTo
	 * @owner Observable
	 */
	function switchMapTo$2(innerObservable, resultSelector) {
	    return this.lift(new SwitchMapToOperator(innerObservable, resultSelector));
	}
	var switchMapTo_2 = switchMapTo$2;
	var SwitchMapToOperator = (function () {
	    function SwitchMapToOperator(observable, resultSelector) {
	        this.observable = observable;
	        this.resultSelector = resultSelector;
	    }
	    SwitchMapToOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new SwitchMapToSubscriber(subscriber, this.observable, this.resultSelector));
	    };
	    return SwitchMapToOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var SwitchMapToSubscriber = (function (_super) {
	    __extends$106(SwitchMapToSubscriber, _super);
	    function SwitchMapToSubscriber(destination, inner, resultSelector) {
	        _super.call(this, destination);
	        this.inner = inner;
	        this.resultSelector = resultSelector;
	        this.index = 0;
	    }
	    SwitchMapToSubscriber.prototype._next = function (value) {
	        var innerSubscription = this.innerSubscription;
	        if (innerSubscription) {
	            innerSubscription.unsubscribe();
	        }
	        this.add(this.innerSubscription = subscribeToResult_1$31.subscribeToResult(this, this.inner, value, this.index++));
	    };
	    SwitchMapToSubscriber.prototype._complete = function () {
	        var innerSubscription = this.innerSubscription;
	        if (!innerSubscription || innerSubscription.closed) {
	            _super.prototype._complete.call(this);
	        }
	    };
	    SwitchMapToSubscriber.prototype._unsubscribe = function () {
	        this.innerSubscription = null;
	    };
	    SwitchMapToSubscriber.prototype.notifyComplete = function (innerSub) {
	        this.remove(innerSub);
	        this.innerSubscription = null;
	        if (this.isStopped) {
	            _super.prototype._complete.call(this);
	        }
	    };
	    SwitchMapToSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;
	        if (resultSelector) {
	            this.tryResultSelector(outerValue, innerValue, outerIndex, innerIndex);
	        }
	        else {
	            destination.next(innerValue);
	        }
	    };
	    SwitchMapToSubscriber.prototype.tryResultSelector = function (outerValue, innerValue, outerIndex, innerIndex) {
	        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;
	        var result;
	        try {
	            result = resultSelector(outerValue, innerValue, outerIndex, innerIndex);
	        }
	        catch (err) {
	            destination.error(err);
	            return;
	        }
	        destination.next(result);
	    };
	    return SwitchMapToSubscriber;
	}(OuterSubscriber_1$31.OuterSubscriber));


	var switchMapTo_1$1 = {
		switchMapTo: switchMapTo_2
	};

	var Observable_1$144 = Observable_1$2;
	var switchMapTo_1 = switchMapTo_1$1;
	Observable_1$144.Observable.prototype.switchMapTo = switchMapTo_1.switchMapTo;

	var __extends$107 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1$47 = Subscriber_1$3;
	var ArgumentOutOfRangeError_1$5 = ArgumentOutOfRangeError_1$2;
	var EmptyObservable_1$8 = EmptyObservable_1$1;
	/**
	 * Emits only the first `count` values emitted by the source Observable.
	 *
	 * <span class="informal">Takes the first `count` values from the source, then
	 * completes.</span>
	 *
	 * <img src="./img/take.png" width="100%">
	 *
	 * `take` returns an Observable that emits only the first `count` values emitted
	 * by the source Observable. If the source emits fewer than `count` values then
	 * all of its values are emitted. After that, it completes, regardless if the
	 * source completes.
	 *
	 * @example <caption>Take the first 5 seconds of an infinite 1-second interval Observable</caption>
	 * var interval = Rx.Observable.interval(1000);
	 * var five = interval.take(5);
	 * five.subscribe(x => console.log(x));
	 *
	 * @see {@link takeLast}
	 * @see {@link takeUntil}
	 * @see {@link takeWhile}
	 * @see {@link skip}
	 *
	 * @throws {ArgumentOutOfRangeError} When using `take(i)`, it delivers an
	 * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0`.
	 *
	 * @param {number} count The maximum number of `next` values to emit.
	 * @return {Observable<T>} An Observable that emits only the first `count`
	 * values emitted by the source Observable, or all of the values from the source
	 * if the source emits fewer than `count` values.
	 * @method take
	 * @owner Observable
	 */
	function take$3(count) {
	    if (count === 0) {
	        return new EmptyObservable_1$8.EmptyObservable();
	    }
	    else {
	        return this.lift(new TakeOperator(count));
	    }
	}
	var take_2 = take$3;
	var TakeOperator = (function () {
	    function TakeOperator(total) {
	        this.total = total;
	        if (this.total < 0) {
	            throw new ArgumentOutOfRangeError_1$5.ArgumentOutOfRangeError;
	        }
	    }
	    TakeOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new TakeSubscriber(subscriber, this.total));
	    };
	    return TakeOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var TakeSubscriber = (function (_super) {
	    __extends$107(TakeSubscriber, _super);
	    function TakeSubscriber(destination, total) {
	        _super.call(this, destination);
	        this.total = total;
	        this.count = 0;
	    }
	    TakeSubscriber.prototype._next = function (value) {
	        var total = this.total;
	        var count = ++this.count;
	        if (count <= total) {
	            this.destination.next(value);
	            if (count === total) {
	                this.destination.complete();
	                this.unsubscribe();
	            }
	        }
	    };
	    return TakeSubscriber;
	}(Subscriber_1$47.Subscriber));


	var take_1$2 = {
		take: take_2
	};

	var Observable_1$145 = Observable_1$2;
	var take_1$1 = take_1$2;
	Observable_1$145.Observable.prototype.take = take_1$1.take;

	var __extends$108 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1$48 = Subscriber_1$3;
	var ArgumentOutOfRangeError_1$6 = ArgumentOutOfRangeError_1$2;
	var EmptyObservable_1$9 = EmptyObservable_1$1;
	/**
	 * Emits only the last `count` values emitted by the source Observable.
	 *
	 * <span class="informal">Remembers the latest `count` values, then emits those
	 * only when the source completes.</span>
	 *
	 * <img src="./img/takeLast.png" width="100%">
	 *
	 * `takeLast` returns an Observable that emits at most the last `count` values
	 * emitted by the source Observable. If the source emits fewer than `count`
	 * values then all of its values are emitted. This operator must wait until the
	 * `complete` notification emission from the source in order to emit the `next`
	 * values on the output Observable, because otherwise it is impossible to know
	 * whether or not more values will be emitted on the source. For this reason,
	 * all values are emitted synchronously, followed by the complete notification.
	 *
	 * @example <caption>Take the last 3 values of an Observable with many values</caption>
	 * var many = Rx.Observable.range(1, 100);
	 * var lastThree = many.takeLast(3);
	 * lastThree.subscribe(x => console.log(x));
	 *
	 * @see {@link take}
	 * @see {@link takeUntil}
	 * @see {@link takeWhile}
	 * @see {@link skip}
	 *
	 * @throws {ArgumentOutOfRangeError} When using `takeLast(i)`, it delivers an
	 * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0`.
	 *
	 * @param {number} count The maximum number of values to emit from the end of
	 * the sequence of values emitted by the source Observable.
	 * @return {Observable<T>} An Observable that emits at most the last count
	 * values emitted by the source Observable.
	 * @method takeLast
	 * @owner Observable
	 */
	function takeLast$2(count) {
	    if (count === 0) {
	        return new EmptyObservable_1$9.EmptyObservable();
	    }
	    else {
	        return this.lift(new TakeLastOperator(count));
	    }
	}
	var takeLast_2 = takeLast$2;
	var TakeLastOperator = (function () {
	    function TakeLastOperator(total) {
	        this.total = total;
	        if (this.total < 0) {
	            throw new ArgumentOutOfRangeError_1$6.ArgumentOutOfRangeError;
	        }
	    }
	    TakeLastOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new TakeLastSubscriber(subscriber, this.total));
	    };
	    return TakeLastOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var TakeLastSubscriber = (function (_super) {
	    __extends$108(TakeLastSubscriber, _super);
	    function TakeLastSubscriber(destination, total) {
	        _super.call(this, destination);
	        this.total = total;
	        this.ring = new Array();
	        this.count = 0;
	    }
	    TakeLastSubscriber.prototype._next = function (value) {
	        var ring = this.ring;
	        var total = this.total;
	        var count = this.count++;
	        if (ring.length < total) {
	            ring.push(value);
	        }
	        else {
	            var index = count % total;
	            ring[index] = value;
	        }
	    };
	    TakeLastSubscriber.prototype._complete = function () {
	        var destination = this.destination;
	        var count = this.count;
	        if (count > 0) {
	            var total = this.count >= this.total ? this.total : this.count;
	            var ring = this.ring;
	            for (var i = 0; i < total; i++) {
	                var idx = (count++) % total;
	                destination.next(ring[idx]);
	            }
	        }
	        destination.complete();
	    };
	    return TakeLastSubscriber;
	}(Subscriber_1$48.Subscriber));


	var takeLast_1$1 = {
		takeLast: takeLast_2
	};

	var Observable_1$146 = Observable_1$2;
	var takeLast_1 = takeLast_1$1;
	Observable_1$146.Observable.prototype.takeLast = takeLast_1.takeLast;

	var __extends$109 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var OuterSubscriber_1$32 = OuterSubscriber_1$1;
	var subscribeToResult_1$32 = subscribeToResult_1$1;
	/**
	 * Emits the values emitted by the source Observable until a `notifier`
	 * Observable emits a value.
	 *
	 * <span class="informal">Lets values pass until a second Observable,
	 * `notifier`, emits something. Then, it completes.</span>
	 *
	 * <img src="./img/takeUntil.png" width="100%">
	 *
	 * `takeUntil` subscribes and begins mirroring the source Observable. It also
	 * monitors a second Observable, `notifier` that you provide. If the `notifier`
	 * emits a value or a complete notification, the output Observable stops
	 * mirroring the source Observable and completes.
	 *
	 * @example <caption>Tick every second until the first click happens</caption>
	 * var interval = Rx.Observable.interval(1000);
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = interval.takeUntil(clicks);
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link take}
	 * @see {@link takeLast}
	 * @see {@link takeWhile}
	 * @see {@link skip}
	 *
	 * @param {Observable} notifier The Observable whose first emitted value will
	 * cause the output Observable of `takeUntil` to stop emitting values from the
	 * source Observable.
	 * @return {Observable<T>} An Observable that emits the values from the source
	 * Observable until such time as `notifier` emits its first value.
	 * @method takeUntil
	 * @owner Observable
	 */
	function takeUntil$2(notifier) {
	    return this.lift(new TakeUntilOperator(notifier));
	}
	var takeUntil_2 = takeUntil$2;
	var TakeUntilOperator = (function () {
	    function TakeUntilOperator(notifier) {
	        this.notifier = notifier;
	    }
	    TakeUntilOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new TakeUntilSubscriber(subscriber, this.notifier));
	    };
	    return TakeUntilOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var TakeUntilSubscriber = (function (_super) {
	    __extends$109(TakeUntilSubscriber, _super);
	    function TakeUntilSubscriber(destination, notifier) {
	        _super.call(this, destination);
	        this.notifier = notifier;
	        this.add(subscribeToResult_1$32.subscribeToResult(this, notifier));
	    }
	    TakeUntilSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        this.complete();
	    };
	    TakeUntilSubscriber.prototype.notifyComplete = function () {
	        // noop
	    };
	    return TakeUntilSubscriber;
	}(OuterSubscriber_1$32.OuterSubscriber));


	var takeUntil_1$1 = {
		takeUntil: takeUntil_2
	};

	var Observable_1$147 = Observable_1$2;
	var takeUntil_1 = takeUntil_1$1;
	Observable_1$147.Observable.prototype.takeUntil = takeUntil_1.takeUntil;

	var __extends$110 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1$49 = Subscriber_1$3;
	/**
	 * Emits values emitted by the source Observable so long as each value satisfies
	 * the given `predicate`, and then completes as soon as this `predicate` is not
	 * satisfied.
	 *
	 * <span class="informal">Takes values from the source only while they pass the
	 * condition given. When the first value does not satisfy, it completes.</span>
	 *
	 * <img src="./img/takeWhile.png" width="100%">
	 *
	 * `takeWhile` subscribes and begins mirroring the source Observable. Each value
	 * emitted on the source is given to the `predicate` function which returns a
	 * boolean, representing a condition to be satisfied by the source values. The
	 * output Observable emits the source values until such time as the `predicate`
	 * returns false, at which point `takeWhile` stops mirroring the source
	 * Observable and completes the output Observable.
	 *
	 * @example <caption>Emit click events only while the clientX property is greater than 200</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = clicks.takeWhile(ev => ev.clientX > 200);
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link take}
	 * @see {@link takeLast}
	 * @see {@link takeUntil}
	 * @see {@link skip}
	 *
	 * @param {function(value: T, index: number): boolean} predicate A function that
	 * evaluates a value emitted by the source Observable and returns a boolean.
	 * Also takes the (zero-based) index as the second argument.
	 * @return {Observable<T>} An Observable that emits the values from the source
	 * Observable so long as each value satisfies the condition defined by the
	 * `predicate`, then completes.
	 * @method takeWhile
	 * @owner Observable
	 */
	function takeWhile$3(predicate) {
	    return this.lift(new TakeWhileOperator(predicate));
	}
	var takeWhile_2 = takeWhile$3;
	var TakeWhileOperator = (function () {
	    function TakeWhileOperator(predicate) {
	        this.predicate = predicate;
	    }
	    TakeWhileOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new TakeWhileSubscriber(subscriber, this.predicate));
	    };
	    return TakeWhileOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var TakeWhileSubscriber = (function (_super) {
	    __extends$110(TakeWhileSubscriber, _super);
	    function TakeWhileSubscriber(destination, predicate) {
	        _super.call(this, destination);
	        this.predicate = predicate;
	        this.index = 0;
	    }
	    TakeWhileSubscriber.prototype._next = function (value) {
	        var destination = this.destination;
	        var result;
	        try {
	            result = this.predicate(value, this.index++);
	        }
	        catch (err) {
	            destination.error(err);
	            return;
	        }
	        this.nextOrComplete(value, result);
	    };
	    TakeWhileSubscriber.prototype.nextOrComplete = function (value, predicateResult) {
	        var destination = this.destination;
	        if (Boolean(predicateResult)) {
	            destination.next(value);
	        }
	        else {
	            destination.complete();
	        }
	    };
	    return TakeWhileSubscriber;
	}(Subscriber_1$49.Subscriber));


	var takeWhile_1$2 = {
		takeWhile: takeWhile_2
	};

	var Observable_1$148 = Observable_1$2;
	var takeWhile_1$1 = takeWhile_1$2;
	Observable_1$148.Observable.prototype.takeWhile = takeWhile_1$1.takeWhile;

	var throttle_1$2 = createCommonjsModule(function (module, exports) {
	"use strict";
	var __extends = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var OuterSubscriber_1 = OuterSubscriber_1$1;
	var subscribeToResult_1 = subscribeToResult_1$1;
	exports.defaultThrottleConfig = {
	    leading: true,
	    trailing: false
	};
	/**
	 * Emits a value from the source Observable, then ignores subsequent source
	 * values for a duration determined by another Observable, then repeats this
	 * process.
	 *
	 * <span class="informal">It's like {@link throttleTime}, but the silencing
	 * duration is determined by a second Observable.</span>
	 *
	 * <img src="./img/throttle.png" width="100%">
	 *
	 * `throttle` emits the source Observable values on the output Observable
	 * when its internal timer is disabled, and ignores source values when the timer
	 * is enabled. Initially, the timer is disabled. As soon as the first source
	 * value arrives, it is forwarded to the output Observable, and then the timer
	 * is enabled by calling the `durationSelector` function with the source value,
	 * which returns the "duration" Observable. When the duration Observable emits a
	 * value or completes, the timer is disabled, and this process repeats for the
	 * next source value.
	 *
	 * @example <caption>Emit clicks at a rate of at most one click per second</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = clicks.throttle(ev => Rx.Observable.interval(1000));
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link audit}
	 * @see {@link debounce}
	 * @see {@link delayWhen}
	 * @see {@link sample}
	 * @see {@link throttleTime}
	 *
	 * @param {function(value: T): SubscribableOrPromise} durationSelector A function
	 * that receives a value from the source Observable, for computing the silencing
	 * duration for each source value, returned as an Observable or a Promise.
	 * @param {Object} config a configuration object to define `leading` and `trailing` behavior. Defaults
	 * to `{ leading: true, trailing: false }`.
	 * @return {Observable<T>} An Observable that performs the throttle operation to
	 * limit the rate of emissions from the source.
	 * @method throttle
	 * @owner Observable
	 */
	function throttle(durationSelector, config) {
	    if (config === void 0) { config = exports.defaultThrottleConfig; }
	    return this.lift(new ThrottleOperator(durationSelector, config.leading, config.trailing));
	}
	exports.throttle = throttle;
	var ThrottleOperator = (function () {
	    function ThrottleOperator(durationSelector, leading, trailing) {
	        this.durationSelector = durationSelector;
	        this.leading = leading;
	        this.trailing = trailing;
	    }
	    ThrottleOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new ThrottleSubscriber(subscriber, this.durationSelector, this.leading, this.trailing));
	    };
	    return ThrottleOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc
	 * @ignore
	 * @extends {Ignored}
	 */
	var ThrottleSubscriber = (function (_super) {
	    __extends(ThrottleSubscriber, _super);
	    function ThrottleSubscriber(destination, durationSelector, _leading, _trailing) {
	        _super.call(this, destination);
	        this.destination = destination;
	        this.durationSelector = durationSelector;
	        this._leading = _leading;
	        this._trailing = _trailing;
	        this._hasTrailingValue = false;
	    }
	    ThrottleSubscriber.prototype._next = function (value) {
	        if (this.throttled) {
	            if (this._trailing) {
	                this._hasTrailingValue = true;
	                this._trailingValue = value;
	            }
	        }
	        else {
	            var duration = this.tryDurationSelector(value);
	            if (duration) {
	                this.add(this.throttled = subscribeToResult_1.subscribeToResult(this, duration));
	            }
	            if (this._leading) {
	                this.destination.next(value);
	                if (this._trailing) {
	                    this._hasTrailingValue = true;
	                    this._trailingValue = value;
	                }
	            }
	        }
	    };
	    ThrottleSubscriber.prototype.tryDurationSelector = function (value) {
	        try {
	            return this.durationSelector(value);
	        }
	        catch (err) {
	            this.destination.error(err);
	            return null;
	        }
	    };
	    ThrottleSubscriber.prototype._unsubscribe = function () {
	        var _a = this, throttled = _a.throttled, _trailingValue = _a._trailingValue, _hasTrailingValue = _a._hasTrailingValue, _trailing = _a._trailing;
	        this._trailingValue = null;
	        this._hasTrailingValue = false;
	        if (throttled) {
	            this.remove(throttled);
	            this.throttled = null;
	            throttled.unsubscribe();
	        }
	    };
	    ThrottleSubscriber.prototype._sendTrailing = function () {
	        var _a = this, destination = _a.destination, throttled = _a.throttled, _trailing = _a._trailing, _trailingValue = _a._trailingValue, _hasTrailingValue = _a._hasTrailingValue;
	        if (throttled && _trailing && _hasTrailingValue) {
	            destination.next(_trailingValue);
	            this._trailingValue = null;
	            this._hasTrailingValue = false;
	        }
	    };
	    ThrottleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        this._sendTrailing();
	        this._unsubscribe();
	    };
	    ThrottleSubscriber.prototype.notifyComplete = function () {
	        this._sendTrailing();
	        this._unsubscribe();
	    };
	    return ThrottleSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));

	});

	var Observable_1$149 = Observable_1$2;
	var throttle_1$1 = throttle_1$2;
	Observable_1$149.Observable.prototype.throttle = throttle_1$1.throttle;

	var __extends$111 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1$50 = Subscriber_1$3;
	var async_1$9 = async;
	var throttle_1$4 = throttle_1$2;
	/**
	 * Emits a value from the source Observable, then ignores subsequent source
	 * values for `duration` milliseconds, then repeats this process.
	 *
	 * <span class="informal">Lets a value pass, then ignores source values for the
	 * next `duration` milliseconds.</span>
	 *
	 * <img src="./img/throttleTime.png" width="100%">
	 *
	 * `throttleTime` emits the source Observable values on the output Observable
	 * when its internal timer is disabled, and ignores source values when the timer
	 * is enabled. Initially, the timer is disabled. As soon as the first source
	 * value arrives, it is forwarded to the output Observable, and then the timer
	 * is enabled. After `duration` milliseconds (or the time unit determined
	 * internally by the optional `scheduler`) has passed, the timer is disabled,
	 * and this process repeats for the next source value. Optionally takes a
	 * {@link IScheduler} for managing timers.
	 *
	 * @example <caption>Emit clicks at a rate of at most one click per second</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = clicks.throttleTime(1000);
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link auditTime}
	 * @see {@link debounceTime}
	 * @see {@link delay}
	 * @see {@link sampleTime}
	 * @see {@link throttle}
	 *
	 * @param {number} duration Time to wait before emitting another value after
	 * emitting the last value, measured in milliseconds or the time unit determined
	 * internally by the optional `scheduler`.
	 * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for
	 * managing the timers that handle the sampling.
	 * @return {Observable<T>} An Observable that performs the throttle operation to
	 * limit the rate of emissions from the source.
	 * @method throttleTime
	 * @owner Observable
	 */
	function throttleTime$2(duration, scheduler, config) {
	    if (scheduler === void 0) { scheduler = async_1$9.async; }
	    if (config === void 0) { config = throttle_1$4.defaultThrottleConfig; }
	    return this.lift(new ThrottleTimeOperator(duration, scheduler, config.leading, config.trailing));
	}
	var throttleTime_2 = throttleTime$2;
	var ThrottleTimeOperator = (function () {
	    function ThrottleTimeOperator(duration, scheduler, leading, trailing) {
	        this.duration = duration;
	        this.scheduler = scheduler;
	        this.leading = leading;
	        this.trailing = trailing;
	    }
	    ThrottleTimeOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new ThrottleTimeSubscriber(subscriber, this.duration, this.scheduler, this.leading, this.trailing));
	    };
	    return ThrottleTimeOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var ThrottleTimeSubscriber = (function (_super) {
	    __extends$111(ThrottleTimeSubscriber, _super);
	    function ThrottleTimeSubscriber(destination, duration, scheduler, leading, trailing) {
	        _super.call(this, destination);
	        this.duration = duration;
	        this.scheduler = scheduler;
	        this.leading = leading;
	        this.trailing = trailing;
	        this._hasTrailingValue = false;
	        this._trailingValue = null;
	    }
	    ThrottleTimeSubscriber.prototype._next = function (value) {
	        if (this.throttled) {
	            if (this.trailing) {
	                this._trailingValue = value;
	                this._hasTrailingValue = true;
	            }
	        }
	        else {
	            this.add(this.throttled = this.scheduler.schedule(dispatchNext$5, this.duration, { subscriber: this }));
	            if (this.leading) {
	                this.destination.next(value);
	            }
	        }
	    };
	    ThrottleTimeSubscriber.prototype.clearThrottle = function () {
	        var throttled = this.throttled;
	        if (throttled) {
	            if (this.trailing && this._hasTrailingValue) {
	                this.destination.next(this._trailingValue);
	                this._trailingValue = null;
	                this._hasTrailingValue = false;
	            }
	            throttled.unsubscribe();
	            this.remove(throttled);
	            this.throttled = null;
	        }
	    };
	    return ThrottleTimeSubscriber;
	}(Subscriber_1$50.Subscriber));
	function dispatchNext$5(arg) {
	    var subscriber = arg.subscriber;
	    subscriber.clearThrottle();
	}


	var throttleTime_1$1 = {
		throttleTime: throttleTime_2
	};

	var Observable_1$150 = Observable_1$2;
	var throttleTime_1 = throttleTime_1$1;
	Observable_1$150.Observable.prototype.throttleTime = throttleTime_1.throttleTime;

	var __extends$112 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1$51 = Subscriber_1$3;
	var async_1$10 = async;
	/**
	 * @param scheduler
	 * @return {Observable<TimeInterval<any>>|WebSocketSubject<T>|Observable<T>}
	 * @method timeInterval
	 * @owner Observable
	 */
	function timeInterval$2(scheduler) {
	    if (scheduler === void 0) { scheduler = async_1$10.async; }
	    return this.lift(new TimeIntervalOperator(scheduler));
	}
	var timeInterval_2 = timeInterval$2;
	var TimeInterval$1 = (function () {
	    function TimeInterval(value, interval) {
	        this.value = value;
	        this.interval = interval;
	    }
	    return TimeInterval;
	}());
	var TimeInterval_1 = TimeInterval$1;

	var TimeIntervalOperator = (function () {
	    function TimeIntervalOperator(scheduler) {
	        this.scheduler = scheduler;
	    }
	    TimeIntervalOperator.prototype.call = function (observer, source) {
	        return source.subscribe(new TimeIntervalSubscriber(observer, this.scheduler));
	    };
	    return TimeIntervalOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var TimeIntervalSubscriber = (function (_super) {
	    __extends$112(TimeIntervalSubscriber, _super);
	    function TimeIntervalSubscriber(destination, scheduler) {
	        _super.call(this, destination);
	        this.scheduler = scheduler;
	        this.lastTime = 0;
	        this.lastTime = scheduler.now();
	    }
	    TimeIntervalSubscriber.prototype._next = function (value) {
	        var now = this.scheduler.now();
	        var span = now - this.lastTime;
	        this.lastTime = now;
	        this.destination.next(new TimeInterval$1(value, span));
	    };
	    return TimeIntervalSubscriber;
	}(Subscriber_1$51.Subscriber));


	var timeInterval_1$2 = {
		timeInterval: timeInterval_2,
		TimeInterval: TimeInterval_1
	};

	var Observable_1$151 = Observable_1$2;
	var timeInterval_1$1 = timeInterval_1$2;
	Observable_1$151.Observable.prototype.timeInterval = timeInterval_1$1.timeInterval;

	var __extends$114 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/**
	 * An error thrown when duetime elapses.
	 *
	 * @see {@link timeout}
	 *
	 * @class TimeoutError
	 */
	var TimeoutError$1 = (function (_super) {
	    __extends$114(TimeoutError, _super);
	    function TimeoutError() {
	        var err = _super.call(this, 'Timeout has occurred');
	        this.name = err.name = 'TimeoutError';
	        this.stack = err.stack;
	        this.message = err.message;
	    }
	    return TimeoutError;
	}(Error));
	var TimeoutError_2 = TimeoutError$1;


	var TimeoutError_1$2 = {
		TimeoutError: TimeoutError_2
	};

	var __extends$113 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var async_1$11 = async;
	var isDate_1$5 = isDate_1$2;
	var Subscriber_1$52 = Subscriber_1$3;
	var TimeoutError_1$1 = TimeoutError_1$2;
	/**
	 * @param {number} due
	 * @param {Scheduler} [scheduler]
	 * @return {Observable<R>|WebSocketSubject<T>|Observable<T>}
	 * @method timeout
	 * @owner Observable
	 */
	function timeout$2(due, scheduler) {
	    if (scheduler === void 0) { scheduler = async_1$11.async; }
	    var absoluteTimeout = isDate_1$5.isDate(due);
	    var waitFor = absoluteTimeout ? (+due - scheduler.now()) : Math.abs(due);
	    return this.lift(new TimeoutOperator(waitFor, absoluteTimeout, scheduler, new TimeoutError_1$1.TimeoutError()));
	}
	var timeout_2 = timeout$2;
	var TimeoutOperator = (function () {
	    function TimeoutOperator(waitFor, absoluteTimeout, scheduler, errorInstance) {
	        this.waitFor = waitFor;
	        this.absoluteTimeout = absoluteTimeout;
	        this.scheduler = scheduler;
	        this.errorInstance = errorInstance;
	    }
	    TimeoutOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new TimeoutSubscriber(subscriber, this.absoluteTimeout, this.waitFor, this.scheduler, this.errorInstance));
	    };
	    return TimeoutOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var TimeoutSubscriber = (function (_super) {
	    __extends$113(TimeoutSubscriber, _super);
	    function TimeoutSubscriber(destination, absoluteTimeout, waitFor, scheduler, errorInstance) {
	        _super.call(this, destination);
	        this.absoluteTimeout = absoluteTimeout;
	        this.waitFor = waitFor;
	        this.scheduler = scheduler;
	        this.errorInstance = errorInstance;
	        this.action = null;
	        this.scheduleTimeout();
	    }
	    TimeoutSubscriber.dispatchTimeout = function (subscriber) {
	        subscriber.error(subscriber.errorInstance);
	    };
	    TimeoutSubscriber.prototype.scheduleTimeout = function () {
	        var action = this.action;
	        if (action) {
	            // Recycle the action if we've already scheduled one. All the production
	            // Scheduler Actions mutate their state/delay time and return themeselves.
	            // VirtualActions are immutable, so they create and return a clone. In this
	            // case, we need to set the action reference to the most recent VirtualAction,
	            // to ensure that's the one we clone from next time.
	            this.action = action.schedule(this, this.waitFor);
	        }
	        else {
	            this.add(this.action = this.scheduler.schedule(TimeoutSubscriber.dispatchTimeout, this.waitFor, this));
	        }
	    };
	    TimeoutSubscriber.prototype._next = function (value) {
	        if (!this.absoluteTimeout) {
	            this.scheduleTimeout();
	        }
	        _super.prototype._next.call(this, value);
	    };
	    TimeoutSubscriber.prototype._unsubscribe = function () {
	        this.action = null;
	        this.scheduler = null;
	        this.errorInstance = null;
	    };
	    return TimeoutSubscriber;
	}(Subscriber_1$52.Subscriber));


	var timeout_1$1 = {
		timeout: timeout_2
	};

	var Observable_1$152 = Observable_1$2;
	var timeout_1 = timeout_1$1;
	Observable_1$152.Observable.prototype.timeout = timeout_1.timeout;

	var __extends$115 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var async_1$12 = async;
	var isDate_1$6 = isDate_1$2;
	var OuterSubscriber_1$33 = OuterSubscriber_1$1;
	var subscribeToResult_1$33 = subscribeToResult_1$1;
	/* tslint:enable:max-line-length */
	/**
	 * @param due
	 * @param withObservable
	 * @param scheduler
	 * @return {Observable<R>|WebSocketSubject<T>|Observable<T>}
	 * @method timeoutWith
	 * @owner Observable
	 */
	function timeoutWith$2(due, withObservable, scheduler) {
	    if (scheduler === void 0) { scheduler = async_1$12.async; }
	    var absoluteTimeout = isDate_1$6.isDate(due);
	    var waitFor = absoluteTimeout ? (+due - scheduler.now()) : Math.abs(due);
	    return this.lift(new TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler));
	}
	var timeoutWith_2 = timeoutWith$2;
	var TimeoutWithOperator = (function () {
	    function TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler) {
	        this.waitFor = waitFor;
	        this.absoluteTimeout = absoluteTimeout;
	        this.withObservable = withObservable;
	        this.scheduler = scheduler;
	    }
	    TimeoutWithOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new TimeoutWithSubscriber(subscriber, this.absoluteTimeout, this.waitFor, this.withObservable, this.scheduler));
	    };
	    return TimeoutWithOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var TimeoutWithSubscriber = (function (_super) {
	    __extends$115(TimeoutWithSubscriber, _super);
	    function TimeoutWithSubscriber(destination, absoluteTimeout, waitFor, withObservable, scheduler) {
	        _super.call(this, destination);
	        this.absoluteTimeout = absoluteTimeout;
	        this.waitFor = waitFor;
	        this.withObservable = withObservable;
	        this.scheduler = scheduler;
	        this.action = null;
	        this.scheduleTimeout();
	    }
	    TimeoutWithSubscriber.dispatchTimeout = function (subscriber) {
	        var withObservable = subscriber.withObservable;
	        subscriber._unsubscribeAndRecycle();
	        subscriber.add(subscribeToResult_1$33.subscribeToResult(subscriber, withObservable));
	    };
	    TimeoutWithSubscriber.prototype.scheduleTimeout = function () {
	        var action = this.action;
	        if (action) {
	            // Recycle the action if we've already scheduled one. All the production
	            // Scheduler Actions mutate their state/delay time and return themeselves.
	            // VirtualActions are immutable, so they create and return a clone. In this
	            // case, we need to set the action reference to the most recent VirtualAction,
	            // to ensure that's the one we clone from next time.
	            this.action = action.schedule(this, this.waitFor);
	        }
	        else {
	            this.add(this.action = this.scheduler.schedule(TimeoutWithSubscriber.dispatchTimeout, this.waitFor, this));
	        }
	    };
	    TimeoutWithSubscriber.prototype._next = function (value) {
	        if (!this.absoluteTimeout) {
	            this.scheduleTimeout();
	        }
	        _super.prototype._next.call(this, value);
	    };
	    TimeoutWithSubscriber.prototype._unsubscribe = function () {
	        this.action = null;
	        this.scheduler = null;
	        this.withObservable = null;
	    };
	    return TimeoutWithSubscriber;
	}(OuterSubscriber_1$33.OuterSubscriber));


	var timeoutWith_1$1 = {
		timeoutWith: timeoutWith_2
	};

	var Observable_1$153 = Observable_1$2;
	var timeoutWith_1 = timeoutWith_1$1;
	Observable_1$153.Observable.prototype.timeoutWith = timeoutWith_1.timeoutWith;

	var __extends$116 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1$53 = Subscriber_1$3;
	var async_1$13 = async;
	/**
	 * @param scheduler
	 * @return {Observable<Timestamp<any>>|WebSocketSubject<T>|Observable<T>}
	 * @method timestamp
	 * @owner Observable
	 */
	function timestamp$2(scheduler) {
	    if (scheduler === void 0) { scheduler = async_1$13.async; }
	    return this.lift(new TimestampOperator(scheduler));
	}
	var timestamp_2 = timestamp$2;
	var Timestamp$1 = (function () {
	    function Timestamp(value, timestamp) {
	        this.value = value;
	        this.timestamp = timestamp;
	    }
	    return Timestamp;
	}());
	var Timestamp_1 = Timestamp$1;

	var TimestampOperator = (function () {
	    function TimestampOperator(scheduler) {
	        this.scheduler = scheduler;
	    }
	    TimestampOperator.prototype.call = function (observer, source) {
	        return source.subscribe(new TimestampSubscriber(observer, this.scheduler));
	    };
	    return TimestampOperator;
	}());
	var TimestampSubscriber = (function (_super) {
	    __extends$116(TimestampSubscriber, _super);
	    function TimestampSubscriber(destination, scheduler) {
	        _super.call(this, destination);
	        this.scheduler = scheduler;
	    }
	    TimestampSubscriber.prototype._next = function (value) {
	        var now = this.scheduler.now();
	        this.destination.next(new Timestamp$1(value, now));
	    };
	    return TimestampSubscriber;
	}(Subscriber_1$53.Subscriber));


	var timestamp_1$2 = {
		timestamp: timestamp_2,
		Timestamp: Timestamp_1
	};

	var Observable_1$154 = Observable_1$2;
	var timestamp_1$1 = timestamp_1$2;
	Observable_1$154.Observable.prototype.timestamp = timestamp_1$1.timestamp;

	var __extends$117 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1$54 = Subscriber_1$3;
	/**
	 * @return {Observable<any[]>|WebSocketSubject<T>|Observable<T>}
	 * @method toArray
	 * @owner Observable
	 */
	function toArray$3() {
	    return this.lift(new ToArrayOperator());
	}
	var toArray_2 = toArray$3;
	var ToArrayOperator = (function () {
	    function ToArrayOperator() {
	    }
	    ToArrayOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new ToArraySubscriber(subscriber));
	    };
	    return ToArrayOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var ToArraySubscriber = (function (_super) {
	    __extends$117(ToArraySubscriber, _super);
	    function ToArraySubscriber(destination) {
	        _super.call(this, destination);
	        this.array = [];
	    }
	    ToArraySubscriber.prototype._next = function (x) {
	        this.array.push(x);
	    };
	    ToArraySubscriber.prototype._complete = function () {
	        this.destination.next(this.array);
	        this.destination.complete();
	    };
	    return ToArraySubscriber;
	}(Subscriber_1$54.Subscriber));


	var toArray_1$2 = {
		toArray: toArray_2
	};

	var Observable_1$155 = Observable_1$2;
	var toArray_1$1 = toArray_1$2;
	Observable_1$155.Observable.prototype.toArray = toArray_1$1.toArray;

	var root_1$12 = root$1;
	/* tslint:enable:max-line-length */
	/**
	 * Converts an Observable sequence to a ES2015 compliant promise.
	 *
	 * @example
	 * // Using normal ES2015
	 * let source = Rx.Observable
	 *   .of(42)
	 *   .toPromise();
	 *
	 * source.then((value) => console.log('Value: %s', value));
	 * // => Value: 42
	 *
	 * // Rejected Promise
	 * // Using normal ES2015
	 * let source = Rx.Observable
	 *   .throw(new Error('woops'))
	 *   .toPromise();
	 *
	 * source
	 *   .then((value) => console.log('Value: %s', value))
	 *   .catch((err) => console.log('Error: %s', err));
	 * // => Error: Error: woops
	 *
	 * // Setting via the config
	 * Rx.config.Promise = RSVP.Promise;
	 *
	 * let source = Rx.Observable
	 *   .of(42)
	 *   .toPromise();
	 *
	 * source.then((value) => console.log('Value: %s', value));
	 * // => Value: 42
	 *
	 * // Setting via the method
	 * let source = Rx.Observable
	 *   .of(42)
	 *   .toPromise(RSVP.Promise);
	 *
	 * source.then((value) => console.log('Value: %s', value));
	 * // => Value: 42
	 *
	 * @param PromiseCtor promise The constructor of the promise. If not provided,
	 * it will look for a constructor first in Rx.config.Promise then fall back to
	 * the native Promise constructor if available.
	 * @return {Promise<T>} An ES2015 compatible promise with the last value from
	 * the observable sequence.
	 * @method toPromise
	 * @owner Observable
	 */
	function toPromise$2(PromiseCtor) {
	    var _this = this;
	    if (!PromiseCtor) {
	        if (root_1$12.root.Rx && root_1$12.root.Rx.config && root_1$12.root.Rx.config.Promise) {
	            PromiseCtor = root_1$12.root.Rx.config.Promise;
	        }
	        else if (root_1$12.root.Promise) {
	            PromiseCtor = root_1$12.root.Promise;
	        }
	    }
	    if (!PromiseCtor) {
	        throw new Error('no Promise impl found');
	    }
	    return new PromiseCtor(function (resolve, reject) {
	        var value;
	        _this.subscribe(function (x) { return value = x; }, function (err) { return reject(err); }, function () { return resolve(value); });
	    });
	}
	var toPromise_2 = toPromise$2;


	var toPromise_1$1 = {
		toPromise: toPromise_2
	};

	var Observable_1$156 = Observable_1$2;
	var toPromise_1 = toPromise_1$1;
	Observable_1$156.Observable.prototype.toPromise = toPromise_1.toPromise;

	var __extends$118 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subject_1$13 = Subject_1$1;
	var OuterSubscriber_1$34 = OuterSubscriber_1$1;
	var subscribeToResult_1$34 = subscribeToResult_1$1;
	/**
	 * Branch out the source Observable values as a nested Observable whenever
	 * `windowBoundaries` emits.
	 *
	 * <span class="informal">It's like {@link buffer}, but emits a nested Observable
	 * instead of an array.</span>
	 *
	 * <img src="./img/window.png" width="100%">
	 *
	 * Returns an Observable that emits windows of items it collects from the source
	 * Observable. The output Observable emits connected, non-overlapping
	 * windows. It emits the current window and opens a new one whenever the
	 * Observable `windowBoundaries` emits an item. Because each window is an
	 * Observable, the output is a higher-order Observable.
	 *
	 * @example <caption>In every window of 1 second each, emit at most 2 click events</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var interval = Rx.Observable.interval(1000);
	 * var result = clicks.window(interval)
	 *   .map(win => win.take(2)) // each window has at most 2 emissions
	 *   .mergeAll(); // flatten the Observable-of-Observables
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link windowCount}
	 * @see {@link windowTime}
	 * @see {@link windowToggle}
	 * @see {@link windowWhen}
	 * @see {@link buffer}
	 *
	 * @param {Observable<any>} windowBoundaries An Observable that completes the
	 * previous window and starts a new window.
	 * @return {Observable<Observable<T>>} An Observable of windows, which are
	 * Observables emitting values of the source Observable.
	 * @method window
	 * @owner Observable
	 */
	function window$3(windowBoundaries) {
	    return this.lift(new WindowOperator(windowBoundaries));
	}
	var window_2 = window$3;
	var WindowOperator = (function () {
	    function WindowOperator(windowBoundaries) {
	        this.windowBoundaries = windowBoundaries;
	    }
	    WindowOperator.prototype.call = function (subscriber, source) {
	        var windowSubscriber = new WindowSubscriber(subscriber);
	        var sourceSubscription = source.subscribe(windowSubscriber);
	        if (!sourceSubscription.closed) {
	            windowSubscriber.add(subscribeToResult_1$34.subscribeToResult(windowSubscriber, this.windowBoundaries));
	        }
	        return sourceSubscription;
	    };
	    return WindowOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var WindowSubscriber = (function (_super) {
	    __extends$118(WindowSubscriber, _super);
	    function WindowSubscriber(destination) {
	        _super.call(this, destination);
	        this.window = new Subject_1$13.Subject();
	        destination.next(this.window);
	    }
	    WindowSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        this.openWindow();
	    };
	    WindowSubscriber.prototype.notifyError = function (error, innerSub) {
	        this._error(error);
	    };
	    WindowSubscriber.prototype.notifyComplete = function (innerSub) {
	        this._complete();
	    };
	    WindowSubscriber.prototype._next = function (value) {
	        this.window.next(value);
	    };
	    WindowSubscriber.prototype._error = function (err) {
	        this.window.error(err);
	        this.destination.error(err);
	    };
	    WindowSubscriber.prototype._complete = function () {
	        this.window.complete();
	        this.destination.complete();
	    };
	    WindowSubscriber.prototype._unsubscribe = function () {
	        this.window = null;
	    };
	    WindowSubscriber.prototype.openWindow = function () {
	        var prevWindow = this.window;
	        if (prevWindow) {
	            prevWindow.complete();
	        }
	        var destination = this.destination;
	        var newWindow = this.window = new Subject_1$13.Subject();
	        destination.next(newWindow);
	    };
	    return WindowSubscriber;
	}(OuterSubscriber_1$34.OuterSubscriber));


	var window_1$1 = {
		window: window_2
	};

	var Observable_1$157 = Observable_1$2;
	var window_1 = window_1$1;
	Observable_1$157.Observable.prototype.window = window_1.window;

	var __extends$119 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1$55 = Subscriber_1$3;
	var Subject_1$14 = Subject_1$1;
	/**
	 * Branch out the source Observable values as a nested Observable with each
	 * nested Observable emitting at most `windowSize` values.
	 *
	 * <span class="informal">It's like {@link bufferCount}, but emits a nested
	 * Observable instead of an array.</span>
	 *
	 * <img src="./img/windowCount.png" width="100%">
	 *
	 * Returns an Observable that emits windows of items it collects from the source
	 * Observable. The output Observable emits windows every `startWindowEvery`
	 * items, each containing no more than `windowSize` items. When the source
	 * Observable completes or encounters an error, the output Observable emits
	 * the current window and propagates the notification from the source
	 * Observable. If `startWindowEvery` is not provided, then new windows are
	 * started immediately at the start of the source and when each window completes
	 * with size `windowSize`.
	 *
	 * @example <caption>Ignore every 3rd click event, starting from the first one</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = clicks.windowCount(3)
	 *   .map(win => win.skip(1)) // skip first of every 3 clicks
	 *   .mergeAll(); // flatten the Observable-of-Observables
	 * result.subscribe(x => console.log(x));
	 *
	 * @example <caption>Ignore every 3rd click event, starting from the third one</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = clicks.windowCount(2, 3)
	 *   .mergeAll(); // flatten the Observable-of-Observables
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link window}
	 * @see {@link windowTime}
	 * @see {@link windowToggle}
	 * @see {@link windowWhen}
	 * @see {@link bufferCount}
	 *
	 * @param {number} windowSize The maximum number of values emitted by each
	 * window.
	 * @param {number} [startWindowEvery] Interval at which to start a new window.
	 * For example if `startWindowEvery` is `2`, then a new window will be started
	 * on every other value from the source. A new window is started at the
	 * beginning of the source by default.
	 * @return {Observable<Observable<T>>} An Observable of windows, which in turn
	 * are Observable of values.
	 * @method windowCount
	 * @owner Observable
	 */
	function windowCount$2(windowSize, startWindowEvery) {
	    if (startWindowEvery === void 0) { startWindowEvery = 0; }
	    return this.lift(new WindowCountOperator(windowSize, startWindowEvery));
	}
	var windowCount_2 = windowCount$2;
	var WindowCountOperator = (function () {
	    function WindowCountOperator(windowSize, startWindowEvery) {
	        this.windowSize = windowSize;
	        this.startWindowEvery = startWindowEvery;
	    }
	    WindowCountOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new WindowCountSubscriber(subscriber, this.windowSize, this.startWindowEvery));
	    };
	    return WindowCountOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var WindowCountSubscriber = (function (_super) {
	    __extends$119(WindowCountSubscriber, _super);
	    function WindowCountSubscriber(destination, windowSize, startWindowEvery) {
	        _super.call(this, destination);
	        this.destination = destination;
	        this.windowSize = windowSize;
	        this.startWindowEvery = startWindowEvery;
	        this.windows = [new Subject_1$14.Subject()];
	        this.count = 0;
	        destination.next(this.windows[0]);
	    }
	    WindowCountSubscriber.prototype._next = function (value) {
	        var startWindowEvery = (this.startWindowEvery > 0) ? this.startWindowEvery : this.windowSize;
	        var destination = this.destination;
	        var windowSize = this.windowSize;
	        var windows = this.windows;
	        var len = windows.length;
	        for (var i = 0; i < len && !this.closed; i++) {
	            windows[i].next(value);
	        }
	        var c = this.count - windowSize + 1;
	        if (c >= 0 && c % startWindowEvery === 0 && !this.closed) {
	            windows.shift().complete();
	        }
	        if (++this.count % startWindowEvery === 0 && !this.closed) {
	            var window_1 = new Subject_1$14.Subject();
	            windows.push(window_1);
	            destination.next(window_1);
	        }
	    };
	    WindowCountSubscriber.prototype._error = function (err) {
	        var windows = this.windows;
	        if (windows) {
	            while (windows.length > 0 && !this.closed) {
	                windows.shift().error(err);
	            }
	        }
	        this.destination.error(err);
	    };
	    WindowCountSubscriber.prototype._complete = function () {
	        var windows = this.windows;
	        if (windows) {
	            while (windows.length > 0 && !this.closed) {
	                windows.shift().complete();
	            }
	        }
	        this.destination.complete();
	    };
	    WindowCountSubscriber.prototype._unsubscribe = function () {
	        this.count = 0;
	        this.windows = null;
	    };
	    return WindowCountSubscriber;
	}(Subscriber_1$55.Subscriber));


	var windowCount_1$1 = {
		windowCount: windowCount_2
	};

	var Observable_1$158 = Observable_1$2;
	var windowCount_1 = windowCount_1$1;
	Observable_1$158.Observable.prototype.windowCount = windowCount_1.windowCount;

	var __extends$120 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subject_1$15 = Subject_1$1;
	var async_1$14 = async;
	var Subscriber_1$56 = Subscriber_1$3;
	var isNumeric_1$5 = isNumeric_1$1;
	var isScheduler_1$10 = isScheduler_1$1;
	function windowTime$2(windowTimeSpan) {
	    var scheduler = async_1$14.async;
	    var windowCreationInterval = null;
	    var maxWindowSize = Number.POSITIVE_INFINITY;
	    if (isScheduler_1$10.isScheduler(arguments[3])) {
	        scheduler = arguments[3];
	    }
	    if (isScheduler_1$10.isScheduler(arguments[2])) {
	        scheduler = arguments[2];
	    }
	    else if (isNumeric_1$5.isNumeric(arguments[2])) {
	        maxWindowSize = arguments[2];
	    }
	    if (isScheduler_1$10.isScheduler(arguments[1])) {
	        scheduler = arguments[1];
	    }
	    else if (isNumeric_1$5.isNumeric(arguments[1])) {
	        windowCreationInterval = arguments[1];
	    }
	    return this.lift(new WindowTimeOperator(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler));
	}
	var windowTime_2 = windowTime$2;
	var WindowTimeOperator = (function () {
	    function WindowTimeOperator(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {
	        this.windowTimeSpan = windowTimeSpan;
	        this.windowCreationInterval = windowCreationInterval;
	        this.maxWindowSize = maxWindowSize;
	        this.scheduler = scheduler;
	    }
	    WindowTimeOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new WindowTimeSubscriber(subscriber, this.windowTimeSpan, this.windowCreationInterval, this.maxWindowSize, this.scheduler));
	    };
	    return WindowTimeOperator;
	}());
	var CountedSubject = (function (_super) {
	    __extends$120(CountedSubject, _super);
	    function CountedSubject() {
	        _super.apply(this, arguments);
	        this._numberOfNextedValues = 0;
	    }
	    CountedSubject.prototype.next = function (value) {
	        this._numberOfNextedValues++;
	        _super.prototype.next.call(this, value);
	    };
	    Object.defineProperty(CountedSubject.prototype, "numberOfNextedValues", {
	        get: function () {
	            return this._numberOfNextedValues;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return CountedSubject;
	}(Subject_1$15.Subject));
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var WindowTimeSubscriber = (function (_super) {
	    __extends$120(WindowTimeSubscriber, _super);
	    function WindowTimeSubscriber(destination, windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {
	        _super.call(this, destination);
	        this.destination = destination;
	        this.windowTimeSpan = windowTimeSpan;
	        this.windowCreationInterval = windowCreationInterval;
	        this.maxWindowSize = maxWindowSize;
	        this.scheduler = scheduler;
	        this.windows = [];
	        var window = this.openWindow();
	        if (windowCreationInterval !== null && windowCreationInterval >= 0) {
	            var closeState = { subscriber: this, window: window, context: null };
	            var creationState = { windowTimeSpan: windowTimeSpan, windowCreationInterval: windowCreationInterval, subscriber: this, scheduler: scheduler };
	            this.add(scheduler.schedule(dispatchWindowClose, windowTimeSpan, closeState));
	            this.add(scheduler.schedule(dispatchWindowCreation, windowCreationInterval, creationState));
	        }
	        else {
	            var timeSpanOnlyState = { subscriber: this, window: window, windowTimeSpan: windowTimeSpan };
	            this.add(scheduler.schedule(dispatchWindowTimeSpanOnly, windowTimeSpan, timeSpanOnlyState));
	        }
	    }
	    WindowTimeSubscriber.prototype._next = function (value) {
	        var windows = this.windows;
	        var len = windows.length;
	        for (var i = 0; i < len; i++) {
	            var window_1 = windows[i];
	            if (!window_1.closed) {
	                window_1.next(value);
	                if (window_1.numberOfNextedValues >= this.maxWindowSize) {
	                    this.closeWindow(window_1);
	                }
	            }
	        }
	    };
	    WindowTimeSubscriber.prototype._error = function (err) {
	        var windows = this.windows;
	        while (windows.length > 0) {
	            windows.shift().error(err);
	        }
	        this.destination.error(err);
	    };
	    WindowTimeSubscriber.prototype._complete = function () {
	        var windows = this.windows;
	        while (windows.length > 0) {
	            var window_2 = windows.shift();
	            if (!window_2.closed) {
	                window_2.complete();
	            }
	        }
	        this.destination.complete();
	    };
	    WindowTimeSubscriber.prototype.openWindow = function () {
	        var window = new CountedSubject();
	        this.windows.push(window);
	        var destination = this.destination;
	        destination.next(window);
	        return window;
	    };
	    WindowTimeSubscriber.prototype.closeWindow = function (window) {
	        window.complete();
	        var windows = this.windows;
	        windows.splice(windows.indexOf(window), 1);
	    };
	    return WindowTimeSubscriber;
	}(Subscriber_1$56.Subscriber));
	function dispatchWindowTimeSpanOnly(state) {
	    var subscriber = state.subscriber, windowTimeSpan = state.windowTimeSpan, window = state.window;
	    if (window) {
	        subscriber.closeWindow(window);
	    }
	    state.window = subscriber.openWindow();
	    this.schedule(state, windowTimeSpan);
	}
	function dispatchWindowCreation(state) {
	    var windowTimeSpan = state.windowTimeSpan, subscriber = state.subscriber, scheduler = state.scheduler, windowCreationInterval = state.windowCreationInterval;
	    var window = subscriber.openWindow();
	    var action = this;
	    var context = { action: action, subscription: null };
	    var timeSpanState = { subscriber: subscriber, window: window, context: context };
	    context.subscription = scheduler.schedule(dispatchWindowClose, windowTimeSpan, timeSpanState);
	    action.add(context.subscription);
	    action.schedule(state, windowCreationInterval);
	}
	function dispatchWindowClose(state) {
	    var subscriber = state.subscriber, window = state.window, context = state.context;
	    if (context && context.action && context.subscription) {
	        context.action.remove(context.subscription);
	    }
	    subscriber.closeWindow(window);
	}


	var windowTime_1$1 = {
		windowTime: windowTime_2
	};

	var Observable_1$159 = Observable_1$2;
	var windowTime_1 = windowTime_1$1;
	Observable_1$159.Observable.prototype.windowTime = windowTime_1.windowTime;

	var __extends$121 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subject_1$16 = Subject_1$1;
	var Subscription_1$17 = Subscription_1$3;
	var tryCatch_1$16 = tryCatch_1$1;
	var errorObject_1$16 = errorObject;
	var OuterSubscriber_1$35 = OuterSubscriber_1$1;
	var subscribeToResult_1$35 = subscribeToResult_1$1;
	/**
	 * Branch out the source Observable values as a nested Observable starting from
	 * an emission from `openings` and ending when the output of `closingSelector`
	 * emits.
	 *
	 * <span class="informal">It's like {@link bufferToggle}, but emits a nested
	 * Observable instead of an array.</span>
	 *
	 * <img src="./img/windowToggle.png" width="100%">
	 *
	 * Returns an Observable that emits windows of items it collects from the source
	 * Observable. The output Observable emits windows that contain those items
	 * emitted by the source Observable between the time when the `openings`
	 * Observable emits an item and when the Observable returned by
	 * `closingSelector` emits an item.
	 *
	 * @example <caption>Every other second, emit the click events from the next 500ms</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var openings = Rx.Observable.interval(1000);
	 * var result = clicks.windowToggle(openings, i =>
	 *   i % 2 ? Rx.Observable.interval(500) : Rx.Observable.empty()
	 * ).mergeAll();
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link window}
	 * @see {@link windowCount}
	 * @see {@link windowTime}
	 * @see {@link windowWhen}
	 * @see {@link bufferToggle}
	 *
	 * @param {Observable<O>} openings An observable of notifications to start new
	 * windows.
	 * @param {function(value: O): Observable} closingSelector A function that takes
	 * the value emitted by the `openings` observable and returns an Observable,
	 * which, when it emits (either `next` or `complete`), signals that the
	 * associated window should complete.
	 * @return {Observable<Observable<T>>} An observable of windows, which in turn
	 * are Observables.
	 * @method windowToggle
	 * @owner Observable
	 */
	function windowToggle$2(openings, closingSelector) {
	    return this.lift(new WindowToggleOperator(openings, closingSelector));
	}
	var windowToggle_2 = windowToggle$2;
	var WindowToggleOperator = (function () {
	    function WindowToggleOperator(openings, closingSelector) {
	        this.openings = openings;
	        this.closingSelector = closingSelector;
	    }
	    WindowToggleOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new WindowToggleSubscriber(subscriber, this.openings, this.closingSelector));
	    };
	    return WindowToggleOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var WindowToggleSubscriber = (function (_super) {
	    __extends$121(WindowToggleSubscriber, _super);
	    function WindowToggleSubscriber(destination, openings, closingSelector) {
	        _super.call(this, destination);
	        this.openings = openings;
	        this.closingSelector = closingSelector;
	        this.contexts = [];
	        this.add(this.openSubscription = subscribeToResult_1$35.subscribeToResult(this, openings, openings));
	    }
	    WindowToggleSubscriber.prototype._next = function (value) {
	        var contexts = this.contexts;
	        if (contexts) {
	            var len = contexts.length;
	            for (var i = 0; i < len; i++) {
	                contexts[i].window.next(value);
	            }
	        }
	    };
	    WindowToggleSubscriber.prototype._error = function (err) {
	        var contexts = this.contexts;
	        this.contexts = null;
	        if (contexts) {
	            var len = contexts.length;
	            var index = -1;
	            while (++index < len) {
	                var context = contexts[index];
	                context.window.error(err);
	                context.subscription.unsubscribe();
	            }
	        }
	        _super.prototype._error.call(this, err);
	    };
	    WindowToggleSubscriber.prototype._complete = function () {
	        var contexts = this.contexts;
	        this.contexts = null;
	        if (contexts) {
	            var len = contexts.length;
	            var index = -1;
	            while (++index < len) {
	                var context = contexts[index];
	                context.window.complete();
	                context.subscription.unsubscribe();
	            }
	        }
	        _super.prototype._complete.call(this);
	    };
	    WindowToggleSubscriber.prototype._unsubscribe = function () {
	        var contexts = this.contexts;
	        this.contexts = null;
	        if (contexts) {
	            var len = contexts.length;
	            var index = -1;
	            while (++index < len) {
	                var context = contexts[index];
	                context.window.unsubscribe();
	                context.subscription.unsubscribe();
	            }
	        }
	    };
	    WindowToggleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        if (outerValue === this.openings) {
	            var closingSelector = this.closingSelector;
	            var closingNotifier = tryCatch_1$16.tryCatch(closingSelector)(innerValue);
	            if (closingNotifier === errorObject_1$16.errorObject) {
	                return this.error(errorObject_1$16.errorObject.e);
	            }
	            else {
	                var window_1 = new Subject_1$16.Subject();
	                var subscription = new Subscription_1$17.Subscription();
	                var context = { window: window_1, subscription: subscription };
	                this.contexts.push(context);
	                var innerSubscription = subscribeToResult_1$35.subscribeToResult(this, closingNotifier, context);
	                if (innerSubscription.closed) {
	                    this.closeWindow(this.contexts.length - 1);
	                }
	                else {
	                    innerSubscription.context = context;
	                    subscription.add(innerSubscription);
	                }
	                this.destination.next(window_1);
	            }
	        }
	        else {
	            this.closeWindow(this.contexts.indexOf(outerValue));
	        }
	    };
	    WindowToggleSubscriber.prototype.notifyError = function (err) {
	        this.error(err);
	    };
	    WindowToggleSubscriber.prototype.notifyComplete = function (inner) {
	        if (inner !== this.openSubscription) {
	            this.closeWindow(this.contexts.indexOf(inner.context));
	        }
	    };
	    WindowToggleSubscriber.prototype.closeWindow = function (index) {
	        if (index === -1) {
	            return;
	        }
	        var contexts = this.contexts;
	        var context = contexts[index];
	        var window = context.window, subscription = context.subscription;
	        contexts.splice(index, 1);
	        window.complete();
	        subscription.unsubscribe();
	    };
	    return WindowToggleSubscriber;
	}(OuterSubscriber_1$35.OuterSubscriber));


	var windowToggle_1$1 = {
		windowToggle: windowToggle_2
	};

	var Observable_1$160 = Observable_1$2;
	var windowToggle_1 = windowToggle_1$1;
	Observable_1$160.Observable.prototype.windowToggle = windowToggle_1.windowToggle;

	var __extends$122 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subject_1$17 = Subject_1$1;
	var tryCatch_1$17 = tryCatch_1$1;
	var errorObject_1$17 = errorObject;
	var OuterSubscriber_1$36 = OuterSubscriber_1$1;
	var subscribeToResult_1$36 = subscribeToResult_1$1;
	/**
	 * Branch out the source Observable values as a nested Observable using a
	 * factory function of closing Observables to determine when to start a new
	 * window.
	 *
	 * <span class="informal">It's like {@link bufferWhen}, but emits a nested
	 * Observable instead of an array.</span>
	 *
	 * <img src="./img/windowWhen.png" width="100%">
	 *
	 * Returns an Observable that emits windows of items it collects from the source
	 * Observable. The output Observable emits connected, non-overlapping windows.
	 * It emits the current window and opens a new one whenever the Observable
	 * produced by the specified `closingSelector` function emits an item. The first
	 * window is opened immediately when subscribing to the output Observable.
	 *
	 * @example <caption>Emit only the first two clicks events in every window of [1-5] random seconds</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = clicks
	 *   .windowWhen(() => Rx.Observable.interval(1000 + Math.random() * 4000))
	 *   .map(win => win.take(2)) // each window has at most 2 emissions
	 *   .mergeAll(); // flatten the Observable-of-Observables
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link window}
	 * @see {@link windowCount}
	 * @see {@link windowTime}
	 * @see {@link windowToggle}
	 * @see {@link bufferWhen}
	 *
	 * @param {function(): Observable} closingSelector A function that takes no
	 * arguments and returns an Observable that signals (on either `next` or
	 * `complete`) when to close the previous window and start a new one.
	 * @return {Observable<Observable<T>>} An observable of windows, which in turn
	 * are Observables.
	 * @method windowWhen
	 * @owner Observable
	 */
	function windowWhen$2(closingSelector) {
	    return this.lift(new WindowOperator$1(closingSelector));
	}
	var windowWhen_2 = windowWhen$2;
	var WindowOperator$1 = (function () {
	    function WindowOperator(closingSelector) {
	        this.closingSelector = closingSelector;
	    }
	    WindowOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new WindowSubscriber$1(subscriber, this.closingSelector));
	    };
	    return WindowOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var WindowSubscriber$1 = (function (_super) {
	    __extends$122(WindowSubscriber, _super);
	    function WindowSubscriber(destination, closingSelector) {
	        _super.call(this, destination);
	        this.destination = destination;
	        this.closingSelector = closingSelector;
	        this.openWindow();
	    }
	    WindowSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        this.openWindow(innerSub);
	    };
	    WindowSubscriber.prototype.notifyError = function (error, innerSub) {
	        this._error(error);
	    };
	    WindowSubscriber.prototype.notifyComplete = function (innerSub) {
	        this.openWindow(innerSub);
	    };
	    WindowSubscriber.prototype._next = function (value) {
	        this.window.next(value);
	    };
	    WindowSubscriber.prototype._error = function (err) {
	        this.window.error(err);
	        this.destination.error(err);
	        this.unsubscribeClosingNotification();
	    };
	    WindowSubscriber.prototype._complete = function () {
	        this.window.complete();
	        this.destination.complete();
	        this.unsubscribeClosingNotification();
	    };
	    WindowSubscriber.prototype.unsubscribeClosingNotification = function () {
	        if (this.closingNotification) {
	            this.closingNotification.unsubscribe();
	        }
	    };
	    WindowSubscriber.prototype.openWindow = function (innerSub) {
	        if (innerSub === void 0) { innerSub = null; }
	        if (innerSub) {
	            this.remove(innerSub);
	            innerSub.unsubscribe();
	        }
	        var prevWindow = this.window;
	        if (prevWindow) {
	            prevWindow.complete();
	        }
	        var window = this.window = new Subject_1$17.Subject();
	        this.destination.next(window);
	        var closingNotifier = tryCatch_1$17.tryCatch(this.closingSelector)();
	        if (closingNotifier === errorObject_1$17.errorObject) {
	            var err = errorObject_1$17.errorObject.e;
	            this.destination.error(err);
	            this.window.error(err);
	        }
	        else {
	            this.add(this.closingNotification = subscribeToResult_1$36.subscribeToResult(this, closingNotifier));
	        }
	    };
	    return WindowSubscriber;
	}(OuterSubscriber_1$36.OuterSubscriber));


	var windowWhen_1$1 = {
		windowWhen: windowWhen_2
	};

	var Observable_1$161 = Observable_1$2;
	var windowWhen_1 = windowWhen_1$1;
	Observable_1$161.Observable.prototype.windowWhen = windowWhen_1.windowWhen;

	var __extends$123 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var OuterSubscriber_1$37 = OuterSubscriber_1$1;
	var subscribeToResult_1$37 = subscribeToResult_1$1;
	/* tslint:enable:max-line-length */
	/**
	 * Combines the source Observable with other Observables to create an Observable
	 * whose values are calculated from the latest values of each, only when the
	 * source emits.
	 *
	 * <span class="informal">Whenever the source Observable emits a value, it
	 * computes a formula using that value plus the latest values from other input
	 * Observables, then emits the output of that formula.</span>
	 *
	 * <img src="./img/withLatestFrom.png" width="100%">
	 *
	 * `withLatestFrom` combines each value from the source Observable (the
	 * instance) with the latest values from the other input Observables only when
	 * the source emits a value, optionally using a `project` function to determine
	 * the value to be emitted on the output Observable. All input Observables must
	 * emit at least one value before the output Observable will emit a value.
	 *
	 * @example <caption>On every click event, emit an array with the latest timer event plus the click event</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var timer = Rx.Observable.interval(1000);
	 * var result = clicks.withLatestFrom(timer);
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link combineLatest}
	 *
	 * @param {ObservableInput} other An input Observable to combine with the source
	 * Observable. More than one input Observables may be given as argument.
	 * @param {Function} [project] Projection function for combining values
	 * together. Receives all values in order of the Observables passed, where the
	 * first parameter is a value from the source Observable. (e.g.
	 * `a.withLatestFrom(b, c, (a1, b1, c1) => a1 + b1 + c1)`). If this is not
	 * passed, arrays will be emitted on the output Observable.
	 * @return {Observable} An Observable of projected values from the most recent
	 * values from each input Observable, or an array of the most recent values from
	 * each input Observable.
	 * @method withLatestFrom
	 * @owner Observable
	 */
	function withLatestFrom$2() {
	    var args = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        args[_i - 0] = arguments[_i];
	    }
	    var project;
	    if (typeof args[args.length - 1] === 'function') {
	        project = args.pop();
	    }
	    var observables = args;
	    return this.lift(new WithLatestFromOperator(observables, project));
	}
	var withLatestFrom_2 = withLatestFrom$2;
	var WithLatestFromOperator = (function () {
	    function WithLatestFromOperator(observables, project) {
	        this.observables = observables;
	        this.project = project;
	    }
	    WithLatestFromOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new WithLatestFromSubscriber(subscriber, this.observables, this.project));
	    };
	    return WithLatestFromOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var WithLatestFromSubscriber = (function (_super) {
	    __extends$123(WithLatestFromSubscriber, _super);
	    function WithLatestFromSubscriber(destination, observables, project) {
	        _super.call(this, destination);
	        this.observables = observables;
	        this.project = project;
	        this.toRespond = [];
	        var len = observables.length;
	        this.values = new Array(len);
	        for (var i = 0; i < len; i++) {
	            this.toRespond.push(i);
	        }
	        for (var i = 0; i < len; i++) {
	            var observable = observables[i];
	            this.add(subscribeToResult_1$37.subscribeToResult(this, observable, observable, i));
	        }
	    }
	    WithLatestFromSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        this.values[outerIndex] = innerValue;
	        var toRespond = this.toRespond;
	        if (toRespond.length > 0) {
	            var found = toRespond.indexOf(outerIndex);
	            if (found !== -1) {
	                toRespond.splice(found, 1);
	            }
	        }
	    };
	    WithLatestFromSubscriber.prototype.notifyComplete = function () {
	        // noop
	    };
	    WithLatestFromSubscriber.prototype._next = function (value) {
	        if (this.toRespond.length === 0) {
	            var args = [value].concat(this.values);
	            if (this.project) {
	                this._tryProject(args);
	            }
	            else {
	                this.destination.next(args);
	            }
	        }
	    };
	    WithLatestFromSubscriber.prototype._tryProject = function (args) {
	        var result;
	        try {
	            result = this.project.apply(this, args);
	        }
	        catch (err) {
	            this.destination.error(err);
	            return;
	        }
	        this.destination.next(result);
	    };
	    return WithLatestFromSubscriber;
	}(OuterSubscriber_1$37.OuterSubscriber));


	var withLatestFrom_1$1 = {
		withLatestFrom: withLatestFrom_2
	};

	var Observable_1$162 = Observable_1$2;
	var withLatestFrom_1 = withLatestFrom_1$1;
	Observable_1$162.Observable.prototype.withLatestFrom = withLatestFrom_1.withLatestFrom;

	var Observable_1$163 = Observable_1$2;
	var zip_1$3 = zip$5;
	Observable_1$163.Observable.prototype.zip = zip_1$3.zipProto;

	var zip_1$4 = zip$5;
	/**
	 * @param project
	 * @return {Observable<R>|WebSocketSubject<T>|Observable<T>}
	 * @method zipAll
	 * @owner Observable
	 */
	function zipAll$2(project) {
	    return this.lift(new zip_1$4.ZipOperator(project));
	}
	var zipAll_2 = zipAll$2;


	var zipAll_1$1 = {
		zipAll: zipAll_2
	};

	var Observable_1$164 = Observable_1$2;
	var zipAll_1 = zipAll_1$1;
	Observable_1$164.Observable.prototype.zipAll = zipAll_1.zipAll;

	var SubscriptionLog = (function () {
	    function SubscriptionLog(subscribedFrame, unsubscribedFrame) {
	        if (unsubscribedFrame === void 0) { unsubscribedFrame = Number.POSITIVE_INFINITY; }
	        this.subscribedFrame = subscribedFrame;
	        this.unsubscribedFrame = unsubscribedFrame;
	    }
	    return SubscriptionLog;
	}());
	var SubscriptionLog_2 = SubscriptionLog;


	var SubscriptionLog_1$2 = {
		SubscriptionLog: SubscriptionLog_2
	};

	var SubscriptionLog_1$1 = SubscriptionLog_1$2;
	var SubscriptionLoggable = (function () {
	    function SubscriptionLoggable() {
	        this.subscriptions = [];
	    }
	    SubscriptionLoggable.prototype.logSubscribedFrame = function () {
	        this.subscriptions.push(new SubscriptionLog_1$1.SubscriptionLog(this.scheduler.now()));
	        return this.subscriptions.length - 1;
	    };
	    SubscriptionLoggable.prototype.logUnsubscribedFrame = function (index) {
	        var subscriptionLogs = this.subscriptions;
	        var oldSubscriptionLog = subscriptionLogs[index];
	        subscriptionLogs[index] = new SubscriptionLog_1$1.SubscriptionLog(oldSubscriptionLog.subscribedFrame, this.scheduler.now());
	    };
	    return SubscriptionLoggable;
	}());
	var SubscriptionLoggable_2 = SubscriptionLoggable;


	var SubscriptionLoggable_1$1 = {
		SubscriptionLoggable: SubscriptionLoggable_2
	};

	function applyMixins(derivedCtor, baseCtors) {
	    for (var i = 0, len = baseCtors.length; i < len; i++) {
	        var baseCtor = baseCtors[i];
	        var propertyKeys = Object.getOwnPropertyNames(baseCtor.prototype);
	        for (var j = 0, len2 = propertyKeys.length; j < len2; j++) {
	            var name_1 = propertyKeys[j];
	            derivedCtor.prototype[name_1] = baseCtor.prototype[name_1];
	        }
	    }
	}
	var applyMixins_2 = applyMixins;


	var applyMixins_1$1 = {
		applyMixins: applyMixins_2
	};

	var __extends$125 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Observable_1$166 = Observable_1$2;
	var Subscription_1$18 = Subscription_1$3;
	var SubscriptionLoggable_1 = SubscriptionLoggable_1$1;
	var applyMixins_1 = applyMixins_1$1;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var ColdObservable = (function (_super) {
	    __extends$125(ColdObservable, _super);
	    function ColdObservable(messages, scheduler) {
	        _super.call(this, function (subscriber) {
	            var observable = this;
	            var index = observable.logSubscribedFrame();
	            subscriber.add(new Subscription_1$18.Subscription(function () {
	                observable.logUnsubscribedFrame(index);
	            }));
	            observable.scheduleMessages(subscriber);
	            return subscriber;
	        });
	        this.messages = messages;
	        this.subscriptions = [];
	        this.scheduler = scheduler;
	    }
	    ColdObservable.prototype.scheduleMessages = function (subscriber) {
	        var messagesLength = this.messages.length;
	        for (var i = 0; i < messagesLength; i++) {
	            var message = this.messages[i];
	            subscriber.add(this.scheduler.schedule(function (_a) {
	                var message = _a.message, subscriber = _a.subscriber;
	                message.notification.observe(subscriber);
	            }, message.frame, { message: message, subscriber: subscriber }));
	        }
	    };
	    return ColdObservable;
	}(Observable_1$166.Observable));
	var ColdObservable_2 = ColdObservable;
	applyMixins_1.applyMixins(ColdObservable, [SubscriptionLoggable_1.SubscriptionLoggable]);


	var ColdObservable_1$1 = {
		ColdObservable: ColdObservable_2
	};

	var __extends$126 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subject_1$18 = Subject_1$1;
	var Subscription_1$19 = Subscription_1$3;
	var SubscriptionLoggable_1$3 = SubscriptionLoggable_1$1;
	var applyMixins_1$3 = applyMixins_1$1;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var HotObservable = (function (_super) {
	    __extends$126(HotObservable, _super);
	    function HotObservable(messages, scheduler) {
	        _super.call(this);
	        this.messages = messages;
	        this.subscriptions = [];
	        this.scheduler = scheduler;
	    }
	    HotObservable.prototype._subscribe = function (subscriber) {
	        var subject = this;
	        var index = subject.logSubscribedFrame();
	        subscriber.add(new Subscription_1$19.Subscription(function () {
	            subject.logUnsubscribedFrame(index);
	        }));
	        return _super.prototype._subscribe.call(this, subscriber);
	    };
	    HotObservable.prototype.setup = function () {
	        var subject = this;
	        var messagesLength = subject.messages.length;
	        /* tslint:disable:no-var-keyword */
	        for (var i = 0; i < messagesLength; i++) {
	            (function () {
	                var message = subject.messages[i];
	                /* tslint:enable */
	                subject.scheduler.schedule(function () { message.notification.observe(subject); }, message.frame);
	            })();
	        }
	    };
	    return HotObservable;
	}(Subject_1$18.Subject));
	var HotObservable_2 = HotObservable;
	applyMixins_1$3.applyMixins(HotObservable, [SubscriptionLoggable_1$3.SubscriptionLoggable]);


	var HotObservable_1$1 = {
		HotObservable: HotObservable_2
	};

	var __extends$127 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AsyncAction_1$5 = AsyncAction_1$1;
	var AsyncScheduler_1$5 = AsyncScheduler_1$1;
	var VirtualTimeScheduler$1 = (function (_super) {
	    __extends$127(VirtualTimeScheduler, _super);
	    function VirtualTimeScheduler(SchedulerAction, maxFrames) {
	        var _this = this;
	        if (SchedulerAction === void 0) { SchedulerAction = VirtualAction; }
	        if (maxFrames === void 0) { maxFrames = Number.POSITIVE_INFINITY; }
	        _super.call(this, SchedulerAction, function () { return _this.frame; });
	        this.maxFrames = maxFrames;
	        this.frame = 0;
	        this.index = -1;
	    }
	    /**
	     * Prompt the Scheduler to execute all of its queued actions, therefore
	     * clearing its queue.
	     * @return {void}
	     */
	    VirtualTimeScheduler.prototype.flush = function () {
	        var _a = this, actions = _a.actions, maxFrames = _a.maxFrames;
	        var error, action;
	        while ((action = actions.shift()) && (this.frame = action.delay) <= maxFrames) {
	            if (error = action.execute(action.state, action.delay)) {
	                break;
	            }
	        }
	        if (error) {
	            while (action = actions.shift()) {
	                action.unsubscribe();
	            }
	            throw error;
	        }
	    };
	    VirtualTimeScheduler.frameTimeFactor = 10;
	    return VirtualTimeScheduler;
	}(AsyncScheduler_1$5.AsyncScheduler));
	var VirtualTimeScheduler_2 = VirtualTimeScheduler$1;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var VirtualAction = (function (_super) {
	    __extends$127(VirtualAction, _super);
	    function VirtualAction(scheduler, work, index) {
	        if (index === void 0) { index = scheduler.index += 1; }
	        _super.call(this, scheduler, work);
	        this.scheduler = scheduler;
	        this.work = work;
	        this.index = index;
	        this.active = true;
	        this.index = scheduler.index = index;
	    }
	    VirtualAction.prototype.schedule = function (state, delay) {
	        if (delay === void 0) { delay = 0; }
	        if (!this.id) {
	            return _super.prototype.schedule.call(this, state, delay);
	        }
	        this.active = false;
	        // If an action is rescheduled, we save allocations by mutating its state,
	        // pushing it to the end of the scheduler queue, and recycling the action.
	        // But since the VirtualTimeScheduler is used for testing, VirtualActions
	        // must be immutable so they can be inspected later.
	        var action = new VirtualAction(this.scheduler, this.work);
	        this.add(action);
	        return action.schedule(state, delay);
	    };
	    VirtualAction.prototype.requestAsyncId = function (scheduler, id, delay) {
	        if (delay === void 0) { delay = 0; }
	        this.delay = scheduler.frame + delay;
	        var actions = scheduler.actions;
	        actions.push(this);
	        actions.sort(VirtualAction.sortActions);
	        return true;
	    };
	    VirtualAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
	        if (delay === void 0) { delay = 0; }
	        return undefined;
	    };
	    VirtualAction.prototype._execute = function (state, delay) {
	        if (this.active === true) {
	            return _super.prototype._execute.call(this, state, delay);
	        }
	    };
	    VirtualAction.sortActions = function (a, b) {
	        if (a.delay === b.delay) {
	            if (a.index === b.index) {
	                return 0;
	            }
	            else if (a.index > b.index) {
	                return 1;
	            }
	            else {
	                return -1;
	            }
	        }
	        else if (a.delay > b.delay) {
	            return 1;
	        }
	        else {
	            return -1;
	        }
	    };
	    return VirtualAction;
	}(AsyncAction_1$5.AsyncAction));
	var VirtualAction_1 = VirtualAction;


	var VirtualTimeScheduler_1$2 = {
		VirtualTimeScheduler: VirtualTimeScheduler_2,
		VirtualAction: VirtualAction_1
	};

	var __extends$124 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Observable_1$165 = Observable_1$2;
	var Notification_1$6 = Notification_1$2;
	var ColdObservable_1 = ColdObservable_1$1;
	var HotObservable_1 = HotObservable_1$1;
	var SubscriptionLog_1 = SubscriptionLog_1$2;
	var VirtualTimeScheduler_1$1 = VirtualTimeScheduler_1$2;
	var defaultMaxFrame = 750;
	var TestScheduler$1 = (function (_super) {
	    __extends$124(TestScheduler, _super);
	    function TestScheduler(assertDeepEqual) {
	        _super.call(this, VirtualTimeScheduler_1$1.VirtualAction, defaultMaxFrame);
	        this.assertDeepEqual = assertDeepEqual;
	        this.hotObservables = [];
	        this.coldObservables = [];
	        this.flushTests = [];
	    }
	    TestScheduler.prototype.createTime = function (marbles) {
	        var indexOf = marbles.indexOf('|');
	        if (indexOf === -1) {
	            throw new Error('marble diagram for time should have a completion marker "|"');
	        }
	        return indexOf * TestScheduler.frameTimeFactor;
	    };
	    TestScheduler.prototype.createColdObservable = function (marbles, values, error) {
	        if (marbles.indexOf('^') !== -1) {
	            throw new Error('cold observable cannot have subscription offset "^"');
	        }
	        if (marbles.indexOf('!') !== -1) {
	            throw new Error('cold observable cannot have unsubscription marker "!"');
	        }
	        var messages = TestScheduler.parseMarbles(marbles, values, error);
	        var cold = new ColdObservable_1.ColdObservable(messages, this);
	        this.coldObservables.push(cold);
	        return cold;
	    };
	    TestScheduler.prototype.createHotObservable = function (marbles, values, error) {
	        if (marbles.indexOf('!') !== -1) {
	            throw new Error('hot observable cannot have unsubscription marker "!"');
	        }
	        var messages = TestScheduler.parseMarbles(marbles, values, error);
	        var subject = new HotObservable_1.HotObservable(messages, this);
	        this.hotObservables.push(subject);
	        return subject;
	    };
	    TestScheduler.prototype.materializeInnerObservable = function (observable, outerFrame) {
	        var _this = this;
	        var messages = [];
	        observable.subscribe(function (value) {
	            messages.push({ frame: _this.frame - outerFrame, notification: Notification_1$6.Notification.createNext(value) });
	        }, function (err) {
	            messages.push({ frame: _this.frame - outerFrame, notification: Notification_1$6.Notification.createError(err) });
	        }, function () {
	            messages.push({ frame: _this.frame - outerFrame, notification: Notification_1$6.Notification.createComplete() });
	        });
	        return messages;
	    };
	    TestScheduler.prototype.expectObservable = function (observable, unsubscriptionMarbles) {
	        var _this = this;
	        if (unsubscriptionMarbles === void 0) { unsubscriptionMarbles = null; }
	        var actual = [];
	        var flushTest = { actual: actual, ready: false };
	        var unsubscriptionFrame = TestScheduler
	            .parseMarblesAsSubscriptions(unsubscriptionMarbles).unsubscribedFrame;
	        var subscription;
	        this.schedule(function () {
	            subscription = observable.subscribe(function (x) {
	                var value = x;
	                // Support Observable-of-Observables
	                if (x instanceof Observable_1$165.Observable) {
	                    value = _this.materializeInnerObservable(value, _this.frame);
	                }
	                actual.push({ frame: _this.frame, notification: Notification_1$6.Notification.createNext(value) });
	            }, function (err) {
	                actual.push({ frame: _this.frame, notification: Notification_1$6.Notification.createError(err) });
	            }, function () {
	                actual.push({ frame: _this.frame, notification: Notification_1$6.Notification.createComplete() });
	            });
	        }, 0);
	        if (unsubscriptionFrame !== Number.POSITIVE_INFINITY) {
	            this.schedule(function () { return subscription.unsubscribe(); }, unsubscriptionFrame);
	        }
	        this.flushTests.push(flushTest);
	        return {
	            toBe: function (marbles, values, errorValue) {
	                flushTest.ready = true;
	                flushTest.expected = TestScheduler.parseMarbles(marbles, values, errorValue, true);
	            }
	        };
	    };
	    TestScheduler.prototype.expectSubscriptions = function (actualSubscriptionLogs) {
	        var flushTest = { actual: actualSubscriptionLogs, ready: false };
	        this.flushTests.push(flushTest);
	        return {
	            toBe: function (marbles) {
	                var marblesArray = (typeof marbles === 'string') ? [marbles] : marbles;
	                flushTest.ready = true;
	                flushTest.expected = marblesArray.map(function (marbles) {
	                    return TestScheduler.parseMarblesAsSubscriptions(marbles);
	                });
	            }
	        };
	    };
	    TestScheduler.prototype.flush = function () {
	        var hotObservables = this.hotObservables;
	        while (hotObservables.length > 0) {
	            hotObservables.shift().setup();
	        }
	        _super.prototype.flush.call(this);
	        var readyFlushTests = this.flushTests.filter(function (test) { return test.ready; });
	        while (readyFlushTests.length > 0) {
	            var test = readyFlushTests.shift();
	            this.assertDeepEqual(test.actual, test.expected);
	        }
	    };
	    TestScheduler.parseMarblesAsSubscriptions = function (marbles) {
	        if (typeof marbles !== 'string') {
	            return new SubscriptionLog_1.SubscriptionLog(Number.POSITIVE_INFINITY);
	        }
	        var len = marbles.length;
	        var groupStart = -1;
	        var subscriptionFrame = Number.POSITIVE_INFINITY;
	        var unsubscriptionFrame = Number.POSITIVE_INFINITY;
	        for (var i = 0; i < len; i++) {
	            var frame = i * this.frameTimeFactor;
	            var c = marbles[i];
	            switch (c) {
	                case '-':
	                case ' ':
	                    break;
	                case '(':
	                    groupStart = frame;
	                    break;
	                case ')':
	                    groupStart = -1;
	                    break;
	                case '^':
	                    if (subscriptionFrame !== Number.POSITIVE_INFINITY) {
	                        throw new Error('found a second subscription point \'^\' in a ' +
	                            'subscription marble diagram. There can only be one.');
	                    }
	                    subscriptionFrame = groupStart > -1 ? groupStart : frame;
	                    break;
	                case '!':
	                    if (unsubscriptionFrame !== Number.POSITIVE_INFINITY) {
	                        throw new Error('found a second subscription point \'^\' in a ' +
	                            'subscription marble diagram. There can only be one.');
	                    }
	                    unsubscriptionFrame = groupStart > -1 ? groupStart : frame;
	                    break;
	                default:
	                    throw new Error('there can only be \'^\' and \'!\' markers in a ' +
	                        'subscription marble diagram. Found instead \'' + c + '\'.');
	            }
	        }
	        if (unsubscriptionFrame < 0) {
	            return new SubscriptionLog_1.SubscriptionLog(subscriptionFrame);
	        }
	        else {
	            return new SubscriptionLog_1.SubscriptionLog(subscriptionFrame, unsubscriptionFrame);
	        }
	    };
	    TestScheduler.parseMarbles = function (marbles, values, errorValue, materializeInnerObservables) {
	        if (materializeInnerObservables === void 0) { materializeInnerObservables = false; }
	        if (marbles.indexOf('!') !== -1) {
	            throw new Error('conventional marble diagrams cannot have the ' +
	                'unsubscription marker "!"');
	        }
	        var len = marbles.length;
	        var testMessages = [];
	        var subIndex = marbles.indexOf('^');
	        var frameOffset = subIndex === -1 ? 0 : (subIndex * -this.frameTimeFactor);
	        var getValue = typeof values !== 'object' ?
	            function (x) { return x; } :
	            function (x) {
	                // Support Observable-of-Observables
	                if (materializeInnerObservables && values[x] instanceof ColdObservable_1.ColdObservable) {
	                    return values[x].messages;
	                }
	                return values[x];
	            };
	        var groupStart = -1;
	        for (var i = 0; i < len; i++) {
	            var frame = i * this.frameTimeFactor + frameOffset;
	            var notification = void 0;
	            var c = marbles[i];
	            switch (c) {
	                case '-':
	                case ' ':
	                    break;
	                case '(':
	                    groupStart = frame;
	                    break;
	                case ')':
	                    groupStart = -1;
	                    break;
	                case '|':
	                    notification = Notification_1$6.Notification.createComplete();
	                    break;
	                case '^':
	                    break;
	                case '#':
	                    notification = Notification_1$6.Notification.createError(errorValue || 'error');
	                    break;
	                default:
	                    notification = Notification_1$6.Notification.createNext(getValue(c));
	                    break;
	            }
	            if (notification) {
	                testMessages.push({ frame: groupStart > -1 ? groupStart : frame, notification: notification });
	            }
	        }
	        return testMessages;
	    };
	    return TestScheduler;
	}(VirtualTimeScheduler_1$1.VirtualTimeScheduler));

	var root_1$13 = root$1;
	var RequestAnimationFrameDefinition = (function () {
	    function RequestAnimationFrameDefinition(root) {
	        if (root.requestAnimationFrame) {
	            this.cancelAnimationFrame = root.cancelAnimationFrame.bind(root);
	            this.requestAnimationFrame = root.requestAnimationFrame.bind(root);
	        }
	        else if (root.mozRequestAnimationFrame) {
	            this.cancelAnimationFrame = root.mozCancelAnimationFrame.bind(root);
	            this.requestAnimationFrame = root.mozRequestAnimationFrame.bind(root);
	        }
	        else if (root.webkitRequestAnimationFrame) {
	            this.cancelAnimationFrame = root.webkitCancelAnimationFrame.bind(root);
	            this.requestAnimationFrame = root.webkitRequestAnimationFrame.bind(root);
	        }
	        else if (root.msRequestAnimationFrame) {
	            this.cancelAnimationFrame = root.msCancelAnimationFrame.bind(root);
	            this.requestAnimationFrame = root.msRequestAnimationFrame.bind(root);
	        }
	        else if (root.oRequestAnimationFrame) {
	            this.cancelAnimationFrame = root.oCancelAnimationFrame.bind(root);
	            this.requestAnimationFrame = root.oRequestAnimationFrame.bind(root);
	        }
	        else {
	            this.cancelAnimationFrame = root.clearTimeout.bind(root);
	            this.requestAnimationFrame = function (cb) { return root.setTimeout(cb, 1000 / 60); };
	        }
	    }
	    return RequestAnimationFrameDefinition;
	}());
	var RequestAnimationFrameDefinition_1 = RequestAnimationFrameDefinition;
	var AnimationFrame_1$1 = new RequestAnimationFrameDefinition(root_1$13.root);


	var AnimationFrame = {
		RequestAnimationFrameDefinition: RequestAnimationFrameDefinition_1,
		AnimationFrame: AnimationFrame_1$1
	};

	var __extends$128 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AsyncAction_1$6 = AsyncAction_1$1;
	var AnimationFrame_1 = AnimationFrame;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var AnimationFrameAction = (function (_super) {
	    __extends$128(AnimationFrameAction, _super);
	    function AnimationFrameAction(scheduler, work) {
	        _super.call(this, scheduler, work);
	        this.scheduler = scheduler;
	        this.work = work;
	    }
	    AnimationFrameAction.prototype.requestAsyncId = function (scheduler, id, delay) {
	        if (delay === void 0) { delay = 0; }
	        // If delay is greater than 0, request as an async action.
	        if (delay !== null && delay > 0) {
	            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
	        }
	        // Push the action to the end of the scheduler queue.
	        scheduler.actions.push(this);
	        // If an animation frame has already been requested, don't request another
	        // one. If an animation frame hasn't been requested yet, request one. Return
	        // the current animation frame request id.
	        return scheduler.scheduled || (scheduler.scheduled = AnimationFrame_1.AnimationFrame.requestAnimationFrame(scheduler.flush.bind(scheduler, null)));
	    };
	    AnimationFrameAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
	        if (delay === void 0) { delay = 0; }
	        // If delay exists and is greater than 0, or if the delay is null (the
	        // action wasn't rescheduled) but was originally scheduled as an async
	        // action, then recycle as an async action.
	        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
	            return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
	        }
	        // If the scheduler queue is empty, cancel the requested animation frame and
	        // set the scheduled flag to undefined so the next AnimationFrameAction will
	        // request its own.
	        if (scheduler.actions.length === 0) {
	            AnimationFrame_1.AnimationFrame.cancelAnimationFrame(id);
	            scheduler.scheduled = undefined;
	        }
	        // Return undefined so the action knows to request a new async id if it's rescheduled.
	        return undefined;
	    };
	    return AnimationFrameAction;
	}(AsyncAction_1$6.AsyncAction));
	var AnimationFrameAction_2 = AnimationFrameAction;


	var AnimationFrameAction_1$1 = {
		AnimationFrameAction: AnimationFrameAction_2
	};

	var __extends$129 = (commonjsGlobal && commonjsGlobal.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AsyncScheduler_1$6 = AsyncScheduler_1$1;
	var AnimationFrameScheduler = (function (_super) {
	    __extends$129(AnimationFrameScheduler, _super);
	    function AnimationFrameScheduler() {
	        _super.apply(this, arguments);
	    }
	    AnimationFrameScheduler.prototype.flush = function (action) {
	        this.active = true;
	        this.scheduled = undefined;
	        var actions = this.actions;
	        var error;
	        var index = -1;
	        var count = actions.length;
	        action = action || actions.shift();
	        do {
	            if (error = action.execute(action.state, action.delay)) {
	                break;
	            }
	        } while (++index < count && (action = actions.shift()));
	        this.active = false;
	        if (error) {
	            while (++index < count && (action = actions.shift())) {
	                action.unsubscribe();
	            }
	            throw error;
	        }
	    };
	    return AnimationFrameScheduler;
	}(AsyncScheduler_1$6.AsyncScheduler));
	var AnimationFrameScheduler_2 = AnimationFrameScheduler;


	var AnimationFrameScheduler_1$1 = {
		AnimationFrameScheduler: AnimationFrameScheduler_2
	};

	var AnimationFrameAction_1 = AnimationFrameAction_1$1;
	var AnimationFrameScheduler_1 = AnimationFrameScheduler_1$1;
	/**
	 *
	 * Animation Frame Scheduler
	 *
	 * <span class="informal">Perform task when `window.requestAnimationFrame` would fire</span>
	 *
	 * When `animationFrame` scheduler is used with delay, it will fall back to {@link async} scheduler
	 * behaviour.
	 *
	 * Without delay, `animationFrame` scheduler can be used to create smooth browser animations.
	 * It makes sure scheduled task will happen just before next browser content repaint,
	 * thus performing animations as efficiently as possible.
	 *
	 * @example <caption>Schedule div height animation</caption>
	 * const div = document.querySelector('.some-div');
	 *
	 * Rx.Scheduler.schedule(function(height) {
	 *   div.style.height = height + "px";
	 *
	 *   this.schedule(height + 1);  // `this` references currently executing Action,
	 *                               // which we reschedule with new state
	 * }, 0, 0);
	 *
	 * // You will see .some-div element growing in height
	 *
	 *
	 * @static true
	 * @name animationFrame
	 * @owner Scheduler
	 */
	var animationFrame_1$1 = new AnimationFrameScheduler_1.AnimationFrameScheduler(AnimationFrameAction_1.AnimationFrameAction);

	/* tslint:enable:no-unused-variable */
	var Observable_1 = Observable_1$2;
	var Observable = Observable_1.Observable;

	var rxDemo = (function () {
	    function rxDemo() {
	        this._canvas = null;
	        this._ctx = null;
	    }
	    rxDemo.of = function () {
	        var obj = new this();
	        return obj;
	    };
	    rxDemo.prototype.run = function () {
	        var _this = this;
	        this._getCanvasCtx();
	        Observable.combineLatest(this._mouseStream(), this._starStream(), this._enemyStream(), function (x, y, z) {
	            return {
	                spaceship: x,
	                star: y,
	                enemy: z
	            };
	        }).sampleTime(40).subscribe(function (res) {
	            _this._renderScene(res);
	        });
	    };
	    rxDemo.prototype._renderScene = function (actor) {
	        var _this = this;
	        this._drawStars(actor.star);
	        this._drawTriangle(actor.spaceship.x, actor.spaceship.y, 20, '#ff0000', 'up');
	        actor.enemy.forEach(function (enemy) {
	            enemy.y += 5;
	            _this._drawTriangle(enemy.x, enemy.y, 20, '#00ff00', 'down');
	        });
	    };
	    rxDemo.prototype._enemyStream = function () {
	        var _this = this;
	        return Observable.interval(1000).scan(function (arr) {
	            arr.push({
	                x: ~~(Math.random() * _this._canvas.width),
	                y: -30
	            });
	            return arr;
	        }, []);
	    };
	    rxDemo.prototype._mouseStream = function () {
	        var y = this._canvas.height - 30;
	        return Observable.fromEvent(this._canvas, "mousemove").map(function (e) {
	            return {
	                x: e.clientX,
	                y: y
	            };
	        }).startWith({
	            x: this._canvas.width / 2,
	            y: y
	        });
	    };
	    rxDemo.prototype._starStream = function () {
	        var _this = this;
	        var speed = 40, number = 250;
	        return Observable.range(1, number).map(function (res) {
	            return {
	                x: ~~(Math.random() * _this._canvas.width),
	                y: ~~(Math.random() * _this._canvas.height),
	                size: Math.random() * 3 + 1
	            };
	        }).toArray().flatMap(function (arr) {
	            return Observable.interval(speed).map(function () {
	                arr.forEach(function (star) {
	                    if (star.y >= _this._canvas.height)
	                        star.y = 0;
	                    else
	                        star.y += 3;
	                    if (star.x >= _this._canvas.width)
	                        star.x = 0;
	                    else
	                        star.x += 3;
	                });
	                return arr;
	            });
	        });
	    };
	    rxDemo.prototype._drawTriangle = function (x, y, width, color, direction) {
	        var ctx = this._ctx;
	        ctx.fillStyle = color;
	        ctx.beginPath();
	        ctx.moveTo(x - width, y);
	        ctx.lineTo(x, direction === 'up' ? y - width : y + width);
	        ctx.lineTo(x + width, y);
	        ctx.lineTo(x - width, y);
	        ctx.fill();
	    };
	    rxDemo.prototype._drawStars = function (stars) {
	        var _this = this;
	        this._ctx.fillStyle = '#000000';
	        this._ctx.fillRect(0, 0, this._canvas.width, this._canvas.height);
	        this._ctx.fillStyle = '#ffffff';
	        stars.forEach(function (star) {
	            _this._ctx.fillRect(star.x, star.y, star.size, star.size);
	        });
	    };
	    rxDemo.prototype._getCanvasCtx = function () {
	        this._canvas = document.getElementById("webgl");
	        this._canvas.width = window.innerWidth - 20;
	        this._canvas.height = window.innerHeight - 20;
	        this._ctx = this._canvas.getContext("2d");
	    };
	    return rxDemo;
	}());
	rxDemo.of().run();

	exports.demo = demo;
	exports.discount = discount;
	exports.Game = Game;
	exports.imgLoad = imgLoad;
	exports.parse = parse;
	exports.rxDemo = rxDemo;
	exports.AjaxUtil = AjaxUtil;
	exports.Either = Either;
	exports.Right = Right;
	exports.Left = Left;
	exports.IO = IO;
	exports.Maybe = Maybe;
	exports.Just = Just;
	exports.Nothing = Nothing;
	exports.chain = chain$1;
	exports.map = map$1;
	exports.either = either;
	exports.trace = trace;
	exports.objToStr = objToStr;
	exports.slice = slice$1;
	exports.lower = lower;
	exports.trim = trim$1;
	exports.type = type;
	exports.props = props;

	Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=wdfl.js.map
